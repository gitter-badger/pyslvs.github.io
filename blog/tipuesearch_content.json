{"pages":[{"title":"About","text":"Pyslvs.com Blog The repository of http://pyslvs.com is located at https://github.com/pyslvs/pyslvs.github.io . Pyslvs is a planar linkage simulation and synthesis package built with Python3 and PyQt5.","tags":"misc","url":"https://pyslvs.github.io/blog/pages/about/"},{"title":"Python 物件導向","text":"請學員瞭解關於物件導向的概念及特性。 非物件導向 名詞解釋： 變數 (Variable)：代表儲存一個或多個的 單一資料 或 資料集 ，能夠被 定義 (Define) 與 引用 (Reference)。 函式 (Function)：封裝的程式碼（在程式中定義），以能在特定需求時 輸入 資料與 輸出 結果。 通常物件導向的程式語言會比較高階，也能夠支援非物件導向的操作。不過有些特例如 C# 語言，所有程式碼必須在物件導向概念中實現，非物件導向的實作則是「靜態函式」對應一般函式；「靜態類別」對應模組 (Module)，甚至連進入點 (Entry point) 都必須在類別中。 物件導向 名詞解釋： 類別 / 類型 / 型別 (Class)：定義 資料形式 與 資料操作 。 物件 (Object)：是 類別 的 實例 (Instance)，可以被變數儲存。 在擁有物件導向的程式語言中， 函式也是一種物件 ，並且有自己的類別，如 匿名函式 (Anonymous function, Function literal, Lambda expression)。 程式中若要獲得物件，是 由類別產生 ，或使用字面表示式 (Literal expression)。而某些能夠支援更抽象概念的程式語言中，類別也是一種物件，因此類別也有自己的類別，稱為 元類 (Meta Class)，如 Python。 類別有以下特性： 封裝性 (Encapsulation)：可以 攜帶各種資料或資料集 ，並且由於物件是實例的關係，每個物件是獨立個體，其資料可以有著不同的內容。 繼承 (Inheritance)：定義簡單的類別後，較複雜的類別可以從簡單的類別 提取其功能 。 多形 (Polymorphism)： 不同類別 可能會有 相同操作 。程式碼在使用該物件時， 強型別 的程式語言（如 C++）必須特別規範， 弱型別 的程式語言（如 Python）會嘗試尋找並進行該操作。 抽象性 (Abstraction)：透過 繼承 和 元類 概念可以表達更抽象的物件概念。 以下將示範 Python 程式碼中如何用 封裝性 與 繼承 呈現各種特性。 封裝性 Python 的基本類型定義語法如下： # Python 中的類型名稱使用 Camal case（單字首大寫）。 # 每個類型與函式定義之間空兩行。 class MyClass : \"\"\"定義 my class。\"\"\" def __init__ ( self , score ): \"\"\"初始化函式。 類別中的 function 稱為方法 (Method)， 其中第一項參數 self 代表此物件。 實際呼叫時會自動填入。 \"\"\" print ( \"初始化！\" ) # 類別中的「變數」稱為成員 (Member)。 # 類別中的「名稱」稱為屬性 (Attribute)。 # members 和 methods 都是 attributes。 # attributes 使用「點」運算子取得。 self . score = score # 私有 attributes 名稱前加上雙底線。 # 名稱會被編碼為 \"_MyClass__score\"。 # 除非用上述名稱呼叫， # 只有本類別的 method 可以呼叫。 self . __score = score + 10 def method1 ( self , p0 ): \"\"\"一個公開的 method， 任何使用本物件的程式都可以呼叫。 \"\"\" print ( \"method 1:\" , self . __score ) # 呼叫一個私有 method。 self . __method2 ( p0 ) def __method2 ( self , p0 ): \"\"\"一個私有的 method。\"\"\" print ( \"method 2:\" , p0 ) # 初始化一個 MyClass 實例。 a = MyClass ( 50 ) # 初始化！ print ( a . score ) # 50 a . method1 ( 20 ) # method 1: 60 # method 2: 20 # 強迫呼叫 print ( a . _MyClass__score ) # 60 # 強迫呼叫 a . _MyClass__method2 ( 30 ) # method 2: 30 上面的類型中，呈現了 封裝性 的效果，一個 MyClass 物件中擁有公有與私有的 attributes，當使用 a 名稱傳送此物件時，隨時可以使用公開 attributes。 繼承 繼承可以將較小類型的 attributes 全部拿來用。在 Python 中，有個類型叫做 object ，提供一些預設特性，所有類型如果沒指定都會繼承它。 繼承語法如下： # 引用斜邊公式 hypotenuse。 from math import hypot class Point : \"\"\"點資料集。\"\"\" def __init__ ( self , x , y ): \"\"\"初始化時設定兩座標並顯示。\"\"\" self . x = x self . y = y self . __show () def __show ( self ): \"\"\"印出 x 和 y。\"\"\" print ( self . x , self . y ) def distance ( self , c ): \"\"\"回傳兩點的距離。\"\"\" return hypot ( c . x - self . x , c . y - self . y ) def move ( self , x , y ): \"\"\"移動座標。\"\"\" self . x = x self . y = y class PointView ( Point ): \"\"\"檢視用的類型，繼承自點。\"\"\" def __init__ ( self , x , y ): # 引用上一個繼承項的 __init__ 函式。 super ( Coordinate , self ) . __init__ ( x , y ) print ( \"Point view\" ) def distance_with_origin ( self ): \"\"\"此點與原點的距離。\"\"\" return hypot ( self . x , self . y ) def __repr__ ( self ): \"\"\"覆寫預設函式 __repr__。 此函式可以定義物件轉成字串時的樣式。 \"\"\" return f \"<Point x={self.x} y={self.y}>\" # 建立點資料 p1。 p1 = Point ( 20 , 30 ) # 20 30 # 建立點資料 p2。 p2 = PointView ( 50 , 70 ) # 50 70 # Point view # 顯示距離。 print ( p2 . distance ( p1 )) # 50 # 顯示 p2 與原點的距離。 print ( p2 . distance_with_origin ()) # 86.02325267042627 # 印出 p1 和 p2。 # 印的時候會呼叫預設函式 __repr__。 print ( p1 ) # <Point object at 一段記憶體位址> print ( p2 ) # <Point x=50 y=70> 上面的範例中， PointView 繼承自 Point ，因此會擁有所有 Point 的公有與私有 attributes，但是私有 attributes 會被編成 _Point__show 的樣式，因此不能直接使用。 另外，當 PointView 的屬性名稱與 Point 重複時（如 __init__ ），會直接覆蓋，因此必須使用 super 函式搜尋到 Point 類型，將 PointView 實體帶入 Point.__init__ 執行。 靜態方法 靜態方法 (static method) 只是掛上類別名稱的函式 (static method)。在 Python 中，靜態方法可以有兩種定義法，稱為 static method 與 class method。 class Point : def __init__ ( self , x , y ): self . x = x self . y = y def __eq__ ( self , p ): \"\"\"實做相等運算子 ==。\"\"\" return self . x == p . x and self . y == p . y @staticmethod def s_method ( x , y ): \"\"\"Static method.\"\"\" return Point ( x + 10 , y + 10 ) @classmethod def c_method ( cls , x , y ): return cls ( x + 10 , y + 10 ) p1 = Point . s_method ( 20 , 30 ) p2 = Point . c_method ( 20 , 30 ) print ( p1 == p2 ) # True 兩者的差異只在於 class method 的會傳入當前類型，所以在繼承上有差別。 延伸閱讀 - 類別與實體的關係 類別也有 attributes，稱為 class attributes。如 Point.__init__ 、 Point._Point__show 等。而 p1.x 是因為上面的範例使用 self.x = x 的語法產生，這是後天賦予物件的，又稱 object attributes。物件可以使用 class attributes，但是類別沒有 object attributes。 關於 class attributes，每個 object 的 class member 其實是使用相同名稱，但是 class method 是複製過來的，如下： class A : a = 10 def method ( self , p0 , p1 ): pass a = A () b = A () print ( a . a is b . a ) # True print ( a . method is b . method ) # False 是因為下列程式是相同結果的： a . method ( p0 , p1 ) A . method ( a , p0 , p1 ) Python 內建的 type 函式會回傳實體的類型。而事實上 type 是一種類型，而且是所有類型的元類，因此初始化時可以「作出」實體的類型。","tags":"學習","url":"https://pyslvs.github.io/blog/yuan_2018-11-19.html"},{"title":"Python 與 C / C++ 簽章","text":"學習辨認 Python 與 C / C++ 的函式呼叫方式。 簽章 函式 (Function) 能在特定需求時 輸入 資料與 輸出 結果，輸入與輸出值稱為 參數 (Argument)。 以強型別程式語言 C 來說，一個輸入 3 個參數，輸出 1 個參數的函式是這樣宣告的： int func ( int p0 , int p1 , float p2 ); 但是 Python 沒有類型標示，因此函式會如此定義： def func ( p0 , p1 , p2 ): ... 函式 func 的輸入與輸出類型（如「輸入 3 個參數、輸出 1 個參數」），稱為 簽章 (Signature)。 Python 是弱型別語言，簽章只有強制規定參數 數量 ，而沒有規定參數類型。 另外，單一化的輸入需求不足以滿足函式應用範圍，而產生 多載 (Overload) 的功能，以支援不同選項、不同類型的輸入。以強型別程式語言 C++ 為例： // 注意：C 語言不支援多載。 // C++ 多載宣告，編譯時會依照簽章自動生成四種函式。 // 預設值也算是一種多載。 // 撰寫程式時只需要寫 func 即可。 int func ( int p0 , int p1 , long double p2 , bool p3 = false ); int func ( int p0 , int p1 , double p2 ) { // 會需要寫轉換型別的接繞函式。 // 如果簽章搞錯，會造成無限遞迴 (Recursive)。 return func ( p0 , p1 , ( long double ) p2 ); } int func ( int p0 , int p1 , float p2 ) { // 會需要調整設定。 return func ( p0 , p1 , ( long double ) p2 , true ); } 上面的例子中，為了支援強型別的標記，函式必須製作多種不同類型的簽章，若有更多需求，則必須使用模板 (Template)： // 模板宣告，編譯時會自動生成多載簽章。 template < typename T > int func ( int p0 , int p1 , T p2 ); // 如果要支援其他參數，又要混合多載。 int func ( int p0 , int p1 , long double p2 , bool p3 = false ); 在 Python 中， 沒有多載 、 沒有模板 、 沒有型別要求 ，因此大幅簡化定義。唯一要解決的問題是滿足參數數量的變化。 預設值 預設值只能從最後開始使用等於 = 符號 連續 定義，不可以隨意指定其中的參數。 在呼叫時使用 = 符號為 關鍵字參數 ，與定義時相同，只能從最後開始 連續 填入。 def func ( p0 , p1 , p2 = 20 , p3 = True ): pass # 可以這樣使用： func ( a0 , a1 , a2 , a3 ) # 全部填滿。 func ( a0 , a1 , a2 ) # 使用部分預設值。 func ( a0 , a1 , p3 = a3 ) # 名稱對應，使用部分預設值。 func ( a0 , a1 ) # 全部使用預設值。 強制名稱對應 使用特殊符號 * ，其後所有參數不分順序，強制使用名稱對應。如果有參數沒有填入或沒有預設值，會引發錯誤。 def func ( p0 , p1 , * , p2 , p3 = True ): pass # 可以這樣使用： func ( a0 , a1 , p2 = a2 , p3 = a3 ) # 全部填滿。 func ( a0 , a1 , p2 = a2 ) # 名稱對應，全部使用預設值。 順序收集與對應收集 使用星號 * ，該變數會收集多餘填入的 位置參數 (Positional argument)。多餘的參數會收集成 tuple 容器，若沒有多餘參數，該參數會是空的 tuple 容器。 使用雙星號 ** ，該變數會收集多餘填入的 關鍵字參數 (Keyword argument)。多餘的參數會收集成 dict 容器，若沒有多餘參數，該參數會是空的 dict 容器。 兩者可以擇一或混合使用，但是定義時單星號參數一定要在前面，其後所有參數不分順序。 def func ( p0 , p1 , * p2 , ** p3 , p4 , p5 = True ): pass # 可以這樣使用： func ( a0 , a1 , p4 = a4 , p5 = a5 ) # 全部填滿。 # p2 = () # p3 = {} func ( a0 , a1 , p4 = a4 ) # 全部使用預設值。 # p2 = () # p3 = {} func ( a0 , a1 , b1 , b2 , r = b3 , s = b4 , p4 = a3 ) # 多餘值。 # p2 = (b1, b2) # p3 = {'r': b3, 's': b4} 針對「順序容器（如 tuple 、 list ）」或「成對容器（如 dict ）」，填入時可以用 * 、 ** 按關係填入。不過不符合簽章仍然會引發錯誤，應當注意。如： func ( * [ a0 , a1 , b1 , b2 ], ** { 'r' : b3 , 's' : b4 , 'p4' : a3 }) # 或用變數： a_list = [ a1 , b1 , b2 ] b_dict = { 'r' : b3 , 'p4' : a3 } func ( a0 , s = b4 , * a_list , ** b_dict )","tags":"學習","url":"https://pyslvs.github.io/blog/yuan_2018-11-19-2.html"},{"title":"Python 類型註解","text":"基於協同開發，Python 引入了選擇性的類型註解。 建議先瞭解： 物件導向概念 簽章 自行閱讀 Python 的 撰寫風格規定 PEP 8 學員可以藉由類型註解，在程式碼協同時較快辨認變數類型。 類型註解 類型註解 (Typing) 是一種 註解 ，可以為每種參數進行標示。由於文法問題，類型註解並不是強迫性的，不過仍有效用。可藉由每個範圍 (Scope) 的 __annotations__ 名稱取得，若有工具或 IDE 的功能，可以進行靜態分析。 根據 PEP 484 的內容，類型註解物件可以自行製作和定義，但是本節只會將常用容器列出。 基本文法 Python 為 弱型別 (Weak typing) 語言，又稱 鴨子型別 (Duck type)，相較於 強型別 (Strong typing) 語言，只要 變數能用 即可，不能用就引發錯誤。當然這只能在相對安全的直譯式語言 (Interpreted language) 中，因為這裡只要使用 try 語句即可： try : # 測試 a 能不能執行 test_method。 b = a . test_method () except AttributeError : # 沒有 test_method。 c = 20 else : c = b * 2 但是因為執行效能與開發效率問題，一直測試顯然不是好方法，因此 Python 在簽章上引入了類型註解的文法。 簽章的參數中，使用 : 符號後連接類型名稱；回傳值則是使用 -> 記號連接。參照於一般英文符號以及 運算子必須由空白環繞 的規定， : 符號會連接前一個表示式，與下一個表示式間隔空白； -> 記號則是必須由空白環繞。 # 只能從預設值或參數名稱猜測。 def func ( p0 , p1 = 20 , p2 = True ): pass # 直接規定型別。 def func ( p0 : int , p1 : int = 20 , p2 : bool = True ) -> None : pass # 若是太長可以利用括弧換行。 def func ( number : int , size : int = 20 , reverse : bool = True ) -> None : pass 在 Python 3.6 新增單一變數的類型註解文法 ( PEP 526 )。 不過一般可直接辨識的變數就不會使用，例如直接賦予類型的初始化物件。 # 等等會裝入整數。 a : List [ int ] = [] # 這麼明顯就不用了。 a : MyClass = MyClass () Python 的類型註解一般也是用 鴨子型別 的概念標示，提醒開發者「需要這樣使用」，而非「一定需要這種類型」。如： def func ( w ) -> bool : \"\"\"w 是一個會進行疊代與檢索的物件。\"\"\" for i in range ( 20 ): for k in w : if w [ i + 2 ] == 'z' : return True # 應該標示成序列： w : Secquence [ int ] # 而非強迫成某種型態： w : List [ int ] w : Tuple [ int , ... ] 容器 自 Python 3.5 起支援，型別中支援 放入 或 回傳 的型別必須由標準模組 typing 提供。容器的類型註解名稱會跟一般容器名稱不一樣，改成字首大寫。 通常排列習慣將相同性質的容器一起擺放。 from typing import ( # 序列 Tuple , List , Secquence , # 二元搜尋樹 Set , Dict , # 迭代器（產出） Iterator , # 生產器（接收、產出） Generator , # 可呼叫物（函式） Callable , # 邏輯判斷 Optional , Union , Any , ) 使用單一項目的容器： # 其實 tuple 容器是固定長度的。 my_tuple : Tuple [ int , int ] = ( 20 , 20 ) # 不限長度的容器。 my_list : List [ float ] = [ 20. , 50.02 , - 3.006 ] # 不限長度的 tuple 容器（其他變數決定）。 my_tuple : Tuple [ int , ... ] = tuple ( i for i in range ( s )) # 巢狀標示。 w : Set [ Tuple [ int , int ]] = {( 10 , 20 ), ( 30 , 40 ), ( 50 , 60 )} 使用成對項目的容器： d : Dict [ str , List [ int ]] = { 's' : [ 10 , 20 , 30 ], 'b' : [], 'f' : [ 77 , 66 , 55 , 44 ], }","tags":"學習","url":"https://pyslvs.github.io/blog/yuan_2018-11-19-3.html"},{"title":"Python 複製與參照","text":"這邊整理關於 Python 程式語言中的「命名」規則，請學員閱讀。 Python 的設計構想源自 ABC [ 1 ]，採越位規格 ( off-side rule ) 分隔程式區段，其表達式語法 (expression syntax) 與 C 語言類似[ 2 ]，因此會提到其相關規則。在其他類似 C 的程式語言（C++、C#、Java 等，其中 C++ 文法的相似度最高）可能會使用相同的規則處理。 請牢記以下關係： 官方 提供的 Python 單機版直譯器稱為 CPython，因為 該直譯器是純 C 語言編寫，達成 Python 所有功能 。除了 CPython 外，還有以 Java 編寫的 Jython ，以 .net 技術編寫的 Ironpython ，以 Python 編寫的 PyPy , 以 Javascript 編寫的 Brython ，進階版的 Stackless Python 以及專用於微控制器的 Micropython 等。CPython 的原理是將 Python script 翻譯成字節碼 (Bytecode)，並透過解析字節碼來執行，字節碼存放在 __pycache__ 資料夾中。 由於 Python 文法是由 正規表示式 (Regular Expression, RE) 定義的（ 詳見此 ），因此 理論上任何支援 RE 解析功能的程式語言都能寫成 Python 直譯器，包括 Python 本身 ( PyPy )。 以下章節內容關於非 Python 部分可以斟酌吸收。 C 的指派 在 C 語言中，使用 指派 運算子來規劃記憶體存值，該符號為 等於 記號 = 。 int a = 10 ; 上面 C 程式碼的意思為：使用最大為 整數 ( int ) 的記憶體空間 存放 數字 10 ，並且在本程式 範圍 (Scope) 中，這個記憶體空間的代號為 a 。 在 C 語言中 記憶體空間的代號 稱為 變數 (Variable)，透過「宣告」規定在 範圍 中有哪些代號；「定義」可以做記憶體劃分和存值的動作。 /* C 語言的單行註解使用雙斜線，多行使用斜線與星號。 每「行」結尾為分號，會忽略重複空白和所有換行記號。 因此，C 語言可以不用縮排、全部寫同一行，難以閱讀。 */ // C 語言可以任意規劃「範圍」或巢狀範圍，使用大括弧即可。 { // 宣告，沒有任何動作，只是給編譯器看的。 int a ; // 定義，規劃記憶體並存值。 a = 10 ; { // 可以一起寫。 int b = 20 ; // 如果巢狀範圍宣告撞名，會將外部範圍的名稱暫時「隱藏」。 } // 這裡不能用 b。 } 在宣告的範圍外，該變數會被自動刪除，以節省記憶體。因此，在 C 語言中，任何定義的動作都會花費記憶空間。「指派」的文法如下： 左值 = 右值 右值的計算結果為 任意記憶體大小的值 ，而左值 必須 運算出 相應大小 的記憶體空間，透過指派運算子，可以將右值的值複製到左值。另外，一些運算類的指派運算子 += 、 -= 等，是將計算結果存入相同記憶體位置的意思，如 a += 10 同於 a = a + 10 。 甚至在範圍外，也可以使用 C 語言的指標 (Pointer) 功能，攜帶記憶體空間的鑰匙，持有鑰匙，可以直接存取記憶體。以下為 C++ 語言的一個小範例。 /* 指標是一種變數！ 指標是一種二進位代號，代表記憶體區段的「第一個值」。 指標的間隔數是該類型的空間大小，但是 C 語言中 +1 會自動幫忙跳號。 */ // 假設有一把鑰匙（還沒定義）。 int * a ; { // 使用 new 關鍵字初始化 50 個整數，並將第一把鑰匙交給 b。 int * b = new int [ 50 ]; // 將 b 鑰匙複製給 a。 a = b ; } /* b 鑰匙被刪除，但是 50 個整數還在。 如果剛才沒有複製給 a，會遺失 50 個整數的鑰匙，引發記憶體洩漏 (Memory leak)。 */ cout << * ( a + 2 ) << endl ; // 顯示第三位整數的值（第一把鑰匙 +2）。 cout << a [ 0 ] << endl ; // 同上，顯示第一位整數的值。 delete [] a ; // 使用 delete 關鍵字刪除 a 鑰匙的所有值。 若不使用指標，C 語言也有參照物件，相當於取綽號： int a = 10 ; // 為 a 變數取綽號 b。 int & b = a ; b = 2 ; // a = 2 總結：除非特別設計，不然指派運算子都是使用 複製 ，而非參照。 上述流程是不是十分繁瑣且危險？在 Python 中，參考自其他程式語言，引入垃圾回收機制 (Garbage collection)，取代了指標和參照物件的功能。 Python 的指派 Python 的變數稱為 名稱 (Name)，可以視作一張 範圍通行證 ，而非記憶體代號，已經跟 C 語言的意思不一樣了。而透過「指派」，可以發通行證給任何數值，不用管記憶體大小。 一句話解釋規則 ： 所有的數值會自動追蹤與管理，擁有一個或多個名稱的值 可以在該作用範圍使用 ，失去所有名稱的值 會被刪除 。 Python 的表達式 (Expression) 中有種數值稱為字面數值 (literal value)，意指寫出來就是該值，例如 70 的類型是 int ； (1, 2, 3) 的類型是 tuple ； [1, 2, 3] 的類型是 list ； {'a': 20, 'c': 80} 的類型是 dict 。不過只有部分字面數值，任何時候寫出來都 永遠共享記憶體 ，特徵是 不能改變值 ，所有 method 操作結果都回傳副本，不改原始值。 只有 None 、 bool 、 int 、 float 、 complex 、所有字串 (string)、 tuple 類型。 # 相同值的共享記憶體檢查 # 用 is 運算子可以檢查是否為相同記憶體。 # int print ( 10 is 10 ) # True # tuple print (() is ()) # True # list print ([] is []) # False # dict print ({} is {}) # False 來段範例： # 發通行證 a 給數值 10。 a = 10 # 通行證 a 的持有者是 10，發通行證 b 給數值 10。 b = a print ( a is b ) # True # b += 5 來自 C 語言，同於 b = b + 5。 # 對通行證 b 的值做 +5 計算，並對該值發通行證 b。 # 通行證 b 被拔除自 10，交給結果 15。 b += 5 print ( b ) # 15 print ( a ) # 10 print ( a is b ) # False 來一段容器的範例： # list 容器 a = [ 1 , 2 , 3 ] b = a print ( a is b ) # True # 對通行證 b 的容器操作，在尾端加入 4。 b . append ( 4 ) # 使用 del 關鍵字，對通行證 b 的容器操作，刪除第二位值 2。 del b [ 1 ] print ( b ) # [1, 3, 4] print ( a ) # [1, 3, 4] # 幫當前的 a 值複製，重發通行證 b 給複製體。 b = a . copy () # 讓 a 刪除最後一項。 a . pop () print ( a ) # [1, 3] print ( b ) # [1, 3, 4] print ( a is b ) # False 活用上述概念，可以輕鬆達成複製 (Copy) 與參照 (Reference) 功能。 最後介紹範圍的規則： # Python 中，唯二的範圍界線為 Function 與 Class 的定義，而非縮排。 def func ( b ): # 通行證 c 只有效於 func 中。 # 回傳值計算完後通行證 c 會被移除（垃圾回收）。 c = 20 return b + c # 全域通行證 g g = 'abc' # 主程式與 func 的範圍沒有巢狀關係。 def main (): a = 10 # a 進入 func 函數，獲得區域通行證 b。 # 回傳值 30 被丟出 func，獲得區域通行證 d。 d = func ( a ) print ( d ) # 30 # 巢狀函式有巢狀範圍界線。 def nest_func (): # 使用 global 關鍵字指定全域通行證 g。 global g # 全域通行證 g 重新發給 50。 g = 50 # 使用 nonlocal 關鍵字指定上層的區域通行證 d。 nonlocal d # 上層的區域通行證 d 重新發給 20。 d = 20 # 執行巢狀函式。持有 d 的 30 被刪除；持有 g 的 'abc' 被刪除。 nest_func () print ( g ) # 50 print ( d ) # 20 # 執行 main main ()","tags":"學習","url":"https://pyslvs.github.io/blog/yuan_2018-11-18.html"},{"title":"Python 控制流程","text":"請學員從下列圖片中的控制流程方法對應 Python 中的語法。 # Condition statement if condition_1 : # Do for condition 1. elif condition_2 : # Do for condition 2. else : # Do for other case. # Loops for i in range ( 10 ): if i == 4 : continue # Do for 0~9 except 4. k = 'b' w = [ 'a' , 'b' , 'c' , 'd' , 'e' ] while w : # Condition: 'w' is not empty. if k == w . pop (): # Remove last one and compare it with 'k'. break # Stop the loop if k is equal with last one. print ( w ) # w = ['a'] # note: \"for\" loop is done with \"while\" loop. for c in [ 'a' , 'b' , 'c' ]: if c == 'b' : continue # Do for 'a'~'c' except 'b'. i = 0 c_list = [ 'a' , 'b' , 'c' ] while i < len ( c_list ): # 'i' is in the range of length of 'c_list'. c = c_list [ i ] # Get the value from 'c_list'. if c == 'b' : continue # Do for 'a'~'c' except 'b'. i += 1 # 'i' increase 1. # Define a function 'func'. def func ( a , b ): c = int ( a ) # Copy 'a' and turn it to an integer, and save it to 'c'. if c > 30 : # If 'c' is over 30, set it to 30. c = 30 return b - c # Return a value that obtained by 'b' minus with 'c'. # Garbage collecting for 'a', 'b', 'c'. Except 'b' - 'c'. # Use the function. d = func ( 27.9705 , 50 ) # 'd' is 23. d -= func ( '70' , d ) # 'd' minus -7, so 'd' will be set to 30. func ( 30.5 , d ) # Return value is 0, but it will be discarded and deleted. # The following statements are the same in the last line of function. def f ( w ): w . append ( w . pop ( 0 )) # No return statement. def f ( w ): w . append ( w . pop ( 0 )) return def f (): w . append ( w . pop ( 0 )) return None # The first is recommended. 關鍵字 ： Control flow - 控制流程 Condition statement - 條件式 Loop - 迴圈 Iterate - 迭代 Function call - 函式呼叫 Function arguments - 函式參數 Scope - 範圍 Garbage collection - 垃圾回收 延伸閱讀 - 執行緒 ： Qt 中的 signal 與 slot 為透過多執行緒配置實現的功能。","tags":"學習","url":"https://pyslvs.github.io/blog/yuan_2018-11-18-2.html"},{"title":"Testing Mac OS X with specific Python version in Travis CI","text":"How to test Python executable file with specific version in Mac OS X? Travis CI basic options MacPorts Python, pip and PyInstaller Travis CI basic options Test with Ubuntu and Mac OS X platform. Because of Travis CI are not provide Python language in \"osx\" platform, so we choose \"generic\". With \"matrix\" option, the Linux and OS X platform can test at same time. In OS X platform, set a \"PYTHON\" environment variable to represent specific version of Python. # .travis.yml language : python matrix : include : - os : linux sudo : required python : 3.6 dist : xenial - os : linux sudo : required python : 3.7 dist : xenial - os : osx osx_image : xcode10 language : generic env : PYTHON=36 Then, use \"addons\" option to install packages in Ubuntu platform with \"apt\" option. For example, install SWIG. addons : apt : packages : - swig MacPorts Since Homebrew always provide newest version of Python, it is recommended to use MacPorts as package management tool. With \"TRAVIS_OS_NAME\" variable, the bash command will only execute in OS X platform. Homebrew is already installed by Travis CI, so you can install dependency directly. Download MacPort from https://raw.githubusercontent.com/GiovanniBussi/macports-ci/master/macports-ci and install it. # For OSX before_install : - if [[ \"$TRAVIS_OS_NAME\" == \"osx\" ]]; then brew install swig; curl -LO https://raw.githubusercontent.com/GiovanniBussi/macports-ci/master/macports-ci; source ./macports-ci install; fi Python, pip and PyInstaller Install Python and pip by MacPorts. Type \"yes\" front of command can be pass the ask of MacPorts during installation. And using port select command to update python3 and pip soft link in /usr/local/bin . PyInstaller can be installed by pip, but should install with \"--user\" flag. That's because of MacPorts will install executable scripts to /opt/local , which is protected by system, it cannot be done with \"sudo\". The user folder /Users/travis/Library/Python/x.y/bin (where \"x.y\" is the Python version) is not in \"PATH\" variable, so add it using $(python3 -c \"import site; print(site.USER_BASE)\")/bin after installation completed. - if [[ \"$TRAVIS_OS_NAME\" == \"osx\" ]]; then yes | sudo port install python$PYTHON; yes | sudo port install py$PYTHON-pip; sudo port select --set python3 python$PYTHON; sudo port select --set pip pip$PYTHON; pip install pyinstaller --user; export PATH=$PATH:$(python3 -c \"import site; print(site.USER_BASE)\")/bin; fi Check the versions. - if [[ \"$TRAVIS_OS_NAME\" == \"osx\" ]]; then python3 --version; pip --version; pyinstaller --version; fi Install Python modules from requirements.txt . This step is also recommand using \"--user\" flag without \"sudo\". This step will automatically executed in Linux platform. - if [[ \"$TRAVIS_OS_NAME\" == \"osx\" ]]; then pip install -r requirements.txt --user; fi Summary The final version of configuration file looks like this: # Travis-Ci for Pyslvs-PyQt5 language : python matrix : include : - os : linux sudo : required python : 3.6 dist : xenial - os : linux sudo : required python : 3.7 dist : xenial - os : osx osx_image : xcode10 language : generic env : PYTHON=36 branches : only : - master - /&#94;dev\\d*[.]?\\d*$/ addons : apt : packages : - swig # For OS X before_install : - if [[ \"$TRAVIS_OS_NAME\" == \"osx\" ]]; then brew install swig; curl -LO https://raw.githubusercontent.com/GiovanniBussi/macports-ci/master/macports-ci; source ./macports-ci install; fi - if [[ \"$TRAVIS_OS_NAME\" == \"osx\" ]]; then yes | sudo port install python$PYTHON; yes | sudo port install py$PYTHON-pip; sudo port select --set python3 python$PYTHON; sudo port select --set pip pip$PYTHON; pip install pyinstaller --user; export PATH=$PATH:/Users/travis/Library/Python/$PYTHON/bin; fi - if [[ \"$TRAVIS_OS_NAME\" == \"osx\" ]]; then python3 --version; pip --version; pyinstaller --version; fi - if [[ \"$TRAVIS_OS_NAME\" == \"osx\" ]]; then pip install -r requirements.txt --user; fi script : - make before_cache : - rm -rf $HOME/.cache/pip/log cache : directories : - $HOME/.cache/pip","tags":"開發","url":"https://pyslvs.github.io/blog/yuan_2018-09-22.html"},{"title":"Pyslvs v18.09 - 09/13","text":"Mac OS platform supported. Mac OS platform Python-Solvespace kernel is already supported with macOS! Two types of executable files will be generated by PyInstaller. Unix-like executable file can execute in command line, but it will open external shell window when using \"open\" command. Common \"app\" format can execute with \"open\" command, but cannot pass arguments directly.","tags":"開發","url":"https://pyslvs.github.io/blog/yuan_2018-09-13.html"},{"title":"Pyslvs v18.06 - 06/30","text":"Three kernel of Pyslvs Three kernel of Pyslvs Pyslvs has been divided into three repositories now: Pylsvs-PyQt5 : Functional implement in graphical interface. pyslvs : Main libraries of Pyslvs, including 2D solver and mechanism synthesis methodology. Adesign : Independent framework of three algorithms.","tags":"開發","url":"https://pyslvs.github.io/blog/yuan_2018-06-30.html"},{"title":"Pyslvs v18.06 - 06/07","text":"Enhanced DXF format exporting function. Linkage length free move mode. DXF support Support versions: R12 R2000 R2004 R2007 R2010 R2013 R2018 (User interface are in the test version.) Demo video Now expression table widget finally has a selection mode. Choose a length parameter to change linkage dimension by slide bar or spin box.","tags":"開發","url":"https://pyslvs.github.io/blog/yuan_2018-06-07.html"},{"title":"Pyslvs v18.05 - 05/21","text":"Simple reading function of Solvespace format. Linkage select function. New planar solving kernel \"Pyslvs\". Demo video The reading function just support 2D sketch. In addition to get the R joints from \"constrain\" condition and get the grounded joints from \"point-plane distance\" condition with (0, 1, 0) work plane and (1, 0, 0) work plane. Another new function can allow user to select linkages by clicking mouse on main canvas, including to choose table items from linkage table widget just like the table of points. 讀取功能僅支援 2D 草圖。還有自 \"constrain\" 條件取得 R 接頭，由 \"point-plane distance\" 條件自 (0,1,0) 工作平面和 (1,0,0) 工作平面取得接地接頭。 另一個新功能可以讓用戶在主畫布上點擊游標來選擇連桿，包括像接點表格一樣從連桿表格元件中選取表格項目。 New solving kernel option In Pyslvs 18.05, a independent Cython module has pack together from old \"algorithm\" and \"topologic\" module. This module can be work without user interface and it just need two dependent module -- \"Cython\" to compile, \"lark-parser\" for parse expression. If there has highlight demand, optional dependent module \"Pygments\" can be provide to it. Now the \"Pyslvs\" kernel can use to be a planar solver of Pyslvs GUI program or external API. Pyslvs will using \"Pyslvs\" module as default planar solving kernel in new version, \"Python-Solvespace\" will still be a option in setting interface. 在Pyslvs 18.05中，一個獨立的Cython模塊從舊的 \"algorithm\" 和 \"topologic\" 模塊組裝在一起。 這個模塊可以在沒有用戶界面的情況下工作，它只需要兩個依賴模塊 - \"Cython\" 來編譯，解析表達式的 \"lark-parser\"。 如果有亮顯的需求，可以提供可選的相關模塊 \"Pygments\"。 現在 \"Pyslvs\" 內核可以用作Pyslvs GUI程序或外部API的平面解算器。 在新版本中，Pyslvs將使用 \"Pyslvs\" 模塊作為默認的平面解決內核，\"Python-Solvespace\" 仍然是設置界面的一個選項。","tags":"開發","url":"https://pyslvs.github.io/blog/yuan_2018-05-21.html"},{"title":"Triangular formulas in Pyslvs","text":"Triangular formula expression in Pyslvs Source code written in Python Pyslvs 中的三角形表示式 Python 版本的原始碼 Triangular formulas in Pyslvs In order to reach the simulation of mechanism motion path, Pyslvs takes three geometric solutions to meets the joint types in PMKS. PLA(P): Input as two (or one) known point(s), distance of reference point to the target point, and an angle value of them (or horizontal line), we can find the coordinate of target point. PLLP: Input as two known points, two distances of two reference points to the target point, we can find the coordinate of target point. PLPP: Input as a known point, distance of reference point to the target point, a straight line between two known points, we can find the coordinate of target point that is on the line. 為了達成機構路徑的模擬，以符合 PMKS 所能模擬的接頭種類，Pyslvs 採用三種幾何解法： PLA(P)：透過兩個（或一個）已知點、基準點至目標點距離，及其（與水平線）的夾角，可以求得目標點座標。 PLLP：透過兩個已知點、兩基準點至目標點距離，可以求得目標點座標。 PLPP：透過一個已知點、基準點至目標點距離、已知兩點連成的直線，可以求得目標點在直線上的座標。 PLAP PLLP PLPP Expression Pyslvs is using the expression to solving coordinates as below: Pyslvs 使用函式解題的表示法如下： Function[parameter0, parameter1, parameter2, ...](Target); ... After determined the target point by arguments, it can be use as a parameter to calculate next formula. For example, the coordinates of a four bar linkage mechanism can be find out with three formulas: 當透過輸入端求解之後，可以透過解出的目標點繼續求解。 例如，一個四連桿機構可以透過三個函式求解： #Known: a0, P0, P2, L0, L1, L2, L3, L4 PLAP[P0, L0, a0](P1); PLLP[P1, L1, L2, P2](P3); PLLP[P1, L3, L4, P3](P4) Source code There has input and output types of Cython function, and the calculation method as Python version. 這裡提供 Cython 的輸入輸出類型與 Python 版本的運算方法。 PLAP tuple PLAP(Coordinate A, double L0, double a0, Coordinate B=0, bool inverse=false); def PLAP(A, L0, a0, B=None, inverse=False): \"\"\"Point on circle by angle.\"\"\" a1 = atan2(B.y - A.y, B.x - A.x) if B else 0 if inverse: return (A.x + L0*cos(a1 - a0), A.y + L0*sin(a1 - a0)) else: return (A.x + L0*cos(a1 + a0), A.y + L0*sin(a1 + a0)) PLLP tuple PLLP ( Coordinate A , double L0 , double L1 , Coordinate B , bool inverse = false ); def PLLP ( A , L0 , L1 , B , inverse = False ): \"\"\"Two intersection points of two circles.\"\"\" dx = B . x - A . x dy = B . y - A . y d = A . distance ( B ) #No solutions, the circles are separate. if d > L0 + L1 : return ( nan , nan ) #No solutions because one circle is contained within the other. if d < abs ( L0 - L1 ): return ( nan , nan ) #Circles are coincident and there are an infinite number of solutions. if ( d == 0 ) and ( L0 == L1 ): return ( nan , nan ) a = ( L0 * L0 - L1 * L1 + d * d ) / ( 2 * d ) h = sqrt ( L0 * L0 - a * a ) xm = A . x + a * dx / d ym = A . y + a * dy / d if inverse : return ( xm + h * dy / d , ym - h * dx / d ) else : return ( xm - h * dy / d , ym + h * dx / d ) PLPP tuple PLPP ( Coordinate A , double L0 , Coordinate B , Coordinate C , bool inverse = false ); def PLAP ( A , L0 , B , C , inverse = False ): \"\"\"Two intersection points of a line and a circle.\"\"\" line_mag = B . distance ( C ) dx = C . x - B . x dy = C . y - B . y u = (( A . x - B . x ) * dx + ( A . y - B . y ) * dy ) / ( line_mag * line_mag ) I = Coordinate ( B . x + u * dx , B . y + u * dy ) #Test distance between point A and intersection. d = A . distance ( I ) if d > L0 : #No intersection. return ( nan , nan ) elif d == L0 : #One intersection point. return ( I . x , I . y ) #Two intersection points. d = sqrt ( L0 * L0 - d * d ) / line_mag dx *= d dy *= d if inverse : return ( I . x - dx , I . y - dy ) else : return ( I . x + dx , I . y + dy )","tags":"論述","url":"https://pyslvs.github.io/blog/pyslvs_triangle_expression.html"},{"title":"Pyslvs v18.04 - 04/09","text":"Application of auto configuration algorithm 自動配置演算法的應用 Application of auto configuration algorithm We can using auto configure function to preview the paths (limit ranges) of any mechanism. This function is achieved by expanded \"tinycadlib\", some new Cython functions to calculate the path data. But we still keep Solvespace as a third party verification tool. So the calculation of main canvas will still using Python-Solvespace kernel. 我們可以利用 自動配置功能 來預覽任何機構的運動路徑（極限範圍）。 這個功能是透過擴充後的「tinycadlib」實現的，多了一些 Cython 函式來計算路徑數據。 但是我們仍保留 Solvespace 作為第三方驗證工具。因此主畫布的計算仍會使用 Python-Solvespace 核心。","tags":"開發","url":"https://pyslvs.github.io/blog/yuan_2018-04-09.html"},{"title":"Flow charts of Pyslvs synthesis function","text":"Flow charts 流程圖 Flow charts of Pyslvs synthesis function Number and type synthesis Dimensional synthesis","tags":"開發","url":"https://pyslvs.github.io/blog/yuan_2018-03-26.html"},{"title":"Pyslvs v18.03 - 02/28","text":"Auto configuration algorithm 自動配置演算法 Auto configuration algorithm A function that can auto configure the solutions. 一個可以自動配置解決方案的功能。","tags":"開發","url":"https://pyslvs.github.io/blog/yuan_2018-02-28.html"},{"title":"Pyslvs v18.02 - 02/22","text":"Update information 更新資訊 Update information Update information about dimensional synthesis function. 尺寸合成功能的更新資訊。","tags":"開發","url":"https://pyslvs.github.io/blog/yuan_2018-02-22.html"},{"title":"Pyslvs v18.02 - 02/11","text":"Ball lifter mechanism synthesis test 提球機構合成測試 Ball lifter mechanism synthesis test The new synthesis options will support algorithms that end with fitness, and we will conduct small calculations for ball lifter mechanisms with two target paths. 新的合成設定中將支援隨適應值結束演算法，針對有兩個目標路徑的提球機構展開小型演算測試。 The construction of the ball lifter mechanism is so variable that it takes 6 minutes to 20 minutes to calculate the fitness below 100. 提球機構的變數較多，導致演算適應值至 100 以下的所需時間為 6 分鐘到 20 分鐘不等。 In addition, the staggered position of two target paths will also affect the result. 另外，兩段目標路徑的交錯位置也會影結果。","tags":"開發","url":"https://pyslvs.github.io/blog/yuan_2018-02-11.html"},{"title":"Pyslvs v18.01 - 01/25","text":"Triangular iteration 三角迭代展示影片 Triangular iteration demo video Video - English version: Video - Traditional Chinese version: Triangular iteration function will be update in version 18.1. But the profile can not apply in dimensional synthesis function currently. 三角迭代功能將會於 18.1 版更新。 但是目前的配置資訊不能應用於尺寸合成功能。","tags":"開發","url":"https://pyslvs.github.io/blog/yuan_2018-01-25.html"},{"title":"Pyslvs v18.01 - 01/07","text":"Topological library Atlas function 拓樸程式庫 圖譜功能 Topological library For better computing performance, the number synthesis library changed to Cython prepared. Which extracted some of the functions of NetworkX module, translated into Cython syntax. 為取得更好的運算效能，數目合成的程式庫改為 Cython 編寫。其中提取 NetworkX 模組的部份功能，轉譯為 Cython 語法。 Graph class edges public object ( tuple ) nodes public object ( tuple ) adj public object ( dict ) neighbors cpp function has_triangles cpp function is_connected cpp function degree cpp function number_of_edges cpp function __len__ cpp function GraphMatcher class G1 public Graph G2 public Graph G1_nodes object ( set ) G2_nodes object ( set ) mapping object ( set ) core_1 public object ( set ) core_2 public object ( set ) inout_1 public object ( set ) inout_2 public object ( set ) state GMState initialize c function candidate_pairs_iter python generator is_isomorphic cpp function isomorphisms_iter python generator match python generator semantic_feasibility c function syntactic_feasibility c function GMState class GM GraphMatcher G1_node object ( None or int ) G2_node object ( None or int ) depth int Atlas function Use the text file to store the atlas, the expression is the edge attribute in Graph class. You can also load text files into Pyslvs for processing. 使用文字文件儲存圖譜，表示式為 Graph 類型的 edges 屬性。 另外還可以將文字文件載入 Pyslvs 中處理。","tags":"開發","url":"https://pyslvs.github.io/blog/yuan_2018-01-07.html"},{"title":"Pyslvs 2018 Plan","text":"About release 關於發佈 About release Since 2018, Pyslvs will take the monthly release of the version update. The format of the version will be numbered as {year}.{month}.{patch} . The progress of the update will be updated in both English and Traditional Chinese in this blog. The \"開發\" category in this blog will refer to questions (concepts) that Pyslvs faces and how to use the existing knowledge collation to reach a solution to the problem. 自 2018 年開始，Pyslvs 將會採取每月釋出的方式進行版本更新。版本格式將以 {year}.{month}.{patch} 的方式編號。 更新進度將以英文與繁體中文的方式全部更新在本網誌。 本網誌的「開發」類別中將會提及 Pyslvs 面臨的問題（概念），並如何使用現有的知識歸類，達成問題的解決途徑。","tags":"開發","url":"https://pyslvs.github.io/blog/yuan_2018_plan.html"},{"title":"Pyslvs v0.9 - 12/12","text":"Graphviz 引擎限制（已解決） Beta 3 Release Graphviz 引擎限制（已解決） 最後使用 NetworkX 呼叫 Pydot 模組克服障礙。 Pydot 模組的原理是使用 command line 擷取回傳資訊，因此只要系統可以呼叫「dot」等指令即可。 即使不安裝 Graphviz，Pyslvs 只會跳出提醒視窗，可以選擇 Network 的引擎，或是馬上安裝，不用重開 Pyslvs 也可以重繪圖譜。 嘗試之餘也完成了轉換式，可以接頭表示；另外還有排除退化結果的功能。 Beta 3 Release 先釋出測試版，包含 beta 2 之後的進度。 舊的函式錯誤修復。 PMKS 表示式的 P 和 RP 接頭已經支援。 矩形選取模式。 類型合成圖譜。 更多範例。","tags":"開發","url":"https://pyslvs.github.io/blog/yuan_2017-12-12.html"},{"title":"Pyslvs v0.9 - 12/10","text":"QIcon 透明背景繪製 Graphviz 引擎限制 QIcon 透明背景繪製 使用 QImage 取代 QPixmap 可以繪製出具有透明背景的圖示或影像。 image = QImage ( QSize ( * rect ), QImage . Format_ARGB32_Premultiplied ) image . fill ( Qt . transparent ) painter = QPainter ( image ) painter . translate ( image . width () / 2 , image . height () / 2 ) painter . end () return QIcon ( QPixmap . fromImage ( image ) . scaledToWidth ( width )) 從 QIcon 轉為 QPixmap 可以用 pixmap(size: QSize) 或 pixmap(w: float, h: float) 方法。 listWidget . currentItem () . icon () . pixmap ( listWidget . iconSize ()) Graphviz 引擎限制 NetworkX 透過 PyGraphviz 引入 Graphviz 的繪圖演算法，提供更好的節點位置在圖譜中表現。 Graphviz 引擎如下： dot neato fdp twopi circo 其中 circo 和 neato 的效果較符合圖譜期望。 NetworkX 引擎如下： kamada kawai（有 SciPy 需求因此未加入） shell circular spring spectral random 其中較適合的為 shell，random 為隨機產生。 很遺憾的是，Windows x64 的 Python 無法安裝 PyGraphviz，因此 Pyslvs 目前只有 Ubuntu 版本提供 Graphviz 引擎。 而經測試，AppImage 技術由於只將 PyGraphviz 包入，端口程式庫仍然連接 Graphviz 程式庫，所以 Ubuntu 用戶必須安裝 Graphviz 。 sudo apt install graphviz 以下是瓦特與史帝芬生鍊用 neato 引擎排佈的結果。","tags":"開發","url":"https://pyslvs.github.io/blog/yuan_2017-12-10.html"},{"title":"Pyslvs v0.9 - 12/05","text":"拓樸排列程式 拓樸排列程式 花了一些時間寫了一個排列拓樸程式，將概念寫在這邊。 在論壇爬文時，看到作者自己推薦的 Python 樹狀結構模組 anytree，看了說明文件後決定使用此模組協助樹狀管理。 以一個四連桿 (4,) 的樹狀拓樸如下，只有一種排列方法： L0(2) ├── L1(2) │ └── L3(2) │ └── [L2](2) └── L2(2) └── [L3](2) ------- Answer count: 1 需要的模組有： from anytree import Node , RenderTree from anytree.search import findall from itertools import permutations from typing import Tuple 接著是印出上面樹狀結構的函式，anytree 的 RenderTree 搜尋函式會朝下列出節點的階級字元。 這邊用 noname 這個 bool 變數決定是否顯示名稱。 show_tree = lambda root : ' \\n ' . join ( \"{}{}({})\" . format ( pre , n . name , n . limit ) for pre , fill , n in RenderTree ( root )) 接下來是主函式，稱為 make_link ，接收內含 int 的可迭代物件。 def make_link ( iter : Tuple [ int ,]): ... return answer 第一部分是創出連桿的數量，數字則是接頭數。 link_type = [] for i , num in enumerate ( iter ): i += 2 for j in range ( num ): link_type . append ( i ) 如輸入 (4,) ，可以得到 [2, 2, 2, 2] ；輸入 (5, 4) 可得 [2, 2, 2, 2, 2, 3, 3, 3, 3] 。 使用 Python 迭代工具模組的 permutations 函式來創造排列組合的迴圈。 相符無誤的項目會將 root 節點加入答案，有錯誤則用 continue 關鍵字跳過。 answer = [] for all_link in list(set(permutations(link_type))): ... answer.append(links[0]) 首先轉換 link_type 的內容成為 anytree 模組的 Node 類型。 其中 limit 屬性是此節點的接頭上限，僅用於比對，並無程式上的限制。 all_link = [ Node ( \"L{}\" . format ( i ), limit = v ) for i , v in enumerate ( all_link )] 接著將第一項當作 root 節點，加入 links 。 這裡 links 清單的最後一項 links[-1] 是接下來的搜索法準備填入的項目。 links = [] links . append ( all_link . pop ( 0 )) 然後使用廣度優先搜索法 (Breadth-First-Search, BFS) 填入所有節點，使用 list 類型的 pop 方法配上 while 迴圈可以確保用光所有節點。 當指派一個節點的 parent 屬性時，anytree 模組會自動將節點連上父節點，父節點可以透過 children 屬性取得一個裝有所有子節點指標的 tuple 物件。 while all_link : link = all_link . pop ( 0 ) if ( len ( links [ - 1 ] . children ) + bool ( links [ - 1 ] . parent )) == links [ - 1 ] . limit : links . append ( links [ - 1 ] . children [ 0 ]) link . parent = links [ - 1 ] 由於數學定義的「樹 (tree)」結構中，子節點只能擁有一個父項，否則為迴路 (Loop)，anytree 模組會在連接成迴路時自動回擲 LoopError 錯誤。 但是我們的運動鍊為 close chain，因此必須再創立一個配對流程，這次使用類似連結的概念，同時為「主體」連結一個虛擬節點。 虛擬節點的樣式使用中括弧 [ ] 辨識，不用指派名稱。 創立 get_no_done 函式回傳使用 anytree 的 findall 模組過濾沒配對完成的節點。 get_no_done = lambda : findall ( links [ 0 ], filter_ = lambda n : '[' not in n . name and ( len ( n . children ) + bool ( links [ - 1 ] . parent )) < n . limit ) error = False while get_no_done (): nodes = get_no_done () try : l_1 , l_2 = nodes [ 0 ], nodes [ 1 ] except ( ValueError , IndexError ): error = True break else : Node ( \"[{}]\" . format ( l_1 . name ), limit = str ( l_1 . limit ), parent = l_2 ) Node ( \"[{}]\" . format ( l_2 . name ), limit = str ( l_2 . limit ), parent = l_1 ) 最後檢查是否在上述迴圈出現沒閉合狀況。 if error : continue 或是兩對連桿之間有連到一個以上的接頭。 if findall ( links [ 0 ], filter_ = lambda n : len ([ c . name for c in n . children ]) != len ( set ( c . name for c in n . children ))): continue 最後可以進行測試： if __name__ == '__main__' : print ( \"Topologic test\" ) answer = topo ([ 5 , 4 ]) #Show tree for root in answer : print ( show_tree ( root )) print ( '-' * 7 ) print ( \"Answer count: {}\" . format ( len ( answer ))) 可得： ... ------- L0(2) ├── L1(3) │ ├── L3(2) │ │ └── L5(3) │ │ ├── L6(3) │ │ │ ├── L8(3) │ │ │ │ ├── [L6](3) │ │ │ │ └── [L7](2) │ │ │ └── [L8](3) │ │ └── L7(2) │ │ └── [L8](3) │ └── L4(2) │ └── [L2](2) └── L2(2) └── [L4](2) ------- Answer count: 60 經驗證，所有接頭都有連接。","tags":"開發","url":"https://pyslvs.github.io/blog/yuan_2017-12-05.html"},{"title":"Pyslvs v0.9 - 12/03","text":"PMKS 轉換式更新 機構範例 PMKS 轉換式更新 完成滑動接頭 P 與 RP 的轉換式，已經可以支援這兩種接頭的輸入。 另外改進了三點共線和共點在 Solvespace 輸入的錯誤。 機構範例 增加了兩個範例，用作測試上述程式。 曲柄滑塊 雙臂接球機構","tags":"開發","url":"https://pyslvs.github.io/blog/yuan_2017-12-03.html"},{"title":"設計、設計方法與機械設計","text":"從設計觀念的釐清, 到設計方法的探尋, 以及利用各種設計方法來進行機械設計, 到底有沒有一套脈絡或論述可以依循? 設計到底是甚麼? 在工程領域, 設計應該是一種表達, 而且是能夠讓參與設計的所有團隊成員都充分了解, 且據以依循, 可以得到預期結果的具體表達. 工程設計常用的表達至少有口語、文字、2D、3D、數學與實體等六種方式. 例如: 利用 Leo Editor 管理 Pelican 靜態網誌系統的協同使用\"設計\", 文字表達敘述如下: 這是一套允許多人協同編寫位於 content 目錄下的 Markdown 檔案格式或 reStructuredText 格式文章原稿的系統 為了完整保留本網誌系統原稿與設定檔案的歷程資料, 採用 Github 或 Fossil SCM 進行內容組態管理 為了在組態管理歷程資料過程, 避免各學員的 Leo Editor 專案 XML 檔案, 因合併產生衝突處理上的困難, 規定各成員必須自行維護管理 users 目錄下, 以作者名稱命名的 .leo 檔案 為了讓 Pelican 所產生的 html 網誌系統, 可以同時在無網路連線的近端與雲端上使用, 近端利用 pelicanconf.py 加上 local_publishconf.py 轉檔, 遠端則使用 pelicanconf.py 加上 publishconf.py 轉檔 Pelican 轉換完成的 html 檔案, 設定置於 blog 目錄中 由於 Pelican 轉換後的 html 位於 blog 子目錄, 因此整個系統根目錄中的 index.html 以 head 標註中的 meta redirect 跳轉至 blog 目錄中的 index.html 為了讓多人所建立的文章原稿, 同時存入 content 目錄而不會產生覆蓋, 規定以作者名稱加上底線, 再加上當天日期及副檔名命名 作者若同一天建立多篇文章原稿, 則以用戶名稱_日期-1.md 等 dash 後加上數字區別 因為 Pelican 針對沒有 slug 欄位設定的中文標題文章原稿, 會以拉丁拼音命名轉換後的 html 檔案, 比較不容易望文生義, 因此建議各文章以有意義的英文名稱命名, 且最前方加上作者名稱, 以避免因重複 slug 設定, 而讓 Pelican 無法轉檔 為了讓各用戶的 Leo Editor 文章節點中, 以 @edit 或 @clean 節點指令下的文章更容易查找, 建議在存檔節點的根節點, 以文章標題註記 有關 attila 樣板右方 menu 側欄中的連結增刪, 可以透過編輯 partials 目錄中的 navigation.html 達成 頁面正中方的搜尋表達, 以修改近端與雲端 templates 目錄中的 base.html 檔案中的 search section, 套入 search.html 達成 系統啟用 summary plugin 的目的, 在於讓 reStructuredText 格式文章原稿可以透過標註, 區隔摘要與內文 系統啟用 neighbors plugin 的目的, 在於讓各篇文章末端出現前後文章的連結, 以方便循序瀏覽閱讀 系統啟用 tipuesearch plugin 的目的, 在於讓使用者可以透過兩個字元以上的關鍵字進行全文搜尋 為了讓 Pelican 轉換完成的 html 檔案, 可以採 tipuesearch Javascript 延伸功能, 以關鍵字搜尋, 近端關鍵字以 tipuesearch_content.js 儲存, 遠端則使用 tipuesearch_content.json 儲存, 詳細內容可參見 plugin 目錄中, tipue_search 子目錄中的 tipue_search.py 設定 上述之所以在轉檔階段需要區分近端與雲端的原因, 在於近端無 disqus 設定, 而遠端則附加 disqus 回應系統 為了讓近端與遠端瀏覽器中各 AJAX 前後端程式系統的反應一致, 近端利用 www-server 按鈕, 以執行緒啟動 https 伺服器, 使用者可以在轉檔完成後, 以瀏覽器 IPv4 網路協定檢查內容 為了讓系統在 IPv6 網路協定下正常運作, 以 ipv6-https-server 按鈕, 以執行緒啟動 https 伺服器, 使用者可以在轉檔完成後 ,以瀏覽器 IPv6 網路協定檢查內容 當然, 本網誌系統的完整原始資料都保存在 Pyslvs 倉儲 , 任何人只要 git clone 倉儲, 稍加修改, 就可以另起爐灶, 延續這個網誌系統的價值, 但是其中許多細微精密的設計, 若沒有完整表達, 一旦爾後使用環境改變或各相關系統改版, 使用者就無法充分掌握各開放系統的互動搭配, 獨力配置因應. 換言之, 工程領域中與所謂設計相關的具體表達, 至少是時間與所處環境的函數, 一旦時空轉變, 就必須透過完整的歷程組態管理紀錄, 啟動各互動元件間的配置修改, 方能延續或加值原始設計的表達, 得到預期結果. 設計方法 假如我們接受在工程領域中, 上述所謂設計是一種表達的陳述, 那麼在表達設計的歷程中, 將存在許多解決問題的方法, 與所處時空背景的說明. 首先, 甚麼是方法? \"方\"為合乎約制條件, 可以實際拿出來使用的策略與規則, 表示並非空想, 而可實際施行的內容, 才叫\"方\". 至於\"法\"是順應自然條件下, 可因時空而制宜的最高行事準則. 因此\"方法\"就是: 配合不同條件, 實際施行的最高準則. 而再從上述設計有六種表達方式的論述出發, 那麼以口語表達而言的設計方法, 就是: 配合不同條件, 實際施行口語表達的最高準則. 也就是因應環境與對象, 將設計內容, 說清楚講明白所採行的策略與準則. 因此, 所謂設計方法, 除了口語表達外, 還可以從文字、2D、3D、數學與實體等表達的形式, 加以發揮, 具體呈現設計內容. 由於設計方法以各種形式表達的過程中, 會因時空背景與參與人員所做決策的差異, 而產生不同的結果, 多人協同團隊為了更有效掌握過程中的各項細節, 因此設計方法及組成元件有關的組態管理系統 (Configuration Management) 因應而生. 機械設計 機械是一種器物, 而且是由固體、流體與軟體元件精巧組合而成, 可互動運作, 達成特定功能之器物. 因此機械設計就是靈活運用六種表達方式, 明確說明如何透過固體、流體與軟體元件之互動運作, 而能達成預定結果之明確與具體表達. Pyslvs 是機械設計過程中的一項工具, 主要由平面機構模擬核心、演化運算核心與視窗圖形化介面程式所組成. 其中, 兩種運算核心都依據平面機構有關的數學模型與分析表達, 採用軟體元件製作, 再結合 2D 使用者圖形介面建立物件導向, 以及事件驅動程式元件等功能, 讓使用者可以輸入平面機構模型後, 進行模擬或合成運算. 而 Pyslvs 平面機構模擬核心的主體為一套 Geometric Constrain Solver, 依附在 Solvespace 參數化 3D 繪圖套件中. 在 2013 年 9 月透過 SWIG (Simplified Wrapper and Interface Generator) 技術, 轉為 Python2 可呼叫的程式庫, 為 Python2-Solvespace . 2016 年 7 月之後, 經本站轉為 Python3 可呼叫的程式庫, 成為 Python3-Solvespace . 至於 Pyslvs 平面機構合成所使用的演化運算核心 ,則源自 2015 年 4 月利用 Cython (C-extension for Python) 技術所開發的 Algorithm , 包含實數編碼基因 (Real-coded Genetic) 演算法、差分進化 (Differential Evolution) 演算法與螢火蟲 (Firefly) 演算法等模組. Pyslvs 的圖形介面採用 PyQt5 , 在 Eric6 整合開發環境中建立.","tags":"論述","url":"https://pyslvs.github.io/blog/scrum_design-design_methods-and-mechanical-design.html"},{"title":"Pyslvs v0.9 - 11/28","text":"介面操作重大更新 介面操作重大更新 今天改寫了一下畫布介面。 將拍照到剪貼簿的按鈕移到右上角的版本標籤旁；表格頁籤旁改成「全部選擇」按鈕。 新增兩個功能的快捷鍵： 全選點 (Select all point)：Ctrl + A 自由移動模式切換 (Free move mode toggle)：Ctrl + F 另外有一個重大突破：矩形窗選功能。 在非自由移動模式下可靠滑鼠拖拉矩形線框，選取畫布上的點。 自由移動模式下拖拉將會移動並修改選擇的點座標。","tags":"開發","url":"https://pyslvs.github.io/blog/yuan_2017-11-28.html"},{"title":"Pyslvs.com 上線","text":"2017.11.26 之前的 pyslvs 網站內容備份在 https://kmolyuan.github.io/pyslvs/ , 目前的 http://pyslvs.com 使用 http://pyslvs.github.io 作為網站內容, disqus 則登記為 pyslvs-com. 這項改變的目的是以 Pelican 靜態網頁取代原先的一頁式網頁, 除了比較容易維護之外, 也可以提供更充實的內容. 這項以 Github Pages 架構作為雲端 WWW 伺服器, 而 DNS 的設定首先是將 http://www.pyslvs.com 以 CNAME 指向 http://pyslvs.github.io , 然後在內定轉址的根網址 http://pyslvs.com , 以 301 類型轉至 http://www.pyslvs.com . 至於 Github Pages 的部分則是針對 https://github.com/pyslvs/pyslvs.github.io 倉儲, 將 Settings 中的 Custom Domain 設為 http://www.pyslvs.com 就算完成. Pyslvs 的原意為 Python for Solvespace , 是讓使用者容易使用 Solvespace 所開源出來的 Geometric Constraint Solver, 也就是 Python Solvespace , 隨後利用 PyQt5 使用者介面並加上演化合成引擎, 成為目前的 PSLVS (Python Synthesis of Linkages and Verification Software), 中文為 Python 機構合成與驗證套件, 其開發目標希望成為一套能夠用於機械產品平面機構合成與機構可用性驗證的模擬分析與最佳化設計套件. 其他開放源機構分析軟體: http://blog.rectorsquid.com/linkage-mechanism-designer-and-simulator/ (Github: https://github.com/rectorsquid/Linkage ) https://designengrlab.github.io/PMKS/ (Github: https://github.com/DesignEngrLab/PMKS )","tags":"論壇","url":"https://pyslvs.github.io/blog/pyslvs-on-line.html"}]}