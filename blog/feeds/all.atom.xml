<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>Pyslvs.com</title><link href="https://pyslvs.github.io/blog/" rel="alternate"></link><link href="https://pyslvs.github.io/blog/feeds/all.atom.xml" rel="self"></link><id>https://pyslvs.github.io/blog/</id><updated>2018-02-28T21:00:00+08:00</updated><entry><title>Pyslvs v18.3.0 - 02/28</title><link href="https://pyslvs.github.io/blog/yuan_2018-02-28.html" rel="alternate"></link><published>2018-02-28T21:00:00+08:00</published><updated>2018-02-28T21:00:00+08:00</updated><author><name>Yuan Chang</name></author><id>tag:pyslvs.github.io,2018-02-28:/blog/yuan_2018-02-28.html</id><summary type="html">&lt;ul&gt;
&lt;li&gt;Auto configuration algorithm 自動配置演算法&lt;/li&gt;
&lt;/ul&gt;
</summary><content type="html">&lt;ul&gt;
&lt;li&gt;Auto configuration algorithm 自動配置演算法&lt;/li&gt;
&lt;/ul&gt;


&lt;h1&gt;Auto configuration algorithm 自動配置演算法&lt;/h1&gt;
&lt;p&gt;A function that can auto configure the solutions.&lt;/p&gt;
&lt;p&gt;一個可以自動配置解決方案的功能。&lt;/p&gt;
&lt;iframe width="560" height="345" src="https://www.youtube.com/embed/2WNBDhVDWYM" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen&gt;&lt;/iframe&gt;</content><category term="development"></category></entry><entry><title>Pyslvs v18.2.0 - 02/22</title><link href="https://pyslvs.github.io/blog/yuan_2018-02-22.html" rel="alternate"></link><published>2018-02-22T21:00:00+08:00</published><updated>2018-02-22T21:00:00+08:00</updated><author><name>Yuan Chang</name></author><id>tag:pyslvs.github.io,2018-02-22:/blog/yuan_2018-02-22.html</id><summary type="html">&lt;ul&gt;
&lt;li&gt;Update information 更新資訊&lt;/li&gt;
&lt;/ul&gt;
</summary><content type="html">&lt;ul&gt;
&lt;li&gt;Update information 更新資訊&lt;/li&gt;
&lt;/ul&gt;


&lt;h1&gt;Update information 更新資訊&lt;/h1&gt;
&lt;p&gt;Update information about dimensional synthesis function.&lt;/p&gt;
&lt;p&gt;尺寸合成功能的更新資訊。&lt;/p&gt;
&lt;iframe width="560" height="315" src="https://www.youtube.com/embed/ysris9uON4U" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen&gt;&lt;/iframe&gt;</content><category term="development"></category></entry><entry><title>Pyslvs v18.2.0 - 02/11</title><link href="https://pyslvs.github.io/blog/yuan_2018-02-11.html" rel="alternate"></link><published>2018-02-11T21:00:00+08:00</published><updated>2018-02-11T21:00:00+08:00</updated><author><name>Yuan Chang</name></author><id>tag:pyslvs.github.io,2018-02-11:/blog/yuan_2018-02-11.html</id><summary type="html">&lt;ul&gt;
&lt;li&gt;Ball lifter mechanism synthesis test 提球機構合成測試&lt;/li&gt;
&lt;/ul&gt;
</summary><content type="html">&lt;ul&gt;
&lt;li&gt;Ball lifter mechanism synthesis test 提球機構合成測試&lt;/li&gt;
&lt;/ul&gt;


&lt;h1&gt;Ball lifter mechanism synthesis test 提球機構合成測試&lt;/h1&gt;
&lt;p&gt;The new synthesis options will support algorithms that end with fitness, and we will conduct small calculations for ball lifter mechanisms with two target paths.&lt;/p&gt;
&lt;p&gt;新的合成設定中將支援隨適應值結束演算法，針對有兩個目標路徑的提球機構展開小型演算測試。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="../data/images/18_02_11_01.png"&gt;&lt;/p&gt;
&lt;p&gt;The construction of the ball lifter mechanism is so variable that it takes 6 minutes to 20 minutes to calculate the fitness below 100.&lt;/p&gt;
&lt;p&gt;提球機構的變數較多，導致演算適應值至 100 以下的所需時間為 6 分鐘到 20 分鐘不等。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="../data/images/18_02_11_02.png"&gt;&lt;/p&gt;
&lt;p&gt;In addition, the staggered position of two target paths will also affect the result.&lt;/p&gt;
&lt;p&gt;另外，兩段目標路徑的交錯位置也會影結果。&lt;/p&gt;</content><category term="development"></category></entry><entry><title>Pyslvs v18.1.0 - 01/25</title><link href="https://pyslvs.github.io/blog/yuan_2018-01-25.html" rel="alternate"></link><published>2018-01-25T21:00:00+08:00</published><updated>2018-01-25T21:00:00+08:00</updated><author><name>Yuan Chang</name></author><id>tag:pyslvs.github.io,2018-01-25:/blog/yuan_2018-01-25.html</id><summary type="html">&lt;ul&gt;
&lt;li&gt;Triangular iteration 三角迭代展示影片&lt;/li&gt;
&lt;/ul&gt;
</summary><content type="html">&lt;ul&gt;
&lt;li&gt;Triangular iteration 三角迭代展示影片&lt;/li&gt;
&lt;/ul&gt;


&lt;h1&gt;Triangular iteration demo video 三角迭代展示影片&lt;/h1&gt;
&lt;p&gt;Video - English version:&lt;/p&gt;
&lt;iframe width="560" height="315" src="https://www.youtube.com/embed/-zmGU0RoFNo" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen&gt;&lt;/iframe&gt;

&lt;p&gt;Video - Traditional Chinese version:&lt;/p&gt;
&lt;iframe width="560" height="315" src="https://www.youtube.com/embed/h9eqmw9gRDg" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen&gt;&lt;/iframe&gt;

&lt;p&gt;Triangular iteration function will be update in version 18.1.&lt;/p&gt;
&lt;p&gt;But the profile can not apply in dimensional synthesis function currently.&lt;/p&gt;
&lt;p&gt;三角迭代功能將會於 18.1 版更新。&lt;/p&gt;
&lt;p&gt;但是目前的配置資訊不能應用於尺寸合成功能。&lt;/p&gt;</content><category term="development"></category></entry><entry><title>Pyslvs v18.1.0 - 01/07</title><link href="https://pyslvs.github.io/blog/yuan_2018-01-07.html" rel="alternate"></link><published>2018-01-07T21:00:00+08:00</published><updated>2018-01-07T21:00:00+08:00</updated><author><name>Yuan Chang</name></author><id>tag:pyslvs.github.io,2018-01-07:/blog/yuan_2018-01-07.html</id><summary type="html">&lt;ul&gt;
&lt;li&gt;Topological library 拓樸程式庫&lt;/li&gt;
&lt;li&gt;Atlas function 圖譜功能&lt;/li&gt;
&lt;/ul&gt;
</summary><content type="html">&lt;ul&gt;
&lt;li&gt;Topological library 拓樸程式庫&lt;/li&gt;
&lt;li&gt;Atlas function 圖譜功能&lt;/li&gt;
&lt;/ul&gt;


&lt;h1&gt;Topological library 拓樸程式庫&lt;/h1&gt;
&lt;p&gt;For better computing performance, the number synthesis library changed to Cython prepared. Which extracted some of the functions of NetworkX module, translated into Cython syntax.&lt;/p&gt;
&lt;p&gt;為取得更好的運算效能，數目合成的程式庫改為 Cython 編寫。其中提取 NetworkX 模組的部份功能，轉譯為 Cython 語法。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;Graph&lt;/code&gt; class&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;edges&lt;/code&gt; public &lt;code&gt;object&lt;/code&gt; (&lt;code&gt;tuple&lt;/code&gt;)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;nodes&lt;/code&gt; public &lt;code&gt;object&lt;/code&gt; (&lt;code&gt;tuple&lt;/code&gt;)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;adj&lt;/code&gt; public &lt;code&gt;object&lt;/code&gt; (&lt;code&gt;dict&lt;/code&gt;)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;neighbors&lt;/code&gt; cpp function&lt;/li&gt;
&lt;li&gt;&lt;code&gt;has_triangles&lt;/code&gt; cpp function&lt;/li&gt;
&lt;li&gt;&lt;code&gt;is_connected&lt;/code&gt; cpp function&lt;/li&gt;
&lt;li&gt;&lt;code&gt;degree&lt;/code&gt; cpp function&lt;/li&gt;
&lt;li&gt;&lt;code&gt;number_of_edges&lt;/code&gt; cpp function&lt;/li&gt;
&lt;li&gt;&lt;code&gt;__len__&lt;/code&gt; cpp function&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;GraphMatcher&lt;/code&gt; class&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;G1&lt;/code&gt; public &lt;code&gt;Graph&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;G2&lt;/code&gt; public &lt;code&gt;Graph&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;G1_nodes&lt;/code&gt; &lt;code&gt;object&lt;/code&gt; (&lt;code&gt;set&lt;/code&gt;)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;G2_nodes&lt;/code&gt; &lt;code&gt;object&lt;/code&gt; (&lt;code&gt;set&lt;/code&gt;)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;mapping&lt;/code&gt; &lt;code&gt;object&lt;/code&gt; (&lt;code&gt;set&lt;/code&gt;)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;core_1&lt;/code&gt; public &lt;code&gt;object&lt;/code&gt; (&lt;code&gt;set&lt;/code&gt;)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;core_2&lt;/code&gt; public &lt;code&gt;object&lt;/code&gt; (&lt;code&gt;set&lt;/code&gt;)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;inout_1&lt;/code&gt; public &lt;code&gt;object&lt;/code&gt; (&lt;code&gt;set&lt;/code&gt;)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;inout_2&lt;/code&gt; public &lt;code&gt;object&lt;/code&gt; (&lt;code&gt;set&lt;/code&gt;)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;state&lt;/code&gt; &lt;code&gt;GMState&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;initialize&lt;/code&gt; c function&lt;/li&gt;
&lt;li&gt;&lt;code&gt;candidate_pairs_iter&lt;/code&gt; python generator&lt;/li&gt;
&lt;li&gt;&lt;code&gt;is_isomorphic&lt;/code&gt; cpp function&lt;/li&gt;
&lt;li&gt;&lt;code&gt;isomorphisms_iter&lt;/code&gt; python generator&lt;/li&gt;
&lt;li&gt;&lt;code&gt;match&lt;/code&gt; python generator&lt;/li&gt;
&lt;li&gt;&lt;code&gt;semantic_feasibility&lt;/code&gt; c function&lt;/li&gt;
&lt;li&gt;&lt;code&gt;syntactic_feasibility&lt;/code&gt; c function&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;GMState&lt;/code&gt; class&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;GM&lt;/code&gt; &lt;code&gt;GraphMatcher&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;G1_node&lt;/code&gt; &lt;code&gt;object&lt;/code&gt; (&lt;code&gt;None&lt;/code&gt; or &lt;code&gt;int&lt;/code&gt;)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;G2_node&lt;/code&gt; &lt;code&gt;object&lt;/code&gt; (&lt;code&gt;None&lt;/code&gt; or &lt;code&gt;int&lt;/code&gt;)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;depth&lt;/code&gt; &lt;code&gt;int&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;Atlas function 圖譜功能&lt;/h1&gt;
&lt;p&gt;Use the text file to store the atlas, the expression is the &lt;code&gt;edge&lt;/code&gt; attribute in &lt;code&gt;Graph&lt;/code&gt; class.&lt;/p&gt;
&lt;p&gt;You can also load text files into Pyslvs for processing.&lt;/p&gt;
&lt;p&gt;使用文字文件儲存圖譜，表示式為 &lt;code&gt;Graph&lt;/code&gt; 類型的 &lt;code&gt;edges&lt;/code&gt; 屬性。&lt;/p&gt;
&lt;p&gt;另外還可以將文字文件載入 Pyslvs 中處理。&lt;/p&gt;
&lt;iframe width="560" height="315" src="https://www.youtube.com/embed/RzD6_WKJjVM" frameborder="0" gesture="media" allow="encrypted-media" allowfullscreen&gt;&lt;/iframe&gt;</content><category term="development"></category></entry><entry><title>Pyslvs 2018 Plan</title><link href="https://pyslvs.github.io/blog/yuan_2018_plan.html" rel="alternate"></link><published>2018-01-07T12:00:00+08:00</published><updated>2018-01-07T12:00:00+08:00</updated><author><name>Yuan Chang</name></author><id>tag:pyslvs.github.io,2018-01-07:/blog/yuan_2018_plan.html</id><summary type="html">&lt;ul&gt;
&lt;li&gt;About release 關於發佈&lt;/li&gt;
&lt;/ul&gt;
</summary><content type="html">&lt;ul&gt;
&lt;li&gt;About release 關於發佈&lt;/li&gt;
&lt;/ul&gt;


&lt;h1&gt;About release 關於發佈&lt;/h1&gt;
&lt;p&gt;Since 2018, Pyslvs will take the monthly release of the version update. The format of the version will be numbered as &lt;code&gt;{year}.{month}.{patch}&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;The progress of the update will be updated in both English and Traditional Chinese in this blog.&lt;/p&gt;
&lt;p&gt;The "開發" category in this blog will refer to questions (concepts) that Pyslvs faces and how to use the existing knowledge collation to reach a solution to the problem.&lt;/p&gt;
&lt;p&gt;自 2018 年開始，Pyslvs 將會採取每月釋出的方式進行版本更新。版本格式將以 &lt;code&gt;{year}.{month}.{patch}&lt;/code&gt; 的方式編號。&lt;/p&gt;
&lt;p&gt;更新進度將以英文與繁體中文的方式全部更新在本網誌。&lt;/p&gt;
&lt;p&gt;本網誌的「開發」類別中將會提及 Pyslvs 面臨的問題（概念），並如何使用現有的知識歸類，達成問題的解決途徑。&lt;/p&gt;</content><category term="development"></category></entry><entry><title>Pyslvs v0.9 - 12/12</title><link href="https://pyslvs.github.io/blog/yuan_2017-12-12.html" rel="alternate"></link><published>2017-12-12T21:00:00+08:00</published><updated>2017-12-12T21:00:00+08:00</updated><author><name>Yuan Chang</name></author><id>tag:pyslvs.github.io,2017-12-12:/blog/yuan_2017-12-12.html</id><summary type="html">&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Graphviz 引擎限制（已解決）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Beta 3 Release&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
</summary><content type="html">&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Graphviz 引擎限制（已解決）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Beta 3 Release&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;


&lt;h1&gt;Graphviz 引擎限制（已解決）&lt;/h1&gt;
&lt;p&gt;最後使用 NetworkX 呼叫 Pydot 模組克服障礙。&lt;/p&gt;
&lt;p&gt;Pydot 模組的原理是使用 command line 擷取回傳資訊，因此只要系統可以呼叫「dot」等指令即可。&lt;/p&gt;
&lt;p&gt;即使不安裝 Graphviz，Pyslvs 只會跳出提醒視窗，可以選擇 Network 的引擎，或是馬上安裝，不用重開 Pyslvs 也可以重繪圖譜。&lt;/p&gt;
&lt;p&gt;嘗試之餘也完成了轉換式，可以接頭表示；另外還有排除退化結果的功能。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/pyslvs/17_12_12.png"&gt;&lt;/p&gt;
&lt;h1&gt;Beta 3 Release&lt;/h1&gt;
&lt;p&gt;先釋出測試版，包含 beta 2 之後的進度。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;舊的函式錯誤修復。&lt;/li&gt;
&lt;li&gt;PMKS 表示式的 P 和 RP 接頭已經支援。&lt;/li&gt;
&lt;li&gt;矩形選取模式。&lt;/li&gt;
&lt;li&gt;類型合成圖譜。&lt;/li&gt;
&lt;li&gt;更多範例。&lt;/li&gt;
&lt;/ul&gt;</content><category term="development"></category></entry><entry><title>Pyslvs v0.9 - 12/10</title><link href="https://pyslvs.github.io/blog/yuan_2017-12-10.html" rel="alternate"></link><published>2017-12-10T21:00:00+08:00</published><updated>2017-12-10T21:00:00+08:00</updated><author><name>Yuan Chang</name></author><id>tag:pyslvs.github.io,2017-12-10:/blog/yuan_2017-12-10.html</id><summary type="html">&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;QIcon 透明背景繪製&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Graphviz 引擎限制&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
</summary><content type="html">&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;QIcon 透明背景繪製&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Graphviz 引擎限制&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;


&lt;h1&gt;QIcon 透明背景繪製&lt;/h1&gt;
&lt;p&gt;使用 QImage 取代 QPixmap 可以繪製出具有透明背景的圖示或影像。&lt;/p&gt;
&lt;pre class="brush: python"&gt;
image = QImage(QSize(*rect), QImage.Format_ARGB32_Premultiplied)
image.fill(Qt.transparent)
painter = QPainter(image)
painter.translate(image.width()/2, image.height()/2)
painter.end()
return QIcon(QPixmap.fromImage(image).scaledToWidth(width))
&lt;/pre&gt;

&lt;p&gt;從 QIcon 轉為 QPixmap 可以用 &lt;code&gt;pixmap(size: QSize)&lt;/code&gt; 或 &lt;code&gt;pixmap(w: float, h: float)&lt;/code&gt; 方法。&lt;/p&gt;
&lt;pre class="brush: python"&gt;
listWidget.currentItem().icon().pixmap(listWidget.iconSize())
&lt;/pre&gt;

&lt;h1&gt;Graphviz 引擎限制&lt;/h1&gt;
&lt;p&gt;NetworkX 透過 PyGraphviz 引入 Graphviz 的繪圖演算法，提供更好的節點位置在圖譜中表現。&lt;/p&gt;
&lt;p&gt;Graphviz 引擎如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;dot&lt;/li&gt;
&lt;li&gt;neato&lt;/li&gt;
&lt;li&gt;fdp&lt;/li&gt;
&lt;li&gt;twopi&lt;/li&gt;
&lt;li&gt;circo&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;其中 circo 和 neato 的效果較符合圖譜期望。&lt;/p&gt;
&lt;p&gt;NetworkX 引擎如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;kamada kawai（有 SciPy 需求因此未加入）&lt;/li&gt;
&lt;li&gt;shell&lt;/li&gt;
&lt;li&gt;circular&lt;/li&gt;
&lt;li&gt;spring&lt;/li&gt;
&lt;li&gt;spectral&lt;/li&gt;
&lt;li&gt;random&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;其中較適合的為 shell，random 為隨機產生。&lt;/p&gt;
&lt;p&gt;很遺憾的是，Windows x64 的 Python 無法安裝 PyGraphviz，因此 Pyslvs 目前只有 Ubuntu 版本提供 Graphviz 引擎。&lt;/p&gt;
&lt;p&gt;而經測試，AppImage 技術由於只將 PyGraphviz 包入，端口程式庫仍然連接 Graphviz 程式庫，所以 &lt;strong&gt;Ubuntu 用戶必須安裝 Graphviz&lt;/strong&gt;。&lt;/p&gt;
&lt;pre class="brush: bash"&gt;
sudo apt install graphviz
&lt;/pre&gt;

&lt;p&gt;以下是瓦特與史帝芬生鍊用 neato 引擎排佈的結果。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/pyslvs/17_12_10.png"&gt;&lt;/p&gt;</content><category term="development"></category></entry><entry><title>Pyslvs v0.9 - 12/05</title><link href="https://pyslvs.github.io/blog/yuan_2017-12-05.html" rel="alternate"></link><published>2017-12-05T21:00:00+08:00</published><updated>2017-12-05T21:00:00+08:00</updated><author><name>Yuan Chang</name></author><id>tag:pyslvs.github.io,2017-12-05:/blog/yuan_2017-12-05.html</id><summary type="html">&lt;ul&gt;
&lt;li&gt;拓樸排列程式&lt;/li&gt;
&lt;/ul&gt;
</summary><content type="html">&lt;ul&gt;
&lt;li&gt;拓樸排列程式&lt;/li&gt;
&lt;/ul&gt;


&lt;h1&gt;拓樸排列程式&lt;/h1&gt;
&lt;p&gt;花了一些時間寫了一個排列拓樸程式，將概念寫在這邊。&lt;/p&gt;
&lt;p&gt;在論壇爬文時，看到作者自己推薦的 Python 樹狀結構模組 anytree，看了說明文件後決定使用此模組協助樹狀管理。&lt;/p&gt;
&lt;p&gt;以一個四連桿 (4,) 的樹狀拓樸如下，只有一種排列方法：&lt;/p&gt;
&lt;pre&gt;
L0(2)
├── L1(2)
│   └── L3(2)
│       └── [L2](2)
└── L2(2)
    └── [L3](2)
-------
Answer count: 1
&lt;/pre&gt;

&lt;p&gt;需要的模組有：&lt;/p&gt;
&lt;pre class="brush: python"&gt;
from anytree import Node, RenderTree
from anytree.search import findall
from itertools import permutations
from typing import Tuple
&lt;/pre&gt;

&lt;p&gt;接著是印出上面樹狀結構的函式，anytree 的 RenderTree 搜尋函式會朝下列出節點的階級字元。&lt;/p&gt;
&lt;p&gt;這邊用 &lt;code&gt;noname&lt;/code&gt; 這個 bool 變數決定是否顯示名稱。&lt;/p&gt;
&lt;pre class="brush: python"&gt;
show_tree = lambda root: '\n'.join("{}{}({})".format(pre, n.name, n.limit) for pre, fill, n in RenderTree(root))
&lt;/pre&gt;

&lt;p&gt;接下來是主函式，稱為 &lt;code&gt;make_link&lt;/code&gt;，接收內含 int 的可迭代物件。&lt;/p&gt;
&lt;pre class="brush: python"&gt;
def make_link(iter: Tuple[int,]):
    ...
    return answer
&lt;/pre&gt;

&lt;p&gt;第一部分是創出連桿的數量，數字則是接頭數。&lt;/p&gt;
&lt;pre class="brush: python"&gt;
link_type = []
  for i, num in enumerate(iter):
    i += 2
    for j in range(num):
        link_type.append(i)
&lt;/pre&gt;

&lt;p&gt;如輸入 &lt;code&gt;(4,)&lt;/code&gt;，可以得到 &lt;code&gt;[2, 2, 2, 2]&lt;/code&gt;；輸入 &lt;code&gt;(5, 4)&lt;/code&gt; 可得 &lt;code&gt;[2, 2, 2, 2, 2, 3, 3, 3, 3]&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;使用 Python 迭代工具模組的 &lt;a href="https://docs.python.org/3/library/itertools.html#itertools.permutations"&gt;permutations&lt;/a&gt; 函式來創造排列組合的迴圈。&lt;/p&gt;
&lt;p&gt;相符無誤的項目會將 root 節點加入答案，有錯誤則用 continue 關鍵字跳過。&lt;/p&gt;
&lt;pre class="brush: python"&gt;
answer = []
for all_link in list(set(permutations(link_type))):
  ...
  answer.append(links[0])
&lt;/pre&gt;

&lt;p&gt;首先轉換 &lt;code&gt;link_type&lt;/code&gt; 的內容成為 anytree 模組的 Node 類型。&lt;/p&gt;
&lt;p&gt;其中 &lt;code&gt;limit&lt;/code&gt; 屬性是此節點的接頭上限，僅用於比對，並無程式上的限制。&lt;/p&gt;
&lt;pre class="brush: python"&gt;
all_link = [Node("L{}".format(i), limit=v) for i, v in enumerate(all_link)]
&lt;/pre&gt;

&lt;p&gt;接著將第一項當作 root 節點，加入 &lt;code&gt;links&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;這裡 &lt;code&gt;links&lt;/code&gt; 清單的最後一項 &lt;code&gt;links[-1]&lt;/code&gt; 是接下來的搜索法準備填入的項目。&lt;/p&gt;
&lt;pre class="brush: python"&gt;
links = []
links.append(all_link.pop(0))
&lt;/pre&gt;

&lt;p&gt;然後使用廣度優先搜索法 (Breadth-First-Search, BFS) 填入所有節點，使用 list 類型的 pop 方法配上 while 迴圈可以確保用光所有節點。&lt;/p&gt;
&lt;p&gt;當指派一個節點的 &lt;code&gt;parent&lt;/code&gt; 屬性時，anytree 模組會自動將節點連上父節點，父節點可以透過 &lt;code&gt;children&lt;/code&gt; 屬性取得一個裝有所有子節點指標的 tuple 物件。&lt;/p&gt;
&lt;pre class="brush: python"&gt;
while all_link:
    link = all_link.pop(0)
    if (len(links[-1].children) + bool(links[-1].parent))==links[-1].limit:
        links.append(links[-1].children[0])
    link.parent = links[-1]
&lt;/pre&gt;

&lt;p&gt;由於數學定義的「樹 (tree)」結構中，子節點只能擁有一個父項，否則為迴路 (Loop)，anytree 模組會在連接成迴路時自動回擲 &lt;code&gt;LoopError&lt;/code&gt; 錯誤。&lt;/p&gt;
&lt;p&gt;但是我們的運動鍊為 close chain，因此必須再創立一個配對流程，這次使用類似連結的概念，同時為「主體」連結一個虛擬節點。&lt;/p&gt;
&lt;p&gt;虛擬節點的樣式使用中括弧 &lt;code&gt;[ ]&lt;/code&gt; 辨識，不用指派名稱。&lt;/p&gt;
&lt;p&gt;創立 &lt;code&gt;get_no_done&lt;/code&gt; 函式回傳使用 anytree 的 findall 模組過濾沒配對完成的節點。&lt;/p&gt;
&lt;pre class="brush: python"&gt;
get_no_done = lambda: findall(links[0], filter_=lambda n: '[' not in n.name and (len(n.children) + bool(links[-1].parent)) &lt; n.limit)
error = False
while get_no_done():
    nodes = get_no_done()
    try:
        l_1, l_2 = nodes[0], nodes[1]
    except (ValueError, IndexError):
        error = True
        break
    else:
        Node("[{}]".format(l_1.name), limit=str(l_1.limit), parent=l_2)
        Node("[{}]".format(l_2.name), limit=str(l_2.limit), parent=l_1)
&lt;/pre&gt;

&lt;p&gt;最後檢查是否在上述迴圈出現沒閉合狀況。&lt;/p&gt;
&lt;pre class="brush: python"&gt;
if error:
    continue
&lt;/pre&gt;

&lt;p&gt;或是兩對連桿之間有連到一個以上的接頭。&lt;/p&gt;
&lt;pre class="brush: python"&gt;
if findall(links[0], filter_=lambda n: len([c.name for c in n.children])!=len(set(c.name for c in n.children))):
    continue
&lt;/pre&gt;

&lt;p&gt;最後可以進行測試：&lt;/p&gt;
&lt;pre class="brush: python"&gt;
if __name__=='__main__':
    print("Topologic test")
    answer = topo([5, 4])
    #Show tree
    for root in answer:
        print(show_tree(root))
        print('-'*7)
    print("Answer count: {}".format(len(answer)))
&lt;/pre&gt;

&lt;p&gt;可得：&lt;/p&gt;
&lt;pre&gt;
...
-------
L0(2)
├── L1(3)
│   ├── L3(2)
│   │   └── L5(3)
│   │       ├── L6(3)
│   │       │   ├── L8(3)
│   │       │   │   ├── [L6](3)
│   │       │   │   └── [L7](2)
│   │       │   └── [L8](3)
│   │       └── L7(2)
│   │           └── [L8](3)
│   └── L4(2)
│       └── [L2](2)
└── L2(2)
    └── [L4](2)
-------
Answer count: 60
&lt;/pre&gt;

&lt;p&gt;經驗證，所有接頭都有連接。&lt;/p&gt;</content><category term="development"></category></entry><entry><title>Pyslvs v0.9 - 12/03</title><link href="https://pyslvs.github.io/blog/yuan_2017-12-03.html" rel="alternate"></link><published>2017-12-03T21:00:00+08:00</published><updated>2017-12-03T21:00:00+08:00</updated><author><name>Yuan Chang</name></author><id>tag:pyslvs.github.io,2017-12-03:/blog/yuan_2017-12-03.html</id><summary type="html">&lt;ul&gt;
&lt;li&gt;PMKS 轉換式更新&lt;/li&gt;
&lt;li&gt;機構範例&lt;/li&gt;
&lt;/ul&gt;
</summary><content type="html">&lt;ul&gt;
&lt;li&gt;PMKS 轉換式更新&lt;/li&gt;
&lt;li&gt;機構範例&lt;/li&gt;
&lt;/ul&gt;


&lt;h1&gt;PMKS 轉換式更新&lt;/h1&gt;
&lt;p&gt;完成滑動接頭 P 與 RP 的轉換式，已經可以支援這兩種接頭的輸入。&lt;/p&gt;
&lt;p&gt;另外改進了三點共線和共點在 Solvespace 輸入的錯誤。&lt;/p&gt;
&lt;h1&gt;機構範例&lt;/h1&gt;
&lt;p&gt;增加了兩個範例，用作測試上述程式。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;曲柄滑塊&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/pyslvs/17_12_03_01.png"&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;雙臂接球機構&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/pyslvs/17_12_03_02.png"&gt;&lt;/p&gt;</content><category term="development"></category></entry><entry><title>設計、設計方法與機械設計</title><link href="https://pyslvs.github.io/blog/scrum_design-design_methods-and-mechanical-design.html" rel="alternate"></link><published>2017-12-02T11:00:00+08:00</published><updated>2017-12-02T11:00:00+08:00</updated><author><name>scrum</name></author><id>tag:pyslvs.github.io,2017-12-02:/blog/scrum_design-design_methods-and-mechanical-design.html</id><summary type="html">&lt;p&gt;從設計觀念的釐清, 到設計方法的探尋, 以及利用各種設計方法來進行機械設計, 到底有沒有一套脈絡或論述可以依循?&lt;/p&gt;
</summary><content type="html">&lt;p&gt;從設計觀念的釐清, 到設計方法的探尋, 以及利用各種設計方法來進行機械設計, 到底有沒有一套脈絡或論述可以依循?&lt;/p&gt;


&lt;h2&gt;設計到底是甚麼?&lt;/h2&gt;
&lt;p&gt;在工程領域, 設計應該是一種表達, 而且是能夠讓參與設計的所有團隊成員都充分了解, 且據以依循, 可以得到預期結果的具體表達.&lt;/p&gt;
&lt;p&gt;工程設計常用的表達至少有口語、文字、2D、3D、數學與實體等六種方式.&lt;/p&gt;
&lt;p&gt;例如: 利用 &lt;a href="http://leoeditor.com/"&gt;Leo Editor&lt;/a&gt; 管理 &lt;a href="https://github.com/getpelican/pelican"&gt;Pelican&lt;/a&gt; 靜態網誌系統的協同使用"設計", 文字表達敘述如下:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;這是一套允許多人協同編寫位於 content 目錄下的 &lt;a href="https://en.wikipedia.org/wiki/Markdown"&gt;Markdown&lt;/a&gt; 檔案格式或 &lt;a href="https://en.wikipedia.org/wiki/ReStructuredText"&gt;reStructuredText&lt;/a&gt; 格式文章原稿的系統&lt;/li&gt;
&lt;li&gt;為了完整保留本網誌系統原稿與設定檔案的歷程資料, 採用 &lt;a href="https://github.com/"&gt;Github&lt;/a&gt; 或 &lt;a href="https://www.fossil-scm.org"&gt;Fossil SCM&lt;/a&gt; 進行內容組態管理&lt;/li&gt;
&lt;li&gt;為了在組態管理歷程資料過程, 避免各學員的 &lt;a href="http://leoeditor.com/"&gt;Leo Editor&lt;/a&gt; 專案 XML 檔案, 因合併產生衝突處理上的困難, 規定各成員必須自行維護管理 users 目錄下, 以作者名稱命名的 .leo 檔案&lt;/li&gt;
&lt;li&gt;為了讓 &lt;a href="https://github.com/getpelican/pelican"&gt;Pelican&lt;/a&gt; 所產生的 html 網誌系統, 可以同時在無網路連線的近端與雲端上使用, 近端利用 &lt;a href="https://github.com/pyslvs/pyslvs.github.io/blob/master/pelicanconf.py"&gt;pelicanconf.py&lt;/a&gt; 加上 &lt;a href="https://github.com/pyslvs/pyslvs.github.io/blob/master/local_publishconf.py"&gt;local_publishconf.py&lt;/a&gt; 轉檔, 遠端則使用 &lt;a href="https://github.com/pyslvs/pyslvs.github.io/blob/master/pelicanconf.py"&gt;pelicanconf.py&lt;/a&gt; 加上 &lt;a href="https://github.com/pyslvs/pyslvs.github.io/blob/master/publishconf.py"&gt;publishconf.py&lt;/a&gt; 轉檔&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/getpelican/pelican"&gt;Pelican&lt;/a&gt; 轉換完成的 html 檔案, 設定置於 blog 目錄中&lt;/li&gt;
&lt;li&gt;由於 &lt;a href="https://github.com/getpelican/pelican"&gt;Pelican&lt;/a&gt; 轉換後的 html 位於 blog 子目錄, 因此整個系統根目錄中的 index.html 以 head 標註中的 meta redirect 跳轉至 blog 目錄中的 index.html&lt;/li&gt;
&lt;li&gt;為了讓多人所建立的文章原稿, 同時存入 content 目錄而不會產生覆蓋, 規定以作者名稱加上底線, 再加上當天日期及副檔名命名&lt;/li&gt;
&lt;li&gt;作者若同一天建立多篇文章原稿, 則以用戶名稱_日期-1.md 等 dash 後加上數字區別&lt;/li&gt;
&lt;li&gt;因為 &lt;a href="https://github.com/getpelican/pelican"&gt;Pelican&lt;/a&gt; 針對沒有 slug 欄位設定的中文標題文章原稿, 會以拉丁拼音命名轉換後的 html 檔案, 比較不容易望文生義, 因此建議各文章以有意義的英文名稱命名, 且最前方加上作者名稱, 以避免因重複 slug 設定, 而讓 &lt;a href="https://github.com/getpelican/pelican"&gt;Pelican&lt;/a&gt; 無法轉檔&lt;/li&gt;
&lt;li&gt;為了讓各用戶的 &lt;a href="http://leoeditor.com/"&gt;Leo Editor&lt;/a&gt; 文章節點中, 以 @edit 或 @clean 節點指令下的文章更容易查找, 建議在存檔節點的根節點, 以文章標題註記&lt;/li&gt;
&lt;li&gt;有關 &lt;a href="https://github.com/arulrajnet/attila"&gt;attila&lt;/a&gt; 樣板右方 menu 側欄中的連結增刪, 可以透過編輯 partials 目錄中的 navigation.html 達成&lt;/li&gt;
&lt;li&gt;頁面正中方的搜尋表達, 以修改近端與雲端 templates 目錄中的 base.html 檔案中的 search section, 套入 &lt;a href="https://github.com/pyslvs/pyslvs.github.io/blob/master/theme/attila/templates/search.html"&gt;search.html&lt;/a&gt; 達成&lt;/li&gt;
&lt;li&gt;系統啟用 &lt;a href="https://github.com/getpelican/pelican-plugins/tree/master/summary"&gt;summary plugin&lt;/a&gt; 的目的, 在於讓 &lt;a href="https://en.wikipedia.org/wiki/ReStructuredText"&gt;reStructuredText&lt;/a&gt; 格式文章原稿可以透過標註, 區隔摘要與內文&lt;/li&gt;
&lt;li&gt;系統啟用 &lt;a href="https://github.com/getpelican/pelican-plugins/tree/master/neighbors"&gt;neighbors plugin&lt;/a&gt; 的目的, 在於讓各篇文章末端出現前後文章的連結, 以方便循序瀏覽閱讀&lt;/li&gt;
&lt;li&gt;系統啟用 &lt;a href="https://github.com/getpelican/pelican-plugins/tree/master/tipue_search"&gt;tipuesearch plugin&lt;/a&gt; 的目的, 在於讓使用者可以透過兩個字元以上的關鍵字進行全文搜尋&lt;/li&gt;
&lt;li&gt;為了讓 &lt;a href="https://github.com/getpelican/pelican"&gt;Pelican&lt;/a&gt; 轉換完成的 html 檔案, 可以採 &lt;a href="http://www.tipue.com/search/"&gt;tipuesearch&lt;/a&gt; Javascript 延伸功能, 以關鍵字搜尋, 近端關鍵字以 &lt;a href="https://github.com/pyslvs/pyslvs.github.io/blob/master/blog/tipuesearch_content.js"&gt;tipuesearch_content.js&lt;/a&gt; 儲存, 遠端則使用 &lt;a href="https://github.com/pyslvs/pyslvs.github.io/blob/master/blog/tipuesearch_content.json"&gt;tipuesearch_content.json&lt;/a&gt; 儲存, 詳細內容可參見 plugin 目錄中, tipue_search 子目錄中的 &lt;a href="https://github.com/pyslvs/pyslvs.github.io/blob/master/plugin/tipue_search/tipue_search.py"&gt;tipue_search.py&lt;/a&gt; 設定&lt;/li&gt;
&lt;li&gt;上述之所以在轉檔階段需要區分近端與雲端的原因, 在於近端無 &lt;a href="https://disqus.com/"&gt;disqus&lt;/a&gt; 設定, 而遠端則附加 &lt;a href="https://disqus.com/"&gt;disqus&lt;/a&gt; 回應系統&lt;/li&gt;
&lt;li&gt;為了讓近端與遠端瀏覽器中各 &lt;a href="https://en.wikipedia.org/wiki/Ajax_(programming)"&gt;AJAX&lt;/a&gt; 前後端程式系統的反應一致, 近端利用 www-server 按鈕, 以執行緒啟動 https 伺服器, 使用者可以在轉檔完成後, 以瀏覽器 IPv4 網路協定檢查內容&lt;/li&gt;
&lt;li&gt;為了讓系統在 IPv6 網路協定下正常運作, 以 ipv6-https-server 按鈕, 以執行緒啟動 https 伺服器, 使用者可以在轉檔完成後 ,以瀏覽器 IPv6 網路協定檢查內容&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;當然, 本網誌系統的完整原始資料都保存在 &lt;a href="https://github.com/pyslvs/pyslvs.github.io"&gt;Pyslvs 倉儲&lt;/a&gt;, 任何人只要 git clone 倉儲, 稍加修改, 就可以另起爐灶, 延續這個網誌系統的價值, 但是其中許多細微精密的設計, 若沒有完整表達, 一旦爾後使用環境改變或各相關系統改版, 使用者就無法充分掌握各開放系統的互動搭配, 獨力配置因應.&lt;/p&gt;
&lt;p&gt;換言之, 工程領域中與所謂設計相關的具體表達, 至少是時間與所處環境的函數, 一旦時空轉變, 就必須透過完整的歷程組態管理紀錄, 啟動各互動元件間的配置修改, 方能延續或加值原始設計的表達, 得到預期結果.&lt;/p&gt;
&lt;h2&gt;設計方法&lt;/h2&gt;
&lt;p&gt;假如我們接受在工程領域中, 上述所謂設計是一種表達的陳述, 那麼在表達設計的歷程中, 將存在許多解決問題的方法, 與所處時空背景的說明.&lt;/p&gt;
&lt;p&gt;首先, 甚麼是方法? "方"為合乎約制條件, 可以實際拿出來使用的策略與規則, 表示並非空想, 而可實際施行的內容, 才叫"方". 至於"法"是順應自然條件下, 可因時空而制宜的最高行事準則. 因此"方法"就是: 配合不同條件, 實際施行的最高準則.&lt;/p&gt;
&lt;p&gt;而再從上述設計有六種表達方式的論述出發, 那麼以口語表達而言的設計方法, 就是:&lt;/p&gt;
&lt;p&gt;配合不同條件, 實際施行口語表達的最高準則. 也就是因應環境與對象, 將設計內容, 說清楚講明白所採行的策略與準則.&lt;/p&gt;
&lt;p&gt;因此, 所謂設計方法, 除了口語表達外, 還可以從文字、2D、3D、數學與實體等表達的形式, 加以發揮, 具體呈現設計內容.&lt;/p&gt;
&lt;p&gt;由於設計方法以各種形式表達的過程中, 會因時空背景與參與人員所做決策的差異, 而產生不同的結果, 多人協同團隊為了更有效掌握過程中的各項細節, 因此設計方法及組成元件有關的組態管理系統 (Configuration Management) 因應而生.&lt;/p&gt;
&lt;h2&gt;機械設計&lt;/h2&gt;
&lt;p&gt;機械是一種器物, 而且是由固體、流體與軟體元件精巧組合而成, 可互動運作, 達成特定功能之器物. 因此機械設計就是靈活運用六種表達方式, 明確說明如何透過固體、流體與軟體元件之互動運作, 而能達成預定結果之明確與具體表達.&lt;/p&gt;
&lt;p&gt;&lt;a href="http://pyslvs.com"&gt;Pyslvs&lt;/a&gt; 是機械設計過程中的一項工具, 主要由平面機構模擬核心、演化運算核心與視窗圖形化介面程式所組成. 其中, 兩種運算核心都依據平面機構有關的數學模型與分析表達, 採用軟體元件製作, 再結合 2D 使用者圖形介面建立物件導向, 以及事件驅動程式元件等功能, 讓使用者可以輸入平面機構模型後, 進行模擬或合成運算.&lt;/p&gt;
&lt;p&gt;而 &lt;a href="http://pyslvs.com"&gt;Pyslvs&lt;/a&gt; 平面機構模擬核心的主體為一套 Geometric Constrain Solver, 依附在 Solvespace 參數化 3D 繪圖套件中. 在 2013 年 9 月透過 &lt;a href="http://www.swig.org/"&gt;SWIG&lt;/a&gt; (Simplified Wrapper and Interface Generator) 技術, 轉為 Python2 可呼叫的程式庫, 為 &lt;a href="https://github.com/BBBSnowball/python-solvespace"&gt;Python2-Solvespace&lt;/a&gt;. 2016 年 7 月之後, 經本站轉為 Python3 可呼叫的程式庫, 成為 &lt;a href="https://github.com/KmolYuan/python-solvespace"&gt;Python3-Solvespace&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;至於 &lt;a href="http://pyslvs.com"&gt;Pyslvs&lt;/a&gt; 平面機構合成所使用的演化運算核心 ,則源自 2015 年 4 月利用 &lt;a href="http://cython.org/"&gt;Cython&lt;/a&gt; (C-extension for Python) 技術所開發的 &lt;a href="https://github.com/kmollee/algorithm"&gt;Algorithm&lt;/a&gt;, 包含實數編碼基因 (Real-coded Genetic) 演算法、差分進化 (Differential Evolution) 演算法與螢火蟲 (Firefly) 演算法等模組.&lt;/p&gt;
&lt;p&gt;&lt;a href="http://pyslvs.com"&gt;Pyslvs&lt;/a&gt; 的圖形介面採用 &lt;a href="https://www.riverbankcomputing.com/software/pyqt/intro"&gt;PyQt5&lt;/a&gt; , 在 &lt;a href="https://eric-ide.python-projects.org"&gt;Eric6&lt;/a&gt; 整合開發環境中建立.&lt;/p&gt;</content><category term="design"></category><category term="design method"></category><category term="mechanical design"></category></entry><entry><title>Pyslvs v0.9 - 11/28</title><link href="https://pyslvs.github.io/blog/yuan_2017-11-28.html" rel="alternate"></link><published>2017-11-28T21:00:00+08:00</published><updated>2017-11-28T21:00:00+08:00</updated><author><name>Yuan Chang</name></author><id>tag:pyslvs.github.io,2017-11-28:/blog/yuan_2017-11-28.html</id><summary type="html">&lt;ul&gt;
&lt;li&gt;介面操作重大更新&lt;/li&gt;
&lt;/ul&gt;
</summary><content type="html">&lt;ul&gt;
&lt;li&gt;介面操作重大更新&lt;/li&gt;
&lt;/ul&gt;


&lt;h1&gt;介面操作重大更新&lt;/h1&gt;
&lt;p&gt;今天改寫了一下畫布介面。&lt;/p&gt;
&lt;p&gt;將拍照到剪貼簿的按鈕移到右上角的版本標籤旁；表格頁籤旁改成「全部選擇」按鈕。&lt;/p&gt;
&lt;p&gt;新增兩個功能的快捷鍵：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;全選點 (Select all point)：Ctrl + A&lt;/li&gt;
&lt;li&gt;自由移動模式切換 (Free move mode toggle)：Ctrl + F&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;另外有一個重大突破：矩形窗選功能。&lt;/p&gt;
&lt;p&gt;在非自由移動模式下可靠滑鼠拖拉矩形線框，選取畫布上的點。&lt;/p&gt;
&lt;p&gt;自由移動模式下拖拉將會移動並修改選擇的點座標。&lt;/p&gt;
&lt;iframe width="854" height="480" src="https://www.youtube.com/embed/-pdUPiUBOfA" frameborder="0" gesture="media" allow="encrypted-media" allowfullscreen&gt;&lt;/iframe&gt;</content><category term="development"></category></entry><entry><title>Pyslvs.com 上線</title><link href="https://pyslvs.github.io/blog/pyslvs-on-line.html" rel="alternate"></link><published>2017-11-26T12:00:00+08:00</published><updated>2017-11-26T12:00:00+08:00</updated><author><name>pyslvs.com</name></author><id>tag:pyslvs.github.io,2017-11-26:/blog/pyslvs-on-line.html</id><summary type="html">&lt;p&gt;2017.11.26 之前的 pyslvs 網站內容備份在 &lt;a href="https://kmolyuan.github.io/pyslvs/"&gt;https://kmolyuan.github.io/pyslvs/&lt;/a&gt;, 目前的 &lt;a href="http://pyslvs.com"&gt;http://pyslvs.com&lt;/a&gt; 使用 &lt;a href="http://pyslvs.github.io"&gt;http://pyslvs.github.io&lt;/a&gt; 作為網站內容, disqus 則登記為 pyslvs-com.&lt;/p&gt;
</summary><content type="html">&lt;p&gt;2017.11.26 之前的 pyslvs 網站內容備份在 &lt;a href="https://kmolyuan.github.io/pyslvs/"&gt;https://kmolyuan.github.io/pyslvs/&lt;/a&gt;, 目前的 &lt;a href="http://pyslvs.com"&gt;http://pyslvs.com&lt;/a&gt; 使用 &lt;a href="http://pyslvs.github.io"&gt;http://pyslvs.github.io&lt;/a&gt; 作為網站內容, disqus 則登記為 pyslvs-com.&lt;/p&gt;


&lt;p&gt;這項改變的目的是以 &lt;a href="https://github.com/getpelican/pelican"&gt;Pelican&lt;/a&gt; 靜態網頁取代原先的一頁式網頁, 除了比較容易維護之外, 也可以提供更充實的內容.&lt;/p&gt;
&lt;p&gt;這項以 &lt;a href="https://pages.github.com/"&gt;Github Pages&lt;/a&gt; 架構作為雲端 WWW 伺服器, 而 DNS 的設定首先是將 &lt;a href="http://www.pyslvs.com"&gt;http://www.pyslvs.com&lt;/a&gt; 以 CNAME 指向 &lt;a href="http://pyslvs.github.io"&gt;http://pyslvs.github.io&lt;/a&gt;, 然後在內定轉址的根網址 &lt;a href="http://pyslvs.com"&gt;http://pyslvs.com&lt;/a&gt;, 以 301 類型轉至 &lt;a href="http://www.pyslvs.com"&gt;http://www.pyslvs.com&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;至於 &lt;a href="https://pages.github.com/"&gt;Github Pages&lt;/a&gt; 的部分則是針對 &lt;a href="https://github.com/pyslvs/pyslvs.github.io"&gt;https://github.com/pyslvs/pyslvs.github.io&lt;/a&gt; 倉儲, 將 Settings 中的 Custom Domain 設為 &lt;a href="http://www.pyslvs.com"&gt;http://www.pyslvs.com&lt;/a&gt; 就算完成.&lt;/p&gt;
&lt;p&gt;Pyslvs 的原意為 Python for &lt;a href="http://solvespace.com"&gt;Solvespace&lt;/a&gt;, 是讓使用者容易使用 &lt;a href="http://solvespace.com"&gt;Solvespace&lt;/a&gt; 所開源出來的 Geometric Constraint Solver, 也就是 &lt;a href="https://github.com/KmolYuan/python-solvespace"&gt;Python Solvespace&lt;/a&gt;, 隨後利用 &lt;a href="https://www.riverbankcomputing.com/software/pyqt/download5"&gt;PyQt5&lt;/a&gt; 使用者介面並加上演化合成引擎, 成為目前的 PSLVS (Python Synthesis of Linkages and Verification Software), 中文為 Python 機構合成與驗證套件, 其開發目標希望成為一套能夠用於機械產品平面機構合成與機構可用性驗證的模擬分析與最佳化設計套件.&lt;/p&gt;
&lt;p&gt;其他開放源機構分析軟體:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://blog.rectorsquid.com/linkage-mechanism-designer-and-simulator/"&gt;http://blog.rectorsquid.com/linkage-mechanism-designer-and-simulator/&lt;/a&gt; (Github: &lt;a href="https://github.com/rectorsquid/Linkage"&gt;https://github.com/rectorsquid/Linkage&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;&lt;a href="https://designengrlab.github.io/PMKS/"&gt;https://designengrlab.github.io/PMKS/&lt;/a&gt; (Github: &lt;a href="https://github.com/DesignEngrLab/PMKS"&gt;https://github.com/DesignEngrLab/PMKS&lt;/a&gt;)&lt;/li&gt;
&lt;/ul&gt;</content><category term="pyslvs"></category></entry></feed>