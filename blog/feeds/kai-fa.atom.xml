<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>Pyslvs.com - 開發</title><link href="https://pyslvs.github.io/blog/" rel="alternate"></link><link href="https://pyslvs.github.io/blog/feeds/kai-fa.atom.xml" rel="self"></link><id>https://pyslvs.github.io/blog/</id><updated>2018-02-11T21:00:00+08:00</updated><entry><title>Pyslvs v18.2.0 - 02/11</title><link href="https://pyslvs.github.io/blog/yuan_2018-02-11.html" rel="alternate"></link><published>2018-02-11T21:00:00+08:00</published><updated>2018-02-11T21:00:00+08:00</updated><author><name>Yuan Chang</name></author><id>tag:pyslvs.github.io,2018-02-11:/blog/yuan_2018-02-11.html</id><summary type="html">&lt;ul&gt;
&lt;li&gt;Ball lifter mechanism synthesis test 提球機構合成測試&lt;/li&gt;
&lt;/ul&gt;
</summary><content type="html">&lt;ul&gt;
&lt;li&gt;Ball lifter mechanism synthesis test 提球機構合成測試&lt;/li&gt;
&lt;/ul&gt;


&lt;h1&gt;Ball lifter mechanism synthesis test 提球機構合成測試&lt;/h1&gt;
&lt;p&gt;The new synthesis options will support algorithms that end with fitness, and we will conduct small calculations for ball lifter mechanisms with two target paths.&lt;/p&gt;
&lt;p&gt;新的合成設定中將支援隨適應值結束演算法，針對有兩個目標路徑的提球機構展開小型演算測試。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="../data/images/18_02_11_01.png"&gt;&lt;/p&gt;
&lt;p&gt;The construction of the ball lifter mechanism is so variable that it takes 6 minutes to 20 minutes to calculate the fitness below 100.&lt;/p&gt;
&lt;p&gt;提球機構的變數較多，導致演算適應值至 100 以下的所需時間為 6 分鐘到 20 分鐘不等。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="../data/images/18_02_11_02.png"&gt;&lt;/p&gt;
&lt;p&gt;In addition, the staggered position of two target paths will also affect the result.&lt;/p&gt;
&lt;p&gt;另外，兩段目標路徑的交錯位置也會影結果。&lt;/p&gt;</content><category term="development"></category></entry><entry><title>Pyslvs v18.1.0 - 01/25</title><link href="https://pyslvs.github.io/blog/yuan_2018-01-25.html" rel="alternate"></link><published>2018-01-25T21:00:00+08:00</published><updated>2018-01-25T21:00:00+08:00</updated><author><name>Yuan Chang</name></author><id>tag:pyslvs.github.io,2018-01-25:/blog/yuan_2018-01-25.html</id><summary type="html">&lt;ul&gt;
&lt;li&gt;Triangular iteration 三角迭代展示影片&lt;/li&gt;
&lt;/ul&gt;
</summary><content type="html">&lt;ul&gt;
&lt;li&gt;Triangular iteration 三角迭代展示影片&lt;/li&gt;
&lt;/ul&gt;


&lt;h1&gt;Triangular iteration demo video 三角迭代展示影片&lt;/h1&gt;
&lt;p&gt;Video - English version:&lt;/p&gt;
&lt;iframe width="560" height="315" src="https://www.youtube.com/embed/-zmGU0RoFNo" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen&gt;&lt;/iframe&gt;

&lt;p&gt;Video - Traditional Chinese version:&lt;/p&gt;
&lt;iframe width="560" height="315" src="https://www.youtube.com/embed/h9eqmw9gRDg" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen&gt;&lt;/iframe&gt;

&lt;p&gt;Triangular iteration function will be update in version 18.1.&lt;/p&gt;
&lt;p&gt;But the profile can not apply in dimensional synthesis function currently.&lt;/p&gt;
&lt;p&gt;三角迭代功能將會於 18.1 版更新。&lt;/p&gt;
&lt;p&gt;但是目前的配置資訊不能應用於尺寸合成功能。&lt;/p&gt;</content><category term="development"></category></entry><entry><title>Pyslvs v18.1.0 - 01/07</title><link href="https://pyslvs.github.io/blog/yuan_2018-01-07.html" rel="alternate"></link><published>2018-01-07T21:00:00+08:00</published><updated>2018-01-07T21:00:00+08:00</updated><author><name>Yuan Chang</name></author><id>tag:pyslvs.github.io,2018-01-07:/blog/yuan_2018-01-07.html</id><summary type="html">&lt;ul&gt;
&lt;li&gt;Topological library 拓樸程式庫&lt;/li&gt;
&lt;li&gt;Atlas function 圖譜功能&lt;/li&gt;
&lt;/ul&gt;
</summary><content type="html">&lt;ul&gt;
&lt;li&gt;Topological library 拓樸程式庫&lt;/li&gt;
&lt;li&gt;Atlas function 圖譜功能&lt;/li&gt;
&lt;/ul&gt;


&lt;h1&gt;Topological library 拓樸程式庫&lt;/h1&gt;
&lt;p&gt;For better computing performance, the number synthesis library changed to Cython prepared. Which extracted some of the functions of NetworkX module, translated into Cython syntax.&lt;/p&gt;
&lt;p&gt;為取得更好的運算效能，數目合成的程式庫改為 Cython 編寫。其中提取 NetworkX 模組的部份功能，轉譯為 Cython 語法。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;Graph&lt;/code&gt; class&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;edges&lt;/code&gt; public &lt;code&gt;object&lt;/code&gt; (&lt;code&gt;tuple&lt;/code&gt;)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;nodes&lt;/code&gt; public &lt;code&gt;object&lt;/code&gt; (&lt;code&gt;tuple&lt;/code&gt;)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;adj&lt;/code&gt; public &lt;code&gt;object&lt;/code&gt; (&lt;code&gt;dict&lt;/code&gt;)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;neighbors&lt;/code&gt; cpp function&lt;/li&gt;
&lt;li&gt;&lt;code&gt;has_triangles&lt;/code&gt; cpp function&lt;/li&gt;
&lt;li&gt;&lt;code&gt;is_connected&lt;/code&gt; cpp function&lt;/li&gt;
&lt;li&gt;&lt;code&gt;degree&lt;/code&gt; cpp function&lt;/li&gt;
&lt;li&gt;&lt;code&gt;number_of_edges&lt;/code&gt; cpp function&lt;/li&gt;
&lt;li&gt;&lt;code&gt;__len__&lt;/code&gt; cpp function&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;GraphMatcher&lt;/code&gt; class&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;G1&lt;/code&gt; public &lt;code&gt;Graph&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;G2&lt;/code&gt; public &lt;code&gt;Graph&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;G1_nodes&lt;/code&gt; &lt;code&gt;object&lt;/code&gt; (&lt;code&gt;set&lt;/code&gt;)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;G2_nodes&lt;/code&gt; &lt;code&gt;object&lt;/code&gt; (&lt;code&gt;set&lt;/code&gt;)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;mapping&lt;/code&gt; &lt;code&gt;object&lt;/code&gt; (&lt;code&gt;set&lt;/code&gt;)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;core_1&lt;/code&gt; public &lt;code&gt;object&lt;/code&gt; (&lt;code&gt;set&lt;/code&gt;)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;core_2&lt;/code&gt; public &lt;code&gt;object&lt;/code&gt; (&lt;code&gt;set&lt;/code&gt;)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;inout_1&lt;/code&gt; public &lt;code&gt;object&lt;/code&gt; (&lt;code&gt;set&lt;/code&gt;)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;inout_2&lt;/code&gt; public &lt;code&gt;object&lt;/code&gt; (&lt;code&gt;set&lt;/code&gt;)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;state&lt;/code&gt; &lt;code&gt;GMState&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;initialize&lt;/code&gt; c function&lt;/li&gt;
&lt;li&gt;&lt;code&gt;candidate_pairs_iter&lt;/code&gt; python generator&lt;/li&gt;
&lt;li&gt;&lt;code&gt;is_isomorphic&lt;/code&gt; cpp function&lt;/li&gt;
&lt;li&gt;&lt;code&gt;isomorphisms_iter&lt;/code&gt; python generator&lt;/li&gt;
&lt;li&gt;&lt;code&gt;match&lt;/code&gt; python generator&lt;/li&gt;
&lt;li&gt;&lt;code&gt;semantic_feasibility&lt;/code&gt; c function&lt;/li&gt;
&lt;li&gt;&lt;code&gt;syntactic_feasibility&lt;/code&gt; c function&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;GMState&lt;/code&gt; class&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;GM&lt;/code&gt; &lt;code&gt;GraphMatcher&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;G1_node&lt;/code&gt; &lt;code&gt;object&lt;/code&gt; (&lt;code&gt;None&lt;/code&gt; or &lt;code&gt;int&lt;/code&gt;)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;G2_node&lt;/code&gt; &lt;code&gt;object&lt;/code&gt; (&lt;code&gt;None&lt;/code&gt; or &lt;code&gt;int&lt;/code&gt;)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;depth&lt;/code&gt; &lt;code&gt;int&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;Atlas function 圖譜功能&lt;/h1&gt;
&lt;p&gt;Use the text file to store the atlas, the expression is the &lt;code&gt;edge&lt;/code&gt; attribute in &lt;code&gt;Graph&lt;/code&gt; class.&lt;/p&gt;
&lt;p&gt;You can also load text files into Pyslvs for processing.&lt;/p&gt;
&lt;p&gt;使用文字文件儲存圖譜，表示式為 &lt;code&gt;Graph&lt;/code&gt; 類型的 &lt;code&gt;edges&lt;/code&gt; 屬性。&lt;/p&gt;
&lt;p&gt;另外還可以將文字文件載入 Pyslvs 中處理。&lt;/p&gt;
&lt;iframe width="560" height="315" src="https://www.youtube.com/embed/RzD6_WKJjVM" frameborder="0" gesture="media" allow="encrypted-media" allowfullscreen&gt;&lt;/iframe&gt;</content><category term="development"></category></entry><entry><title>Pyslvs 2018 Plan</title><link href="https://pyslvs.github.io/blog/yuan_2018_plan.html" rel="alternate"></link><published>2018-01-07T12:00:00+08:00</published><updated>2018-01-07T12:00:00+08:00</updated><author><name>Yuan Chang</name></author><id>tag:pyslvs.github.io,2018-01-07:/blog/yuan_2018_plan.html</id><summary type="html">&lt;ul&gt;
&lt;li&gt;About release 關於發佈&lt;/li&gt;
&lt;/ul&gt;
</summary><content type="html">&lt;ul&gt;
&lt;li&gt;About release 關於發佈&lt;/li&gt;
&lt;/ul&gt;


&lt;h1&gt;About release 關於發佈&lt;/h1&gt;
&lt;p&gt;Since 2018, Pyslvs will take the monthly release of the version update. The format of the version will be numbered as &lt;code&gt;{year}.{month}.{patch}&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;The progress of the update will be updated in both English and Traditional Chinese in this blog.&lt;/p&gt;
&lt;p&gt;The "開發" category in this blog will refer to questions (concepts) that Pyslvs faces and how to use the existing knowledge collation to reach a solution to the problem.&lt;/p&gt;
&lt;p&gt;自 2018 年開始，Pyslvs 將會採取每月釋出的方式進行版本更新。版本格式將以 &lt;code&gt;{year}.{month}.{patch}&lt;/code&gt; 的方式編號。&lt;/p&gt;
&lt;p&gt;更新進度將以英文與繁體中文的方式全部更新在本網誌。&lt;/p&gt;
&lt;p&gt;本網誌的「開發」類別中將會提及 Pyslvs 面臨的問題（概念），並如何使用現有的知識歸類，達成問題的解決途徑。&lt;/p&gt;</content><category term="development"></category></entry><entry><title>Pyslvs v0.9 - 12/12</title><link href="https://pyslvs.github.io/blog/yuan_2017-12-12.html" rel="alternate"></link><published>2017-12-12T21:00:00+08:00</published><updated>2017-12-12T21:00:00+08:00</updated><author><name>Yuan Chang</name></author><id>tag:pyslvs.github.io,2017-12-12:/blog/yuan_2017-12-12.html</id><summary type="html">&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Graphviz 引擎限制（已解決）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Beta 3 Release&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
</summary><content type="html">&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Graphviz 引擎限制（已解決）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Beta 3 Release&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;


&lt;h1&gt;Graphviz 引擎限制（已解決）&lt;/h1&gt;
&lt;p&gt;最後使用 NetworkX 呼叫 Pydot 模組克服障礙。&lt;/p&gt;
&lt;p&gt;Pydot 模組的原理是使用 command line 擷取回傳資訊，因此只要系統可以呼叫「dot」等指令即可。&lt;/p&gt;
&lt;p&gt;即使不安裝 Graphviz，Pyslvs 只會跳出提醒視窗，可以選擇 Network 的引擎，或是馬上安裝，不用重開 Pyslvs 也可以重繪圖譜。&lt;/p&gt;
&lt;p&gt;嘗試之餘也完成了轉換式，可以接頭表示；另外還有排除退化結果的功能。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/pyslvs/17_12_12.png"&gt;&lt;/p&gt;
&lt;h1&gt;Beta 3 Release&lt;/h1&gt;
&lt;p&gt;先釋出測試版，包含 beta 2 之後的進度。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;舊的函式錯誤修復。&lt;/li&gt;
&lt;li&gt;PMKS 表示式的 P 和 RP 接頭已經支援。&lt;/li&gt;
&lt;li&gt;矩形選取模式。&lt;/li&gt;
&lt;li&gt;類型合成圖譜。&lt;/li&gt;
&lt;li&gt;更多範例。&lt;/li&gt;
&lt;/ul&gt;</content><category term="development"></category></entry><entry><title>Pyslvs v0.9 - 12/10</title><link href="https://pyslvs.github.io/blog/yuan_2017-12-10.html" rel="alternate"></link><published>2017-12-10T21:00:00+08:00</published><updated>2017-12-10T21:00:00+08:00</updated><author><name>Yuan Chang</name></author><id>tag:pyslvs.github.io,2017-12-10:/blog/yuan_2017-12-10.html</id><summary type="html">&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;QIcon 透明背景繪製&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Graphviz 引擎限制&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
</summary><content type="html">&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;QIcon 透明背景繪製&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Graphviz 引擎限制&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;


&lt;h1&gt;QIcon 透明背景繪製&lt;/h1&gt;
&lt;p&gt;使用 QImage 取代 QPixmap 可以繪製出具有透明背景的圖示或影像。&lt;/p&gt;
&lt;pre class="brush: python"&gt;
image = QImage(QSize(*rect), QImage.Format_ARGB32_Premultiplied)
image.fill(Qt.transparent)
painter = QPainter(image)
painter.translate(image.width()/2, image.height()/2)
painter.end()
return QIcon(QPixmap.fromImage(image).scaledToWidth(width))
&lt;/pre&gt;

&lt;p&gt;從 QIcon 轉為 QPixmap 可以用 &lt;code&gt;pixmap(size: QSize)&lt;/code&gt; 或 &lt;code&gt;pixmap(w: float, h: float)&lt;/code&gt; 方法。&lt;/p&gt;
&lt;pre class="brush: python"&gt;
listWidget.currentItem().icon().pixmap(listWidget.iconSize())
&lt;/pre&gt;

&lt;h1&gt;Graphviz 引擎限制&lt;/h1&gt;
&lt;p&gt;NetworkX 透過 PyGraphviz 引入 Graphviz 的繪圖演算法，提供更好的節點位置在圖譜中表現。&lt;/p&gt;
&lt;p&gt;Graphviz 引擎如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;dot&lt;/li&gt;
&lt;li&gt;neato&lt;/li&gt;
&lt;li&gt;fdp&lt;/li&gt;
&lt;li&gt;twopi&lt;/li&gt;
&lt;li&gt;circo&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;其中 circo 和 neato 的效果較符合圖譜期望。&lt;/p&gt;
&lt;p&gt;NetworkX 引擎如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;kamada kawai（有 SciPy 需求因此未加入）&lt;/li&gt;
&lt;li&gt;shell&lt;/li&gt;
&lt;li&gt;circular&lt;/li&gt;
&lt;li&gt;spring&lt;/li&gt;
&lt;li&gt;spectral&lt;/li&gt;
&lt;li&gt;random&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;其中較適合的為 shell，random 為隨機產生。&lt;/p&gt;
&lt;p&gt;很遺憾的是，Windows x64 的 Python 無法安裝 PyGraphviz，因此 Pyslvs 目前只有 Ubuntu 版本提供 Graphviz 引擎。&lt;/p&gt;
&lt;p&gt;而經測試，AppImage 技術由於只將 PyGraphviz 包入，端口程式庫仍然連接 Graphviz 程式庫，所以 &lt;strong&gt;Ubuntu 用戶必須安裝 Graphviz&lt;/strong&gt;。&lt;/p&gt;
&lt;pre class="brush: bash"&gt;
sudo apt install graphviz
&lt;/pre&gt;

&lt;p&gt;以下是瓦特與史帝芬生鍊用 neato 引擎排佈的結果。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/pyslvs/17_12_10.png"&gt;&lt;/p&gt;</content><category term="development"></category></entry><entry><title>Pyslvs v0.9 - 12/05</title><link href="https://pyslvs.github.io/blog/yuan_2017-12-05.html" rel="alternate"></link><published>2017-12-05T21:00:00+08:00</published><updated>2017-12-05T21:00:00+08:00</updated><author><name>Yuan Chang</name></author><id>tag:pyslvs.github.io,2017-12-05:/blog/yuan_2017-12-05.html</id><summary type="html">&lt;ul&gt;
&lt;li&gt;拓樸排列程式&lt;/li&gt;
&lt;/ul&gt;
</summary><content type="html">&lt;ul&gt;
&lt;li&gt;拓樸排列程式&lt;/li&gt;
&lt;/ul&gt;


&lt;h1&gt;拓樸排列程式&lt;/h1&gt;
&lt;p&gt;花了一些時間寫了一個排列拓樸程式，將概念寫在這邊。&lt;/p&gt;
&lt;p&gt;在論壇爬文時，看到作者自己推薦的 Python 樹狀結構模組 anytree，看了說明文件後決定使用此模組協助樹狀管理。&lt;/p&gt;
&lt;p&gt;以一個四連桿 (4,) 的樹狀拓樸如下，只有一種排列方法：&lt;/p&gt;
&lt;pre&gt;
L0(2)
├── L1(2)
│   └── L3(2)
│       └── [L2](2)
└── L2(2)
    └── [L3](2)
-------
Answer count: 1
&lt;/pre&gt;

&lt;p&gt;需要的模組有：&lt;/p&gt;
&lt;pre class="brush: python"&gt;
from anytree import Node, RenderTree
from anytree.search import findall
from itertools import permutations
from typing import Tuple
&lt;/pre&gt;

&lt;p&gt;接著是印出上面樹狀結構的函式，anytree 的 RenderTree 搜尋函式會朝下列出節點的階級字元。&lt;/p&gt;
&lt;p&gt;這邊用 &lt;code&gt;noname&lt;/code&gt; 這個 bool 變數決定是否顯示名稱。&lt;/p&gt;
&lt;pre class="brush: python"&gt;
show_tree = lambda root: '\n'.join("{}{}({})".format(pre, n.name, n.limit) for pre, fill, n in RenderTree(root))
&lt;/pre&gt;

&lt;p&gt;接下來是主函式，稱為 &lt;code&gt;make_link&lt;/code&gt;，接收內含 int 的可迭代物件。&lt;/p&gt;
&lt;pre class="brush: python"&gt;
def make_link(iter: Tuple[int,]):
    ...
    return answer
&lt;/pre&gt;

&lt;p&gt;第一部分是創出連桿的數量，數字則是接頭數。&lt;/p&gt;
&lt;pre class="brush: python"&gt;
link_type = []
  for i, num in enumerate(iter):
    i += 2
    for j in range(num):
        link_type.append(i)
&lt;/pre&gt;

&lt;p&gt;如輸入 &lt;code&gt;(4,)&lt;/code&gt;，可以得到 &lt;code&gt;[2, 2, 2, 2]&lt;/code&gt;；輸入 &lt;code&gt;(5, 4)&lt;/code&gt; 可得 &lt;code&gt;[2, 2, 2, 2, 2, 3, 3, 3, 3]&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;使用 Python 迭代工具模組的 &lt;a href="https://docs.python.org/3/library/itertools.html#itertools.permutations"&gt;permutations&lt;/a&gt; 函式來創造排列組合的迴圈。&lt;/p&gt;
&lt;p&gt;相符無誤的項目會將 root 節點加入答案，有錯誤則用 continue 關鍵字跳過。&lt;/p&gt;
&lt;pre class="brush: python"&gt;
answer = []
for all_link in list(set(permutations(link_type))):
  ...
  answer.append(links[0])
&lt;/pre&gt;

&lt;p&gt;首先轉換 &lt;code&gt;link_type&lt;/code&gt; 的內容成為 anytree 模組的 Node 類型。&lt;/p&gt;
&lt;p&gt;其中 &lt;code&gt;limit&lt;/code&gt; 屬性是此節點的接頭上限，僅用於比對，並無程式上的限制。&lt;/p&gt;
&lt;pre class="brush: python"&gt;
all_link = [Node("L{}".format(i), limit=v) for i, v in enumerate(all_link)]
&lt;/pre&gt;

&lt;p&gt;接著將第一項當作 root 節點，加入 &lt;code&gt;links&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;這裡 &lt;code&gt;links&lt;/code&gt; 清單的最後一項 &lt;code&gt;links[-1]&lt;/code&gt; 是接下來的搜索法準備填入的項目。&lt;/p&gt;
&lt;pre class="brush: python"&gt;
links = []
links.append(all_link.pop(0))
&lt;/pre&gt;

&lt;p&gt;然後使用廣度優先搜索法 (Breadth-First-Search, BFS) 填入所有節點，使用 list 類型的 pop 方法配上 while 迴圈可以確保用光所有節點。&lt;/p&gt;
&lt;p&gt;當指派一個節點的 &lt;code&gt;parent&lt;/code&gt; 屬性時，anytree 模組會自動將節點連上父節點，父節點可以透過 &lt;code&gt;children&lt;/code&gt; 屬性取得一個裝有所有子節點指標的 tuple 物件。&lt;/p&gt;
&lt;pre class="brush: python"&gt;
while all_link:
    link = all_link.pop(0)
    if (len(links[-1].children) + bool(links[-1].parent))==links[-1].limit:
        links.append(links[-1].children[0])
    link.parent = links[-1]
&lt;/pre&gt;

&lt;p&gt;由於數學定義的「樹 (tree)」結構中，子節點只能擁有一個父項，否則為迴路 (Loop)，anytree 模組會在連接成迴路時自動回擲 &lt;code&gt;LoopError&lt;/code&gt; 錯誤。&lt;/p&gt;
&lt;p&gt;但是我們的運動鍊為 close chain，因此必須再創立一個配對流程，這次使用類似連結的概念，同時為「主體」連結一個虛擬節點。&lt;/p&gt;
&lt;p&gt;虛擬節點的樣式使用中括弧 &lt;code&gt;[ ]&lt;/code&gt; 辨識，不用指派名稱。&lt;/p&gt;
&lt;p&gt;創立 &lt;code&gt;get_no_done&lt;/code&gt; 函式回傳使用 anytree 的 findall 模組過濾沒配對完成的節點。&lt;/p&gt;
&lt;pre class="brush: python"&gt;
get_no_done = lambda: findall(links[0], filter_=lambda n: '[' not in n.name and (len(n.children) + bool(links[-1].parent)) &lt; n.limit)
error = False
while get_no_done():
    nodes = get_no_done()
    try:
        l_1, l_2 = nodes[0], nodes[1]
    except (ValueError, IndexError):
        error = True
        break
    else:
        Node("[{}]".format(l_1.name), limit=str(l_1.limit), parent=l_2)
        Node("[{}]".format(l_2.name), limit=str(l_2.limit), parent=l_1)
&lt;/pre&gt;

&lt;p&gt;最後檢查是否在上述迴圈出現沒閉合狀況。&lt;/p&gt;
&lt;pre class="brush: python"&gt;
if error:
    continue
&lt;/pre&gt;

&lt;p&gt;或是兩對連桿之間有連到一個以上的接頭。&lt;/p&gt;
&lt;pre class="brush: python"&gt;
if findall(links[0], filter_=lambda n: len([c.name for c in n.children])!=len(set(c.name for c in n.children))):
    continue
&lt;/pre&gt;

&lt;p&gt;最後可以進行測試：&lt;/p&gt;
&lt;pre class="brush: python"&gt;
if __name__=='__main__':
    print("Topologic test")
    answer = topo([5, 4])
    #Show tree
    for root in answer:
        print(show_tree(root))
        print('-'*7)
    print("Answer count: {}".format(len(answer)))
&lt;/pre&gt;

&lt;p&gt;可得：&lt;/p&gt;
&lt;pre&gt;
...
-------
L0(2)
├── L1(3)
│   ├── L3(2)
│   │   └── L5(3)
│   │       ├── L6(3)
│   │       │   ├── L8(3)
│   │       │   │   ├── [L6](3)
│   │       │   │   └── [L7](2)
│   │       │   └── [L8](3)
│   │       └── L7(2)
│   │           └── [L8](3)
│   └── L4(2)
│       └── [L2](2)
└── L2(2)
    └── [L4](2)
-------
Answer count: 60
&lt;/pre&gt;

&lt;p&gt;經驗證，所有接頭都有連接。&lt;/p&gt;</content><category term="development"></category></entry><entry><title>Pyslvs v0.9 - 12/03</title><link href="https://pyslvs.github.io/blog/yuan_2017-12-03.html" rel="alternate"></link><published>2017-12-03T21:00:00+08:00</published><updated>2017-12-03T21:00:00+08:00</updated><author><name>Yuan Chang</name></author><id>tag:pyslvs.github.io,2017-12-03:/blog/yuan_2017-12-03.html</id><summary type="html">&lt;ul&gt;
&lt;li&gt;PMKS 轉換式更新&lt;/li&gt;
&lt;li&gt;機構範例&lt;/li&gt;
&lt;/ul&gt;
</summary><content type="html">&lt;ul&gt;
&lt;li&gt;PMKS 轉換式更新&lt;/li&gt;
&lt;li&gt;機構範例&lt;/li&gt;
&lt;/ul&gt;


&lt;h1&gt;PMKS 轉換式更新&lt;/h1&gt;
&lt;p&gt;完成滑動接頭 P 與 RP 的轉換式，已經可以支援這兩種接頭的輸入。&lt;/p&gt;
&lt;p&gt;另外改進了三點共線和共點在 Solvespace 輸入的錯誤。&lt;/p&gt;
&lt;h1&gt;機構範例&lt;/h1&gt;
&lt;p&gt;增加了兩個範例，用作測試上述程式。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;曲柄滑塊&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/pyslvs/17_12_03_01.png"&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;雙臂接球機構&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/pyslvs/17_12_03_02.png"&gt;&lt;/p&gt;</content><category term="development"></category></entry><entry><title>Pyslvs v0.9 - 11/28</title><link href="https://pyslvs.github.io/blog/yuan_2017-11-28.html" rel="alternate"></link><published>2017-11-28T21:00:00+08:00</published><updated>2017-11-28T21:00:00+08:00</updated><author><name>Yuan Chang</name></author><id>tag:pyslvs.github.io,2017-11-28:/blog/yuan_2017-11-28.html</id><summary type="html">&lt;ul&gt;
&lt;li&gt;介面操作重大更新&lt;/li&gt;
&lt;/ul&gt;
</summary><content type="html">&lt;ul&gt;
&lt;li&gt;介面操作重大更新&lt;/li&gt;
&lt;/ul&gt;


&lt;h1&gt;介面操作重大更新&lt;/h1&gt;
&lt;p&gt;今天改寫了一下畫布介面。&lt;/p&gt;
&lt;p&gt;將拍照到剪貼簿的按鈕移到右上角的版本標籤旁；表格頁籤旁改成「全部選擇」按鈕。&lt;/p&gt;
&lt;p&gt;新增兩個功能的快捷鍵：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;全選點 (Select all point)：Ctrl + A&lt;/li&gt;
&lt;li&gt;自由移動模式切換 (Free move mode toggle)：Ctrl + F&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;另外有一個重大突破：矩形窗選功能。&lt;/p&gt;
&lt;p&gt;在非自由移動模式下可靠滑鼠拖拉矩形線框，選取畫布上的點。&lt;/p&gt;
&lt;p&gt;自由移動模式下拖拉將會移動並修改選擇的點座標。&lt;/p&gt;
&lt;iframe width="854" height="480" src="https://www.youtube.com/embed/-pdUPiUBOfA" frameborder="0" gesture="media" allow="encrypted-media" allowfullscreen&gt;&lt;/iframe&gt;</content><category term="development"></category></entry></feed>