---
Title: Python 類型註解
Date: 2018-11-19 19:00
Category: 學習
Tags: learn Python
Slug: yuan_2018-11-19-3
Author: Yuan Chang
---

基於協同開發，Python 引入了選擇性的類型註解。

建議先瞭解：

+ **物件導向概念**
+ **簽章**
+ 自行閱讀 Python 的**撰寫風格規定 [PEP 8](https://www.python.org/dev/peps/pep-0008/)**

學員可以藉由類型註解，在程式碼協同時較快辨認變數類型。

<!-- PELICAN_END_SUMMARY -->

類型註解
---

類型註解 (Typing) 是一種**註解**，可以為每種參數進行標示。由於文法問題，類型註解並不是強迫性的，不過仍有效用。可藉由每個範圍 (Scope) 的 `__annotations__` 名稱取得，若有工具或 IDE 的功能，可以進行靜態分析。

根據 [PEP 484](https://www.python.org/dev/peps/pep-0484/) 的內容，類型註解物件可以自行製作和定義，但是本節只會將常用容器列出。

### 基本文法

Python 為**弱型別** (Weak typing) 語言，又稱**鴨子型別** (Duck type)，相較於**強型別** (Strong typing) 語言，只要**變數能用**即可，不能用就引發錯誤。當然這只能在相對安全的直譯式語言 (Interpreted language) 中，因為這裡只要使用 `try` 語句即可：

```python
try:
    # 測試 a 能不能執行 test_method。
    b = a.test_method()
except AttributeError:
    # 沒有 test_method。
    c = 20
else:
    c = b * 2
```

但是因為執行效能與開發效率問題，一直測試顯然不是好方法，因此 Python 在簽章上引入了類型註解的文法。

簽章的參數中，使用 `:` 符號後連接類型名稱；回傳值則是使用 `->` 記號連接。參照於一般英文符號以及**運算子必須由空白環繞**的規定，`:` 符號會連接前一個表示式，與下一個表示式間隔空白；`->` 記號則是必須由空白環繞。

```python
# 只能從預設值或參數名稱猜測。
def func(p0, p1=20, p2=True):
    pass

# 直接規定型別。
def func(p0: int, p1: int = 20, p2: bool = True) -> None:
    pass

# 若是太長可以利用括弧換行。
def func(
    number: int,
    size: int = 20,
    reverse: bool = True
) -> None:
    pass
```

在 Python 3.6 新增單一變數的類型註解文法 ([PEP 526](https://www.python.org/dev/peps/pep-0526/))。

不過一般可直接辨識的變數就不會使用，例如直接賦予類型的初始化物件。

```python
# 等等會裝入整數。
a: List[int] = []
# 這麼明顯就不用了。
a: MyClass = MyClass()
```

Python 的類型註解一般也是用**鴨子型別**的概念標示，提醒開發者「需要這樣使用」，而非「一定需要這種類型」。如：

```python
def func(w) -> bool:
    """w 是一個會進行疊代與檢索的物件。"""
    for i in range(20):
        for k in w:
            if w[i + 2] == 'z':
                return True

# 應該標示成序列：
w: Secquence[int]
# 而非強迫成某種型態：
w: List[int]
w: Tuple[int, ...]
```

### 容器

自 Python 3.5 起支援，型別中支援**放入**或**回傳**的型別必須由標準模組 `typing` 提供。容器的類型註解名稱會跟一般容器名稱不一樣，改成字首大寫。

通常排列習慣將相同性質的容器一起擺放。

```python
from typing import (
    # 序列
    Tuple,
    List,
    Secquence,
    # 二元搜尋樹
    Set,
    Dict,
    # 迭代器（產出）
    Iterator,
    # 生產器（接收、產出）
    Generator,
    # 可呼叫物（函式）
    Callable,
    # 邏輯判斷
    Optional,
    Union,
    Any,
)
```

使用單一項目的容器：

```python
# 其實 tuple 容器是固定長度的。
my_tuple: Tuple[int, int] = (20, 20)
# 不限長度的容器。
my_list: List[float] = [20., 50.02, -3.006]
# 不限長度的 tuple 容器（其他變數決定）。
my_tuple: Tuple[int, ...] = tuple(i for i in range(s))
# 巢狀標示。
w: Set[Tuple[int, int]] = {(10, 20), (30, 40), (50, 60)}
```

使用成對項目的容器：

```python
d: Dict[str, List[int]] = {
    's': [10, 20, 30],
    'b': [],
    'f': [77, 66, 55, 44],
}
```
