var tipuesearch = {"pages": [{'title': '簡介', 'text': 'Pyslvs  是一套利用 Python 3 與 PyQt5 建立的平面機構模擬與合成系統.\xa0 機構模擬與合成的主要核心包括\xa0 Python-Solvespace \xa0幾何約束求解程式庫、 tinycadlib  三角幾何函式程式庫、 ADesign  演算程式庫、 bgfs  幾何約束求解程式庫、 topologic \xa0類型合成程式庫、 number  數目合成程式庫等. 其中,  ADesign  演算程式庫包含 Real-coded Genetic Algorithm ( RGA )、Differential Evolution ( DE ) 與 Firefly Algorithm ( Firefly ) 等三種, 用於平面機構尺寸合成演算. 源起 Pyslvs  的開發源自 2008 年, 從最基本的實數基因演算法在平面機構的應用研究起步, 期間歷經下列研究者的貢獻: \n 李孟恭, 2015,  Django 網際框架在平面四連桿尺寸合成系統上的應用 \n 李玠廷, 2013,  網際程式框架在平面連桿機構尺寸合成系統上的應用 \n 陳威任, 2013, 符號式平面滑塊機構應用研究 \n 謝政良, 2012,  網際雙自由度凸輪機構尺寸合成系統 \n 黃竣鉉, 2012,  網際符號輔助軸接連桿機構之基因演算法尺寸合成系統 \n 謝智翔, 2012,  網際史都華平台機構逆運動學分析與模擬 \n 許哲菘, 2010,  網際六軸機械臂系統的逆運動學分析與模擬 \n 葉岱錦, 2009,  基因演算法在網際機構合成系統上的應用 \n 過程中, 於 2015 年由 李孟恭 整合上述論文所開發的三種演算法, 完成  Cython  格式的  RGA 、 DE  與  Firefly  演算法程式庫後. 並自 2016 年起由 張元 將上述尺寸合成演算法, 搭配利用\xa0  SWIG  技術, 將原本只能用於 Python 2 的  Python-Solvespace  倉儲, 改寫為能結合 PyQt5 圖形介面使用的  Python-Solvespace  程式庫作為另一項開端. 再搭配平面機構中的數目合成與類型合成等程式庫後, 成為目前的  Pyslvs  平面機構模擬與合成套件. Pyslvs 開發紀要 2015 年 4 月 - 由 李孟恭 以  Cython  技術, 完成三個 尺寸合成演算法 程式庫. 2016 年 7 月 - 由 張元 完成 Python 3 格式的  Python-Solvespace  程式庫. 2016 年 12 月- 由 張元 結合 PyQt5 與演算程式庫, 完成第一代  Pyslvs  套件. 2017 年 11 月 -  http://pyslvs.com \xa0上線. 2018 年 1 月 - 推出  Pyslvs  18.01\xa0 版, 自此改為以年月序作為版次. 2018 年 7 月 -\xa0 http://pyslvs.com/content/ \xa0使用手冊上線.', 'tags': '', 'url': '簡介.html'}, {'title': '機構與機器', 'text': '機構 (Mechanism) 機構是由剛體 (Rigid) 或撓性 (Flexible) 體機械元件所組成, 這些元件透過接頭 (Joint) 連接, 並以特定的運動相互移動. 機器 (Machine) 機器是由機構或機構的集合所組成, 能將力從動力源傳遞到預計要施加之元件上. 換言之, 機器是由剛性元件或撓性元件所組合而成,\xa0能將力從動力源傳遞到預計要施加之元件上. 機器具有兩個功能: 傳遞確定的相對運動和傳遞力.\xa0 這些功能需要足夠強度與剛性來傳遞力. 若機構中所有的機件皆為連桿, 且所有的接頭皆為旋轉對, 則這個機構特稱為連 (Linkage). 參考資料: Comparison of Methodologies for Conceptual Design of Mechanisms.pdf Design and Optimization of Slider and Crank Mechanism with Multibody Systems.pdf Dynamic Analysis of Flexible Mechanisms by Multibody Dynamics.pdf', 'tags': '', 'url': '機構與機器.html'}, {'title': 'Pyslvs 介面', 'text': '(以  pyslvs-18.8.0.mscv1900-amd64.exe \xa0 開啟) Pyslvs 主畫面的上方為功能表列 (Menu bar), 右側為畫布 (Canvas), 左方則有各式功能的分頁欄 (Tab widgets). 功能表列涵蓋大部分的功能, 其中部分有關各項目的細部操作, 則必須在對應的分頁欄中選取或設定.\xa0 Mechanism 分頁 Pyslvs 左側中的 Mechanism 子頁面, 主要用於輸入機構關鍵點與運動連桿, 使用時以滑鼠點選 Mechanism 頁面後, 可在右方工作區, 以滑鼠輸入機構關鍵點與運動連桿. Inputs\xa0分頁 Pyslvs 的 Inputs 子頁面用於宣告機構的主動軸, 並進行運動模擬. Synthesis\xa0分頁 Pyslvs 的 Synthesis 子頁面用於進行平面機構的結構合成與尺寸合成. 功能表列 (Menu bar) 功能表列中根據不同的功能分類如下: 檔案 (File) 建立新的工作簿、開啟既有的工作簿、參考範例, 以及不同檔案格式的匯入與匯出功能. 編輯 (Edit) 復原與重做功能.\xa0 選項 (Options) 檢視方式調整以及工作簿相關資訊. 說明 (Help) 與 Pyslvs 相關網站與套件資訊. 快捷鍵 F1 - 有關 Pyslvs Shift + F1 - Toggle 全螢幕', 'tags': '', 'url': 'Pyslvs 介面.html'}, {'title': '操作', 'text': 'Pyslvs 開啟 Crank-Rocker 機構畫面, under Mechanism 頁面 (以  pyslvs-18.8.0.mscv1900-amd64.exe \xa0 開啟) : Crank-Rocker under Inputs 頁面 (以  pyslvs-18.8.0.mscv1900-amd64.exe \xa0 開啟) : Crank-Rocker 通過特定點尺寸合成畫面1 (以  pyslvs-18.8.0.mscv1900-amd64.exe \xa0 開啟) : 完成 1000 代 DE 演算法之後的結果畫面 (以  pyslvs-18.8.0.mscv1900-amd64.exe \xa0 開啟) :', 'tags': '', 'url': '操作.html'}, {'title': '模擬操作', 'text': 'Pyslvs 的模擬操作主要牽涉 Mechanism 與 Inputs 分頁, Mechanism 分頁用於定義機構各節點與連桿, 而 Inputs 分頁則可用來定義主動旋轉軸, 並利用自動或手動模式進行合理平面機構的運動模擬.', 'tags': '', 'url': '模擬操作.html'}, {'title': '曲柄滑塊', 'text': '以下說明以\xa0 pyslvs-18.8.0.mscv1900-amd64.exe \xa0 為主. File -> New Workbook 選擇左側 Mechanism 子頁面. 建立固定點與移動點 利用滑鼠在右側畫布區, 按住滑鼠右鍵輸入兩個固定點與一個可運動點. 建立連桿 將其中一個固定點轉為滑塊, 即將 point2 之類型 (type) 由 pin 轉為 pin in slot, 採內建水平滑動面, 或更改滑動面的對應角度. 在 Mechanism 完成機構定義後, 轉到 Inputs 子頁面, 定義 Driver point 後進行曲柄滑塊的運動模擬.', 'tags': '', 'url': '曲柄滑塊.html'}, {'title': '四連桿', 'text': '在 Mechanism 子頁面定義兩個固定點與兩個移動點後, 建立三根可運動連桿. 接著進入 Inputs 頁面, 定義 driver points 後進行基本運動模擬.', 'tags': '', 'url': '四連桿.html'}, {'title': '尺寸合成操作', 'text': 'Pyslvs 的尺寸合成功能, 主要依賴\xa0 tinycadlib \xa0三角幾何函式程式庫與\xa0 ADesign \xa0演算程式庫, 其中各平面機構範例進行尺寸合成的第一步必須先以三角幾何函式程式庫進行配置後, 再輸入特定機構節點所要通過的運行點座標, 最後再選擇  ADesign \xa0演算程式庫中的 Real-coded Genetic Algorithm ( RGA )、Differential Evolution ( DE ) 或 Firefly Algorithm ( Firefly ) 演算法進行尺寸合成運算.', 'tags': '', 'url': '尺寸合成操作.html'}, {'title': '構造合成操作', 'text': 'Pyslvs 的構造合成包括平面機構的數目合成與類型合成等兩部分. 在數目合成階段, 使用者可以選擇連桿個數 (Link number)、接頭個數 (Joint number), 以及機構的自由度.', 'tags': '', 'url': '構造合成操作.html'}, {'title': '下載', 'text': '利用 pyslvs At mde 登錄 Gdrive 提供各版次下載. Windows 64 位元操作系統: pyslvs-18.7.0.mscv1900-amd64.exe  (53446 KB) pyslvs-18.8.0.mscv1900-amd64.exe  (53458 KB) pyslvs-18.9.0.mscv1900-amd64.exe  (68337 KB) pyslvs-18.11.0.mscv1900-amd64.exe  (70875 KB)', 'tags': '', 'url': '下載.html'}, {'title': '範例', 'text': '展示利用 Pyslvs 解題 參考資料: 1977 -\xa0 THE KINEMATICS AND VIBRATION OF PLANAR LINKAGE MECHANISMS MeKin2d MACHINES AND MECHANISMS APPLIED KINEMATIC ANALYSIS Fourth Edition by David H. Myszka Introduction to Mechanism Design: with Computer Applications by By Eric Constans and Karl B. Dyer THEORY OF MACHINES AND MECHANISMS Fourth Edition by John Uicker, Gordon Pennock and\xa0 Joseph Shigley', 'tags': '', 'url': '範例.html'}, {'title': '模擬範例', 'text': '以下畫面以\xa0 pyslvs-18.8.0.mscv1900-amd64.exe \xa0 製作. 以下畫面以\xa0 pyslvs-18.8.0.mscv1900-amd64.exe \xa0 製作. sixbar_r_slider.pyslvs  (只適用於\xa0 pyslvs-18.8.0.mscv1900-amd64.exe \xa0版本 ) 建立六連桿機構模型 以\xa0 pyslvs-18.8.0.mscv1900-amd64.exe \xa0 製作 ) 八連桿機構 eightbar1.pyslvs \xa0(只適用於\xa0 pyslvs-18.8.0.mscv1900-amd64.exe \xa0版本 ) eightbar2.pyslvs \xa0(只適用於\xa0 pyslvs-18.8.0.mscv1900-amd64.exe \xa0版本 ) eightbar3.pyslvs \xa0(只適用於\xa0 pyslvs-18.8.0.mscv1900-amd64.exe \xa0版本 ) 十連桿機構 tenbar_linkage.pyslvs \xa0(只適用於\xa0 pyslvs-18.8.0.mscv1900-amd64.exe \xa0版本 )', 'tags': '', 'url': '模擬範例.html'}, {'title': '尺寸合成範例', 'text': '', 'tags': '', 'url': '尺寸合成範例.html'}, {'title': '結構合成範例', 'text': '', 'tags': '', 'url': '結構合成範例.html'}, {'title': '產品設計範例', 'text': '健步機 連桿式健步機設計.pdf sixbar_foot_exercise_machine.pyslvs \xa0(只適用於\xa0 pyslvs-18.8.0.mscv1900-amd64.exe \xa0版本 ) 汽車雨刷 windshield_design1.pyslvs \xa0(只適用於\xa0 pyslvs-18.8.0.mscv1900-amd64.exe \xa0版本 ) 汽車引擎蓋 automobile_hood1.pyslvs \xa0(只適用於\xa0 pyslvs-18.8.0.mscv1900-amd64.exe \xa0版本 ) 平開窗戶開合機構 house_window.pyslvs \xa0(只適用於\xa0 pyslvs-18.8.0.mscv1900-amd64.exe \xa0版本 )', 'tags': '', 'url': '產品設計範例.html'}, {'title': '開發', 'text': '取得 Pyslvs 原始碼: git clone --recurse-submodules https://github.com/KmolYuan/Pyslvs-PyQt5 本倉儲有兩個主要分支：master 分支為當前穩定版本；dev 分支為開發中版本。每當切換分支時，請注意子倉儲的版次是否有變動，使用以下指令更新： git submodule update --recursive 若有更新，必須重新編譯核心。 位於 pyslvs 目錄中的 unittest 程式: # -*- coding: utf-8 -*-\n\n"""This module will test the functions of Pyslvs."""\n\n__author__ = "Yuan Chang"\n__copyright__ = "Copyright (C) 2016-2018"\n__license__ = "AGPL"\n__email__ = "pyslvs@gmail.com"\n\nimport unittest\nfrom unittest import TestCase\nfrom typing import Tuple, List\n\n#For necessary testing modules.\nfrom math import sqrt, radians, isclose\nfrom pmks import VPoint\nimport bfgs\nfrom tinycadlib import (\n    Coordinate,\n    PLAP,\n    PLLP,\n    PLPP,\n    PXY,\n    expr_solving,\n    data_collecting,\n)\nfrom planarlinkage import Planar\nfrom rga import Genetic\nfrom firefly import Firefly\nfrom de import DiffertialEvolution\nfrom number import number_synthesis\nfrom topologic import topo, Graph\nfrom triangulation import vpoints_configure\nfrom _parser import parse_vpoints\nfrom examples import example_list\n\n\nclass CoreTest(TestCase):\n    \n    """Testing Cython libs."""\n    \n    def vpoints_object(self) -> Tuple[List[VPoint], Tuple[Tuple[int, int]]]:\n        """Example: Jansen\'s linkage (Single)."""\n        expr, inputs = example_list["Jansen\'s linkage (Single)"]\n        return parse_vpoints(expr), inputs\n    \n    def planar_object(self) -> Planar:\n        """Test-used mechanism for algorithm."""\n        return Planar({\n            \'Driver\': {\'P0\': (-70, -70, 50)},\n            \'Follower\': {\'P1\': (70, -70, 50)},\n            \'Target\': {\'P4\': [\n                (60.3, 118.12),\n                (31.02, 115.62),\n                (3.52, 110.62),\n                (-25.77, 104.91),\n                (-81.49, 69.19),\n                (-96.47, 54.906),\n                (-109.34, 35.98),\n                (-121.84, 13.83),\n                (-127.56, -20.09),\n                (-128.63, -49.74),\n                (-117.56, -65.45),\n            ]},\n            \'Expression\': "PLAP[P0,L0,a0](P2);" +\n                "PLLP[P2,L1,L2,P1](P3);" +\n                "PLLP[P2,L3,L4,P3](P4)",\n            \'constraint\': [(\'P0\', \'P1\', \'P2\', \'P3\')],\n            \'upper\': [100., 100., 100., 100., 100., 360.],\n            \'lower\': [5., 5., 5., 5., 5., 0.],\n        })\n    \n    def test_plap(self):\n        """Test for PLAP function."""\n        A = Coordinate(0, 0)\n        B = Coordinate(50, 0)\n        x, y = PLAP(A, 50 * sqrt(2), radians(45), B)\n        self.assertTrue(isclose(x, 50))\n        self.assertTrue(isclose(y, 50))\n    \n    def test_pllp(self):\n        """Test for PLLP function."""\n        A = Coordinate(-30, 0)\n        B = Coordinate(30, 0)\n        x, y = PLLP(A, 50, 50, B)\n        self.assertTrue(isclose(x, 0))\n        self.assertTrue(isclose(y, 40))\n        x, y = PLLP(A, 30, 30, B)\n        self.assertTrue(isclose(x, 0))\n        self.assertTrue(isclose(y, 0))\n        x, y = PLLP(A, 90, 30, B)\n        self.assertTrue(isclose(x, 60))\n        self.assertTrue(isclose(y, 0))\n    \n    def test_plpp(self):\n        """Test for PLPP function."""\n        A = Coordinate(0, 0)\n        B = Coordinate(0, -3)\n        C = Coordinate(3/2, 0)\n        x, y = PLPP(A, sqrt(5), B, C)\n        self.assertTrue(isclose(x, 2))\n        self.assertTrue(isclose(y, 1))\n    \n    def test_pxy(self):\n        A = Coordinate(80, 90)\n        x, y = PXY(A, 40, -20)\n        self.assertTrue(isclose(x, 120))\n        self.assertTrue(isclose(y, 70))\n    \n    def test_topologic(self):\n        """Testing \'topologic\' libraries.\n        \n        + \'topo\' function.\n        + \'Graph\' class.\n        """\n        G = Graph([(0, 1), (0, 4), (1, 5), (2, 3), (2, 4), (3, 5), (4, 5)])\n        H = Graph([(0, 2), (0, 4), (1, 3), (1, 4), (2, 5), (3, 5), (4, 5)])\n        I = Graph([(0, 1), (0, 2), (1, 4), (2, 5), (3, 4), (3, 5), (4, 5)])\n        self.assertTrue(G.is_isomorphic(H))\n        self.assertFalse(G.is_isomorphic(I))\n        answer, time = topo([4, 2], degenerate=True)\n        self.assertEqual(len(answer), 2)\n    \n    def test_solving(self):\n        """Test triangular formula solving.\n        \n        + Test for PMKS parser.\n        + Test data collecting function.\n        + Test expression solving function.\n        """\n        vpoints, inputs = self.vpoints_object()\n        self.assertTrue(len(vpoints) == 8)\n        exprs = vpoints_configure(vpoints, inputs)\n        mapping = {n: \'P{}\'.format(n) for n in range(len(vpoints))}\n        data_dict, dof = data_collecting(exprs, mapping, vpoints)\n        for link, link_length in (\n            (\'L0\', 15.002083188677497),\n            (\'L1\', 41.50187586121861),\n            (\'L2\', 49.9949057404852),\n            (\'L3\', 40.09650982317538),\n            (\'L4\', 55.80253220060896),\n            (\'L5\', 61.90525179659639),\n            (\'L6\', 39.302800154696364),\n            (\'L7\', 36.69767567571548),\n            (\'L8\', 39.395233214184685),\n            (\'L9\', 48.995886562037015),\n            (\'L10\', 65.69940106271898),\n        ):\n            self.assertTrue(isclose(data_dict[link], link_length))\n        self.assertEqual(dof, 1)\n        result = expr_solving(exprs, mapping, vpoints, [0.])\n        x, y = result[-1]\n        self.assertTrue(isclose(x, -43.17005515543241))\n        self.assertTrue(isclose(y, -91.75322590542523))\n    \n    def test_bfgs(self):\n        """Test Sketch Solve kernel."""\n        input_data, output_data, grad_data = bfgs.test_kernel()\n        self.assertEqual(input_data[0], (0.0, 0.0))\n        self.assertEqual(input_data[1], (5.0, 0.0))\n        self.assertEqual(input_data[2], (6.0, 5.0))\n        self.assertEqual(input_data[3], (6.0, 5.0))\n        self.assertEqual(input_data[4], (30.0, 10.0))\n        self.assertTrue(isclose(round(output_data[2][1], 2), 10))\n        self.assertTrue(isclose(round(output_data[4][0], 2), 30))\n        vpoints, inputs = self.vpoints_object()\n        result = bfgs.vpoint_solving(vpoints, [(0, 1, 0.)])\n        x, y = result[-1]\n        self.assertTrue(isclose(round(x, 2), -43.17))\n        self.assertTrue(isclose(round(y, 2), -91.75))\n    \n    def test_number_synthesis(self):\n        """Test Number Synthesis function."""\n        for NL, NJ in [(4, 4), (6, 7), (8, 9), (10, 12)]:\n            for factors in number_synthesis(NL, NJ):\n                count = 0\n                for i, factor in enumerate(factors):\n                    count += factor * (i + 2)\n                self.assertEqual(int(count / 2), NJ)\n    \n    def test_algorithm_rga(self):\n        """Real-coded genetic algorithm."""\n        fun1 = Genetic(self.planar_object(), {\n            \'maxTime\': 1, \'report\': 10,\n            #Genetic\n            \'nPop\': 500,\n            \'pCross\': 0.95,\n            \'pMute\': 0.05,\n            \'pWin\': 0.95,\n            \'bDelta\': 5.,\n        })\n        fun1.run()\n    \n    def test_algorithm_firefly(self):\n        """Firefly algorithm."""\n        fun2 = Firefly(self.planar_object(), {\n            \'maxTime\': 1, \'report\': 10,\n            #Firefly\n            \'n\': 80,\n            \'alpha\': 0.01,\n            \'betaMin\': 0.2,\n            \'gamma\': 1.,\n            \'beta0\': 1.,\n        })\n        fun2.run()\n    \n    def test_algorithm_de(self):\n        """Differtial evolution."""\n        fun3 = DiffertialEvolution(self.planar_object(), {\n            \'maxTime\': 1, \'report\': 10,\n            #DE\n            \'strategy\': 1,\n            \'NP\': 400,\n            \'F\': 0.6,\n            \'CR\': 0.9,\n        })\n        fun3.run()\n\n\nif __name__ == \'__main__\':\n    unittest.main()\n 以 Eric6 IDE 開啟 Pyslvs 專案:', 'tags': '', 'url': '開發.html'}, {'title': 'Windows 開發', 'text': '下載  Qt 可攜程式開發套件.7z  （下載檔案約 8GB, 解開壓縮後約 21GB）或使用 Python 3.7.0 與 Msys2\xa0 製作的  p37_adv （下載檔案約 5.3 GB, 解開壓縮約 14 GB）執行 start.bat。 其中所需要的套件已安裝在可攜程式當中，可參考模組需求清單 requirements.txt。 若要完成獨立可執行檔案的發布，必須另外安裝  PyInstaller  模組： python -m pip install pyinstaller 編譯 GUI 套件: 進入 Pyslvs-PyQt5 目錄後, 執行: mingw32-make 完成後, 以 2018.09 版次為例, dist 目錄中將得到可執行檔案: pyslvs-18.9.0.mscv1900-amd64.exe 編譯程式庫: 在命令列中更換目錄至 core\\libs\\pyslvs 後, 執行: mingw32-make 建立下列動態連結程式庫 (pyd): bfgs.cp36-win_amd64.pyd\nde.cp36-win_amd64.pyd\nfirefly.cp36-win_amd64.pyd\nnumber.cp36-win_amd64.pyd\nplanarlinkage.cp36-win_amd64.pyd\npmks.cp36-win_amd64.pyd\nrga.cp36-win_amd64.pyd\ntinycadlib.cp36-win_amd64.pyd\ntopologic.cp36-win_amd64.pyd\ntriangulation.cp36-win_amd64.pyd\nverify.cp36-win_amd64.pyd', 'tags': '', 'url': 'Windows 開發.html'}, {'title': '環境修正', 'text': '從  p37  標準版升級能夠以  Msys2  編譯 Pyslvs-PyQt5 pip install pyqtchart lark-parser networkx ezdxf peewee openpyxl psutil pyinstaller cffi pyyaml cygwinccompiler.py 修改 套用編譯器設定的補釘，其位於 Pyslvs 專案的 platform 目錄中。 patch p37\\lib\\distutils\\cygwinccompiler.py platform\\patch.diff patch.diff 內容： --- cygwinccompiler.py\n+++ cygwinccompiler.py\n@@ -82,7 +82,21 @@ def get_msvcr():\n         elif msc_ver == \'1600\':\n             # VS2010 / MSVC 10.0\n             return [\'msvcr100\']\n+        elif msc_ver == \'1700\':\n+            # Visual Studio 2012 / Visual C++ 11.0\n+            return [\'msvcr110\']\n+        elif msc_ver == \'1800\':\n+            # Visual Studio 2013 / Visual C++ 12.0\n+            return [\'msvcr120\']\n+        elif msc_ver == \'1900\':\n+            # Visual Studio 2015 / Visual C++ 14.0\n+            # "msvcr140.dll no longer exists" http://blogs.msdn.com/b/vcblog/archive/2014/06/03/visual-studio-14-ctp.aspx\n+            return [\'vcruntime140\']\n+        elif msc_ver == \'1910\':\n+            return [\'vcruntime140\']\n+        elif msc_ver == \'1914\':\n+            return [\'vcruntime140\']\n         else:\n             raise ValueError("Unknown MS Compiler version %s " % msc_ver)\n 增加\xa0distutils.cfg 檔案 在 p37\\Lib\\distutils 目錄中新增 distutils.cfg echo [build]>> p37\\Lib\\distutils\\distutils.cfg\necho compiler = mingw32>> p37\\Lib\\distutils\\distutils.cfg 修改\xa0_advapi32.py 檔案 修改 p37\\Lib\\site-packages\\win32ctypes\\core\\cffi\\_advapi32.py 蓋掉第 197 與 199 行 #c_creds.CredentialBlobSize = \\\n\n    #ffi.sizeof(blob_data) - ffi.sizeof(\'wchar_t\')', 'tags': '', 'url': '環境修正.html'}, {'title': 'PyInstaller 對 Windows 的支援', 'text': '官方說明： https://pyinstaller.readthedocs.io/en/stable/man/pyi-makespec.html#windows-and-mac-os-x-specific-options \n 預設包裝時採用不關閉主控台選項（不使用 -w），目的是顯示 Pyslvs 的版本資訊，關閉後將會無法使用 --help 或 --version 等不啟動 GUI 的顯示功能。 \n 在 Windows 中必須手動加入除了端口程式庫 pyd 以外的相依外部程式庫，如 SWIG 與 PyQt sip 的隱式導入。 \n 在 Windows 中的圖示格式為 ico。 \n', 'tags': '', 'url': 'PyInstaller 對 Windows 的支援.html'}, {'title': 'Ubuntu 開發', 'text': '安裝 python3-dev 與 swig 套件： sudo apt update\nsudo apt install python3-dev swig 取得 Pyslvs 原始碼： git clone --recurse-submodules https://github.com/KmolYuan/Pyslvs-PyQt5 安裝需要的 Python 模組： sudo pip3 install -r requirements.txt 完整編譯： make 可以在倉儲目錄下的 out 資料夾中取得 AppImage 可執行檔（詳見下一節說明）。 編譯核心： # 所有程式庫\nmake build-kernel\n\n# Pyslvs 程式庫\nmake build-pyslvs\n\n# Python-Solvespace 程式庫\nmake build-solvespace 執行腳本： python3 launch_pyslvs.py', 'tags': '', 'url': 'Ubuntu 開發.html'}, {'title': 'AppImage 包裝', 'text': '官方網站： https://appimage.org/ 在不同的 Linux 作業系統下有著不一樣的程式庫版本，由於程式之間的「相依性」十分高，會造成程式編譯後無法移植到其他環境中使用，即使編譯端與客戶端的作業系統是一樣的。 AppImage 的目標是將編譯端的程式可以編一到任何「目標作業系統」都可以執行。而「目標作業系統」必須符合對應的環境需求（相依程式庫版本必須滿足）。最差的情況是必須「完全符合或較新」；最完美的情況甚至是「不用安裝」。 使用的原理是 App Dir 壓縮包配上腳本檔案，執行時會解壓縮到帳戶的 /tmp 目錄（並且會附加 Hash code），而此一壓縮包會包含所有程式所需要的相依程式庫或套件。 AppImage releases 標榜「不使用 sudo」、「選擇性安裝」以及支援版本升級功能。 包裝的建立是透過 bash 腳本使用 AppImage tool kits，支援基本的自動「程式與程式庫相依性分析」的功能。不過在過度「客製化」的開發環境下，開發者必須手動將所需的檔案複製到 App Dir 中。 Pyslvs 的包裝流程是透過 appimage_recipe.sh 腳本完成。使用的工具為 virtualenv，依照開發環境的安裝模式建立 App Dir，並安裝 Pyslvs 所需的模組，並經由手動複製一些 built-in scripts 之後，打造出完全獨立的 Python 執行環境。Pyslvs 便可在完全無 Python 3 的環境中執行（不過仍有 glib 的最低版本需求）。 \n App Dir 位置：ENV/ \n 包裝輸出位置：out/ \n', 'tags': '', 'url': 'AppImage 包裝.html'}, {'title': 'Mac OS X 開發', 'text': 'Mac OS X 上的任何程式開發都不建議使用 sudo 指令（除非必要），也不要使用內建的 Python 以免系統故障。建議使用  Homebrew  或是  MacPort  套件管理工具。 必須注意的是，平台上的編譯工具僅支援向下相容，較新的 xcode 版本無法在舊版運行。 安裝 Python 與 SWIG： # Homebrew 的 Python 版本永遠是最新的穩定板\nbrew install python@3\nbrew install swig\n\n# MacPort 可支援任意 Python 版本\n# 安裝在 /opt 必須使用 sudo 指令\nyes | sudo part install python36\nyes | sudo port install py$PYTHON-pip\nsudo port select --set python3 python36\nsudo port select --set pip pip36 使用 MacPort 的 pip3 安裝時請加上 --user 免去 sudo 操作。 取得 Pyslvs 原始碼： git clone --recurse-submodules https://github.com/KmolYuan/Pyslvs-PyQt5 安裝需要的 Python 模組： pip3 install -r requirements.txt 安裝 PyInstaller 模組打包成執行檔： pip3 install pyinstaller 完整編譯： make 可以在倉儲目錄下的 dist 資料夾中取得 app 與 unix-style 可執行檔。 編譯核心： # 所有程式庫\nmake build-kernel\n \n# Pyslvs 程式庫\nmake build-pyslvs\n \n# Python-Solvespace 程式庫\nmake build-solvespace 執行腳本： python3 launch_pyslvs.py', 'tags': '', 'url': 'Mac OS X 開發.html'}, {'title': 'PyInstaller 對 Mac OS X 的支援', 'text': '官方說明： https://pyinstaller.readthedocs.io/en/stable/man/pyi-makespec.html#windows-and-mac-os-x-specific-options \n 預設包裝時採用關閉主控台的選項（使用 -w），目的是為了產生標準 .app 格式的可執行檔，而非只有類 Unix 執行檔。啟用此選項後，會包裝出上述兩種格式的執行檔。 \n 在 Mac OS X 中，對 .app 格式的可執行檔作網路傳輸時必須微壓縮成 .zip 檔案。 \n 在 Mac OS X 中可以自動定位 SWIG 與 PyQt 等擁有外部程式庫的模組。 \n 在 Mac OS X 中的圖示格式為 icns。 \n', 'tags': '', 'url': 'PyInstaller 對 Mac OS X 的支援.html'}, {'title': '參與協同', 'text': '若要參與 Pyslvs 的開發，基本編寫風格遵循  PEP 8 ，主要規則請參閱子章節的資訊。', 'tags': '', 'url': '參與協同.html'}, {'title': '註解規則', 'text': '所有 Modules、Classes 與 Functions 都應該加上 doc string，一般 Methods 應比照 Functions，而 __init__ 等則視情況在程式碼中添加單行註解。 # -*- coding: utf-8 -*-\n\n"""Module doc string title\n\nModule decriptions ...\n"""\n\n\ndef function():\n    """Single line doc string."""\n    ...\n\n\nclass MyClass:\n\n    """MyClass doc string."""\n\n    def method():\n        """MyClass.method doc string."""\n        ... 使用單行註解多行程式碼時，為求功能明確，應在該區域使用單空行分隔。 def foo() -> List[Set[int]]:\n    """foo doc string."""\n    a = 10\n    b = 20\n\n    # Let a plus b, and assign to c.\n    c = a + b\n\n    # Do another things ...\n    d = func_c2d(c)\n    e = func_c2e(c)\n    f = func_de2f(d, e)\n\n    # Convert f.\n    return list(f)', 'tags': '', 'url': '註解規則.html'}, {'title': '命名規則', 'text': '\n Classes 使用字首大寫命名，如 RedApple。 \n 定值使用全部大寫並用底線連接，如 RED_APPLE。 \n 模組、變數等其他名稱一律使用小寫並用底線連接，如 red_apple。 \n 自用變數樣式（以表示絕對不會跨層級）：\n \n 模組層級的自用變數使用一個底線起始，如 _red_apple、_RedApple 或 _RED_APPLE。 \n Class 層級的自用變數或 Methods 使用兩個底線起始，如 __red_apple。 \n \n \n 必須複寫原始模組，如 Qt 使用小寫字首 redApple，則遵照原始模組。 \n', 'tags': '', 'url': '命名規則.html'}, {'title': '類型註解', 'text': '建議對任何 Functions 與 Methods 都加上類型註解（參見  PEP 484 ），必要時在一般名稱也可做註記（回傳值無法推斷時）。 if not row > -1:\n    return\n\n# Here is not None!\nitem: MyItem = table.item(row)\nitem.do_something() 若是回傳 None 值，可以不加上回傳值的註解。 def func(a: bool):\n    if a:\n        return\n    do_my_job() 序列的樣式為 Sequence[T]、List[T]、Iterator[T] 等，唯獨 Tuple[T] 為固定長度，應標示 Tuple[T, ...]。 def _join_more(iter_obj: Iterable[int]) -> Tuple[int, ...]:\n    """Convert iterable object to tuple."""\n    return tuple(iter_obj) + (1,) 若是可能為多種非繼承類型，使用 Union。 s: Union[str, Sequence[bytes]] = s_func() 若是可能為 None 值，應加上 Optional。 def func(*, labels: Optional[Sequence[int]] = None):\n    ... Functions 使用 Callable[[In_T1, InT2], Out_T]。 def danger(func: Callable[[Any], Any]) -> Callable[[Any], Any]:\n    """My danger decorator."""\n\n    def wrapper_func(*args):\n        """Is danger function."""\n        print("Danger!")\n        return func(*args)\n\n    return wrapper_func\n\n\n@danger\ndef foo():\n    ... 造成遞迴引用類型時應改為字串。 class MyClass:\n\n    def __add__(self, p: \'MyClass\') -> \'MyClass\':\n        ...', 'tags': '', 'url': '類型註解.html'}, {'title': 'Kmol-editor', 'text': 'https://github.com/KmolYuan/kmol-editor \xa0是一個輕量的工程用編輯器, 主要用來開發自己 (意即以 kmol-editor 開發 kmol-editor), 以及應用於協同 Markdown 文件編輯, 可結合  Pandoc  與  MikTeX , 將 Markdown 資料轉換為 html 與 pdf 或 epub 格式. http://lab.kmol.info \xa0 目前使用可攜  miktex_portable_and_pandoc.7z , 使用者下載後與先前的 Python 可攜系統結合, 在原有的 start.bat 啟動批次檔案中的 path 設定, 加入: %Disk%:\\pandoc-2.4-windows-x86_64;%Disk%:\\miktex_portable\\texmfs\\install\\miktex\\bin; 重新啟動後, 即可利用 pandoc 指令與 xelatex 將 Markdown 資料轉為 pdf 文件. 此外, 若配合\xa0 https://github.com/KmolYuan/kmolbook-paper \xa0倉儲, 用於建立課程專題報告、學位論文或期刊論文等, 則需要額外以下列指令: python -m pip install pandoc-fignos pandoc-tablenos pandoc-eqnos 安裝\xa0 pandoc-fignos ,  pandoc-tablenos  與  pandoc-eqnos  等模組. 過程中, 還必須透過 MikTeX Package Manager 安裝: tex\\latex\\catoptions\\catoptions.sty tex\\latex\\fancyhdr\\fancyhdr.sty tex\\latex\\xwatermark\\xwatermark.sty tex\\latex\\ltxkeys\\ltxkeys.sty tex\\latex\\ms\\everyshi.sty tikz.sty tex\\latex\\xcolor\\xcolor.sty 等 packages.', 'tags': '', 'url': 'Kmol-editor.html'}, {'title': '參考', 'text': 'Design of special planar linkages.pdf https://designengrlab.github.io/PMKS/ \xa0 https://github.com/DesignEngrLab/PMKS \xa0 Automated Generation of Linkage Loop Equations for Planar One Degree-of-Freedom Linkages up to 8-Bar.pdf Computer Aided Design of Eight-bar Linkages.pdf Implementation of an Open Source Planar Linkage Mechanism Simulation and Dimensional Synthesis System.pdf 自動拓樸結構合成 Automatic Synthesis of Planar Simple Joint Kinematic Chains by Single Kinematic Chain Adding Method 機構類型合成 TYPE SYNTHESIS OF PLANAR LINKAGE MECHANISMS WITH ROTOIDAL AND PRISMATIC JOINTS 網際連桿合成 A WEB-BASED OPTIMIZATION FOR FUNCTION SYNTHESIS OF PLANAR LINKAGE 機構尺寸合成 Dimensional Synthesis of Six-Bar Linkage as a Constrained RPR Chain C++ 程式轉為 Python 動態程式庫 AutoWIG - automatic generation of python bindings for Cpp libraries.pdf https://github.com/StatisKit/AutoWIG 其他 1990: \xa0 Number synthesis of kinematic chains based on permutation groups 1995: \xa0 Structural Synthesis of Mechanisms 2007: \xa0 A new theory for the topological structure analysis of kinematic chains and its applications 2008: \xa0 Computer-aided structure decomposition theory of kinematic chains and its applications 2012: \xa0 Synthesis of the whole family of planar 1-DOF kinematic chains and creation of their atlas database 2013: \xa0 Automated sketching of non-fractionated kinematic chains 2014: \xa0 一般化運動鏈之數目合成 2015: \xa0 On the number synthesis of kinematic chains 2015: \xa0 Automatic_Structural_Synthesis_of_Planar_Mechanisms_and_Its_Application_to_Creative_Design.pdf 2016: \xa0 Automatic generation of the complete set of planar kinematic chains with up to six independent loops and up to 19 links 2017: \xa0 An automatic method for the connectivity calculation in planar closed kinematic chains 2018: \xa0 A new atlas for 8-bar kinematic chains with up to 3 prismatic pairs using Joint Sorting Code 2018: \xa0 A new method for the automatic sketching of planar kinematic chains CAD https://freecadweb.org/ \xa0 https://www.blender.org/ \xa0 https://github.com/tpaviot/oce \xa0 https://github.com/LaughlinResearch/pyOCCT \xa0', 'tags': '', 'url': '參考.html'}, {'title': 'Misc', 'text': 'The Secret and Beauty of Ancient Chinese Padlocks.pdf', 'tags': '', 'url': 'Misc.html'}]};