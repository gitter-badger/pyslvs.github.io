<h1>簡介</h1>
<p><a href="https://github.com/KmolYuan/Pyslvs-PyQt5">Pyslvs</a> 是一套利用 Python 3 與 PyQt5 建立的平面機構模擬與合成系統.  機構模擬與合成的主要核心包括 <a href="https://github.com/KmolYuan/python-solvespace">Python-Solvespace</a> 幾何約束求解程式庫、<a href="https://github.com/KmolYuan/pyslvs/blob/master/src/tinycadlib.pyx">tinycadlib</a> 三角幾何函式程式庫、<a href="https://github.com/KmolYuan/Adesign">ADesign</a> 演算程式庫、<a href="https://github.com/KmolYuan/pyslvs/blob/master/src/bfgs.pyx">bgfs</a> 幾何約束求解程式庫、<a href="https://github.com/KmolYuan/pyslvs/blob/master/src/topologic.pyx">topologic</a> 類型合成程式庫、<a href="https://github.com/KmolYuan/pyslvs/blob/master/src/number.pyx">number</a> 數目合成程式庫等.</p>
<p>其中, <a href="https://github.com/KmolYuan/Adesign">ADesign</a> 演算程式庫包含 Real-coded Genetic Algorithm (<a href="https://github.com/KmolYuan/Adesign/blob/master/src/rga.pyx">RGA</a>)、Differential Evolution (<a href="https://github.com/KmolYuan/Adesign/blob/master/src/de.pyx">DE</a>) 與 Firefly Algorithm (<a href="https://github.com/KmolYuan/Adesign/blob/master/src/firefly.pyx">Firefly</a>) 等三種, 用於平面機構尺寸合成演算.</p>
<h4>源起</h4>
<p><a href="https://github.com/KmolYuan/Pyslvs-PyQt5">Pyslvs</a> 的開發源自 2008 年, 從最基本的實數基因演算法在平面機構的應用研究起步, 期間歷經下列研究者的貢獻:</p>
<ol>
<li>李孟恭, 2015, <a href="https://hdl.handle.net/11296/tur9hu">Django 網際框架在平面四連桿尺寸合成系統上的應用</a></li>
<li>李玠廷, 2013, <a href="https://hdl.handle.net/11296/mtf789">網際程式框架在平面連桿機構尺寸合成系統上的應用</a></li>
<li>陳威任, 2013, 符號式平面滑塊機構應用研究</li>
<li>謝政良, 2012, <a href="https://hdl.handle.net/11296/h5z5sb">網際雙自由度凸輪機構尺寸合成系統</a></li>
<li>黃竣鉉, 2012, <a href="https://hdl.handle.net/11296/a5b4p7">網際符號輔助軸接連桿機構之基因演算法尺寸合成系統</a></li>
<li>謝智翔, 2012, <a href="https://hdl.handle.net/11296/v9mr92">網際史都華平台機構逆運動學分析與模擬</a></li>
<li>許哲菘, 2010, <a href="https://hdl.handle.net/11296/w66tpa">網際六軸機械臂系統的逆運動學分析與模擬</a></li>
<li>葉岱錦, 2009, <a href="https://hdl.handle.net/11296/tt6672">基因演算法在網際機構合成系統上的應用</a></li>
</ol>
<p>過程中, 於 2015 年由<a href="https://github.com/kmollee">李孟恭</a>整合上述論文所開發的三種演算法, 完成 <a href="http://cython.org/">Cython</a> 格式的 <a href="https://github.com/kmollee/algorithm/blob/master/rga.pyx">RGA</a>、<a href="https://github.com/kmollee/algorithm/blob/master/de.pyx">DE</a> 與 <a href="https://github.com/kmollee/algorithm/blob/master/firefly.pyx">Firefly</a> 演算法程式庫後. 並自 2016 年起由<a href="https://github.com/KmolYuan">張元</a>將上述尺寸合成演算法, 搭配利用  <a href="http://www.swig.org/">SWIG</a> 技術, 將原本只能用於 Python 2 的 <a href="https://github.com/BBBSnowball/python-solvespace">Python-Solvespace</a> 倉儲, 改寫為能結合 PyQt5 圖形介面使用的 <a href="https://github.com/KmolYuan/python-solvespace">Python-Solvespace</a> 程式庫作為另一項開端. 再搭配平面機構中的數目合成與類型合成等程式庫後, 成為目前的 <a href="https://github.com/KmolYuan/Pyslvs-PyQt5">Pyslvs</a> 平面機構模擬與合成套件.</p>
<h4>Pyslvs 開發紀要</h4>
<p>2015 年 4 月 - 由<a href="https://github.com/kmollee">李孟恭</a>以 <a href="http://cython.org/">Cython</a> 技術, 完成三個<a href="https://github.com/kmollee/algorithm">尺寸合成演算法</a>程式庫.</p>
<p>2016 年 7 月 - 由<a href="https://github.com/KmolYuan">張元</a>完成 Python 3 格式的 <a href="https://github.com/KmolYuan/python-solvespace">Python-Solvespace</a> 程式庫.</p>
<p>2016 年 12 月- 由<a href="https://github.com/KmolYuan">張元</a>結合 PyQt5 與演算程式庫, 完成第一代 <a href="https://github.com/KmolYuan/Pyslvs-PyQt5">Pyslvs</a> 套件.</p>
<p>2017 年 11 月 - <a href="http://pyslvs.com">http://pyslvs.com</a> 上線.</p>
<p>2018 年 1 月 - 推出 <a href="https://github.com/KmolYuan/Pyslvs-PyQt5">Pyslvs</a> 18.01  版, 自此改為以年月序作為版次.</p>
<p>2018 年 7 月 - <a href="http://pyslvs.com/content/">http://pyslvs.com/content/</a> 使用手冊上線.</p>
<p></p>
<h2>機構與機器</h2>
<h4>機構 (Mechanism)</h4>
<p>機構是由剛體 (Rigid) 或撓性 (Flexible) 體機械元件所組成, 這些元件透過接頭 (Joint) 連接, 並以特定的運動相互移動.</p>
<h4>機器 (Machine)</h4>
<p>機器是由機構或機構的集合所組成, 能將力從動力源傳遞到預計要施加之元件上.</p>
<p>換言之, 機器是由剛性元件或撓性元件所組合而成, 能將力從動力源傳遞到預計要施加之元件上.</p>
<p>機器具有兩個功能: 傳遞確定的相對運動和傳遞力.  這些功能需要足夠強度與剛性來傳遞力.</p>
<p>若機構中所有的機件皆為連桿, 且所有的接頭皆為旋轉對, 則這個機構特稱為連 (Linkage).</p>
<p>參考資料:</p>
<p style="padding-left: 30px;"><a href="/downloads/Comparison_of_Methodologies_for_Conceptual_Design_of_Mechanisms.pdf">Comparison of Methodologies for Conceptual Design of Mechanisms.pdf</a></p>
<p style="padding-left: 30px;"><a href="/downloads/Design_and_Optimization_of_Slider_and_Crank_Mechanism_with_Multibody_Systems.pdf">Design and Optimization of Slider and Crank Mechanism with Multibody Systems.pdf</a></p>
<p style="padding-left: 30px;"><a href="/downloads/Dynamic_Analysis_of_Flexible_Mechanisms_by_Multibody_Dynamics.pdf">Dynamic Analysis of Flexible Mechanisms by Multibody Dynamics.pdf</a></p><h2>Pyslvs 介面</h2>
<p>(以 <a href="https://drive.google.com/file/d/1VZ9uW1lWkZyYBpxDBqCjBii1aGdHPTKj/view?usp=sharing">pyslvs-18.8.0.mscv1900-amd64.exe</a><span>  開啟)</span></p>
<p><img alt="" height="524" src="/images/pyslvs-18.7.0-screenshot.png" width="600"/></p>
<p>Pyslvs 主畫面的上方為功能表列 (Menu bar), 右側為畫布 (Canvas), 左方則有各式功能的分頁欄 (Tab widgets).</p>
<p>功能表列涵蓋大部分的功能, 其中部分有關各項目的細部操作, 則必須在對應的分頁欄中選取或設定. </p>
<h4>Mechanism 分頁</h4>
<p>Pyslvs 左側中的 Mechanism 子頁面, 主要用於輸入機構關鍵點與運動連桿, 使用時以滑鼠點選 Mechanism 頁面後, 可在右方工作區, 以滑鼠輸入機構關鍵點與運動連桿.</p>
<h4>Inputs 分頁</h4>
<p>Pyslvs 的 Inputs 子頁面用於宣告機構的主動軸, 並進行運動模擬.</p>
<h4>Synthesis 分頁</h4>
<p>Pyslvs 的 Synthesis 子頁面用於進行平面機構的結構合成與尺寸合成.</p>
<h4>功能表列 (Menu bar)</h4>
<p>功能表列中根據不同的功能分類如下:</p>
<p>檔案 (File)</p>
<p>建立新的工作簿、開啟既有的工作簿、參考範例, 以及不同檔案格式的匯入與匯出功能.</p>
<p>編輯 (Edit)</p>
<p>復原與重做功能. </p>
<p>選項 (Options)</p>
<p>檢視方式調整以及工作簿相關資訊.</p>
<p>說明 (Help)</p>
<p>與 Pyslvs 相關網站與套件資訊.</p>
<h4>快捷鍵</h4>
<p>F1 - 有關 Pyslvs</p>
<p>Shift + F1 - Toggle 全螢幕</p>
<p></p><h1>操作</h1>
<p>Pyslvs 開啟 Crank-Rocker 機構畫面, under Mechanism 頁面 (以 <a href="https://drive.google.com/file/d/1VZ9uW1lWkZyYBpxDBqCjBii1aGdHPTKj/view?usp=sharing">pyslvs-18.8.0.mscv1900-amd64.exe</a><span>  開啟)</span>:</p>
<p><img alt="" height="338" src="/images/crank_rocker-18.7.0.png" width="600"/></p>
<p>Crank-Rocker under Inputs 頁面 (以 <a href="https://drive.google.com/file/d/1VZ9uW1lWkZyYBpxDBqCjBii1aGdHPTKj/view?usp=sharing">pyslvs-18.8.0.mscv1900-amd64.exe</a><span>  開啟)</span>:</p>
<p><img alt="" height="338" src="/images/crank_rocker_inputs-18.7.0.png" width="600"/></p>
<p>Crank-Rocker 通過特定點尺寸合成畫面1 (以 <a href="https://drive.google.com/file/d/1VZ9uW1lWkZyYBpxDBqCjBii1aGdHPTKj/view?usp=sharing">pyslvs-18.8.0.mscv1900-amd64.exe</a><span>  開啟)</span>:</p>
<p><img alt="" height="338" src="/images/crank_rocker_dimensional_synthesis1.png" width="600"/></p>
<p>完成 1000 代 DE 演算法之後的結果畫面 (以 <a href="https://drive.google.com/file/d/1VZ9uW1lWkZyYBpxDBqCjBii1aGdHPTKj/view?usp=sharing">pyslvs-18.8.0.mscv1900-amd64.exe</a><span>  開啟)</span>:</p>
<p><img alt="" height="338" src="/images/crank_rocker_dimensional_synthesis2.png" width="600"/></p><h2>模擬操作</h2>
<p>Pyslvs 的模擬操作主要牽涉 Mechanism 與 Inputs 分頁, Mechanism 分頁用於定義機構各節點與連桿, 而 Inputs 分頁則可用來定義主動旋轉軸, 並利用自動或手動模式進行合理平面機構的運動模擬.</p><h3>曲柄滑塊</h3>
<p>以下說明以 <a href="https://drive.google.com/file/d/1VZ9uW1lWkZyYBpxDBqCjBii1aGdHPTKj/view?usp=sharing">pyslvs-18.8.0.mscv1900-amd64.exe</a><span>  為主.</span></p>
<p>File -&gt; New Workbook</p>
<p>選擇左側 Mechanism 子頁面.</p>
<h4>建立固定點與移動點</h4>
<p>利用滑鼠在右側畫布區, 按住滑鼠右鍵輸入兩個固定點與一個可運動點.</p>
<h4>建立連桿</h4>
<p>將其中一個固定點轉為滑塊, 即將 point2 之類型 (type) 由 pin 轉為 pin in slot, 採內建水平滑動面, 或更改滑動面的對應角度.</p>
<p>在 Mechanism 完成機構定義後, 轉到 Inputs 子頁面, 定義 Driver point 後進行曲柄滑塊的運動模擬.</p><h3>四連桿</h3>
<p>在 Mechanism 子頁面定義兩個固定點與兩個移動點後, 建立三根可運動連桿.</p>
<p>接著進入 Inputs 頁面, 定義 driver points 後進行基本運動模擬.</p>
<h2>尺寸合成操作</h2>
<p>Pyslvs 的尺寸合成功能, 主要依賴 <a href="https://github.com/KmolYuan/pyslvs/blob/master/src/tinycadlib.pyx">tinycadlib</a><span> 三角幾何函式程式庫與 </span><a href="https://github.com/KmolYuan/Adesign">ADesign</a><span> 演算程式庫, 其中各平面機構範例進行尺寸合成的第一步必須先以三角幾何函式程式庫進行配置後, 再輸入特定機構節點所要通過的運行點座標, 最後再選擇 <a href="https://github.com/KmolYuan/Adesign">ADesign</a> 演算程式庫中的 Real-coded Genetic Algorithm (<a href="https://github.com/KmolYuan/Adesign/blob/master/src/rga.pyx">RGA</a>)、Differential Evolution (<a href="https://github.com/KmolYuan/Adesign/blob/master/src/de.pyx">DE</a>) 或 Firefly Algorithm (<a href="https://github.com/KmolYuan/Adesign/blob/master/src/firefly.pyx">Firefly</a>) 演算法進行尺寸合成運算.</span></p><h2>結構合成操作</h2>
<p>Pyslvs 的結構合成包括平面機構的數目合成與類型合成等兩部分.</p>
<p>在數目合成階段, 使用者可以選擇連桿個數 (Link number)、接頭個數 (Joint number), 以及機構的自由度.</p><h1>下載</h1>
<p>利用 pyslvs At mde 登錄 Gdrive 提供各版次下載.</p>
<p>Windows 64 位元操作系統:</p>
<p><a href="https://drive.google.com/file/d/1YdgFsFwFMmYvB0wi56OInl-0crUJPFlh/view?usp=sharing">pyslvs-18.7.0.mscv1900-amd64.exe</a> (53446 KB)</p>
<p><a href="https://drive.google.com/file/d/1VZ9uW1lWkZyYBpxDBqCjBii1aGdHPTKj/view?usp=sharing">pyslvs-18.8.0.mscv1900-amd64.exe</a> (53458 KB)</p>
<p><a href="https://drive.google.com/file/d/1gaX-_UfrbjObdATGvS00egfTW0uq3piP/view?usp=sharing">pyslvs-18.9.0.mscv1900-amd64.exe</a> (68337 KB)</p><h1>範例</h1>
<p>展示利用 Pyslvs 解題</p>
<p>參考資料:</p>
<p>1977 - <a href="https://theses.ncl.ac.uk/dspace/bitstream/10443/567/1/Oldham77.pdf">THE KINEMATICS AND VIBRATION OF PLANAR LINKAGE MECHANISMS</a></p>
<p><a href="https://www.researchgate.net/publication/304782762_MeKin2D_Suite_for_Planar_Mechanism_Kinematics">MeKin2d</a></p>
<p><a href="https://www.amazon.com/Machines-Mechanisms-Applied-Kinematic-Analysis/dp/0132157802">MACHINES AND MECHANISMS APPLIED KINEMATIC ANALYSIS Fourth Edition by David H. Myszka</a></p>
<p><a href="https://books.google.com.tw/books?id=0A1mDwAAQBAJ&amp;pg=PP1&amp;lpg=PP1&amp;dq=Introduction+to+Mechanism+Design:+with+Computer+Applications&amp;source=bl&amp;ots=WakYIZ-L93&amp;sig=tSRFX6Z9fhaT3Lzk3USgSb05PXA&amp;hl=en&amp;sa=X&amp;ved=2ahUKEwiPqeP4-sPcAhVHFYgKHbE_Ae4Q6AEwBHoECAUQAQ#v=onepage&amp;q=Introduction%20to%20Mechanism%20Design%3A%20with%20Computer%20Applications">Introduction to Mechanism Design: with Computer Applications by By Eric Constans and Karl B. Dyer</a></p>
<p><a href="https://www.amazon.com/Theory-Machines-Mechanisms-John-Uicker/dp/0195371232">THEORY OF MACHINES AND MECHANISMS Fourth Edition by John Uicker, Gordon Pennock and  Joseph Shigley</a></p>
<p></p>
<p></p>
<h2>模擬範例</h2>
<p><img alt="" height="338" src="/images/sam_sixbar.png" width="600"/></p>
<p>以下畫面以 <a href="https://drive.google.com/file/d/1VZ9uW1lWkZyYBpxDBqCjBii1aGdHPTKj/view?usp=sharing">pyslvs-18.8.0.mscv1900-amd64.exe</a><span>  製作.</span></p>
<p><img alt="" height="338" src="/images/sam_sixbar-18.7.png" width="600"/></p>
<p>以下畫面以 <a href="https://drive.google.com/file/d/1VZ9uW1lWkZyYBpxDBqCjBii1aGdHPTKj/view?usp=sharing">pyslvs-18.8.0.mscv1900-amd64.exe</a><span>  製作.</span></p>
<p><img alt="" height="315" src="/images/sixbar_r_slider.png" width="560"/></p>
<p><a href="/downloads/sixbar_r_with_slider.pyslvs">sixbar_r_slider.pyslvs</a> (只適用於 <a href="https://drive.google.com/file/d/1VZ9uW1lWkZyYBpxDBqCjBii1aGdHPTKj/view?usp=sharing">pyslvs-18.8.0.mscv1900-amd64.exe</a><span> 版本</span>)</p>
<p><iframe allow="autoplay; encrypted-media" allowfullscreen="allowfullscreen" frameborder="0" height="315" src="https://www.youtube.com/embed/aBEfsdOycC8" width="560"></iframe></p>
<h4>建立六連桿機構模型</h4>
<p>以 <a href="https://drive.google.com/file/d/1VZ9uW1lWkZyYBpxDBqCjBii1aGdHPTKj/view?usp=sharing">pyslvs-18.8.0.mscv1900-amd64.exe</a><span>  製作</span>)</p>
<p><iframe allow="autoplay; encrypted-media" allowfullscreen="allowfullscreen" frameborder="0" height="315" src="https://www.youtube.com/embed/1BcjhYgvQtY" width="560"></iframe></p>
<h4>八連桿機構</h4>
<p><a href="/downloads/eight_bar1.pyslvs">eightbar1.pyslvs</a> (只適用於 <a href="https://drive.google.com/file/d/1VZ9uW1lWkZyYBpxDBqCjBii1aGdHPTKj/view?usp=sharing">pyslvs-18.8.0.mscv1900-amd64.exe</a><span> 版本</span>)</p>
<p><img alt="" height="322" src="/images/eightbar1.png" width="600"/></p>
<p><a href="/downloads/eight_bar2.pyslvs">eightbar2.pyslvs</a> (只適用於 <a href="https://drive.google.com/file/d/1VZ9uW1lWkZyYBpxDBqCjBii1aGdHPTKj/view?usp=sharing">pyslvs-18.8.0.mscv1900-amd64.exe</a><span> 版本</span>)</p>
<p><img alt="" height="322" src="/images/eightbar2.png" width="600"/></p>
<p><a href="/downloads/eight_bar3.pyslvs">eightbar3.pyslvs</a> (只適用於 <a href="https://drive.google.com/file/d/1VZ9uW1lWkZyYBpxDBqCjBii1aGdHPTKj/view?usp=sharing">pyslvs-18.8.0.mscv1900-amd64.exe</a><span> 版本</span>)</p>
<p><img alt="" height="322" src="/images/eightbar3.png" width="600"/></p>
<h4>十連桿機構</h4>
<p><a href="/downloads/tenbar_linkage.pyslvs">tenbar_linkage.pyslvs</a> (只適用於 <a href="https://drive.google.com/file/d/1VZ9uW1lWkZyYBpxDBqCjBii1aGdHPTKj/view?usp=sharing">pyslvs-18.8.0.mscv1900-amd64.exe</a><span> 版本</span>)</p>
<p><img alt="" height="322" src="/images/tenbar_linkage.png" width="600"/></p><h2>尺寸合成範例</h2>
<h2>結構合成範例</h2>
<h2>產品設計範例</h2>
<h4>健步機</h4>
<p><a href="/downloads/2014_nsysu_design_linkage_type_foot_exercise_machine.pdf">連桿式健步機設計.pdf</a></p>
<p><a href="/downloads/sixbar_foot_exercise_machine.pyslvs">sixbar_foot_exercise_machine.pyslvs</a> (只適用於 <a href="https://drive.google.com/file/d/1VZ9uW1lWkZyYBpxDBqCjBii1aGdHPTKj/view?usp=sharing">pyslvs-18.8.0.mscv1900-amd64.exe</a><span> 版本</span>)</p>
<p><img alt="" height="338" src="/images/sixbar_foot_exercise_machine.png" width="600"/></p>
<h4>汽車雨刷</h4>
<p><a href="/downloads/windshield_design1.pyslvs">windshield_design1.pyslvs</a> (只適用於 <a href="https://drive.google.com/file/d/1VZ9uW1lWkZyYBpxDBqCjBii1aGdHPTKj/view?usp=sharing">pyslvs-18.8.0.mscv1900-amd64.exe</a><span> 版本</span>)</p>
<p><img alt="" height="338" src="/images/windshield_design1.png" width="600"/></p>
<h4>汽車引擎蓋</h4>
<p><a href="/downloads/automobile_hood1.pyslvs">automobile_hood1.pyslvs</a> (只適用於 <a href="https://drive.google.com/file/d/1VZ9uW1lWkZyYBpxDBqCjBii1aGdHPTKj/view?usp=sharing">pyslvs-18.8.0.mscv1900-amd64.exe</a><span> 版本</span>)</p>
<p><img alt="" height="322" src="/images/automobile_hood1.png" width="600"/></p>
<p>平開窗戶開合機構</p>
<p><a href="/downloads/house_window.pyslvs">house_window.pyslvs</a> (只適用於 <a href="https://drive.google.com/file/d/1VZ9uW1lWkZyYBpxDBqCjBii1aGdHPTKj/view?usp=sharing">pyslvs-18.8.0.mscv1900-amd64.exe</a><span> 版本</span>)</p>
<p><img alt="" height="322" src="/images/casement_window.png" width="600"/></p>
<p></p><h1>開發</h1>
<p>以 Eric6 IDE 開啟 Pyslvs 專案:</p>
<p><img alt="" height="338" src="/images/pyslvs_under_eric6.png" width="600"/></p><h2>Windows 開發</h2>
<p>下載 <a href="https://drive.google.com/file/d/12BLN4daAPlO1KjCTDFi1kqJZ6f5k7Y5k/view?usp=sharing">Qt 可攜程式開發套件.7z </a> (下載檔案約 8GB, 解開壓縮後約 21GB)</p>
<p>使用 Python 3.7.0 與 Msys2  製作的 <a href="https://drive.google.com/file/d/1WOGsDH_rVWBJJ5QI6FSJ4kDVBgAeRkkg/view?usp=sharing">p37_adv</a> (下載檔案約 5.3 GB, 解開壓縮約 14 GB)</p>
<p>執行 start.bat</p>
<p>取得 Pyslvs 原始碼:</p>
<pre class="brush:js;auto-links:false;toolbar:false" contenteditable="false">git clone --recurse-submodules https://github.com/KmolYuan/Pyslvs-PyQt5</pre>
<h4>編譯 GUI 套件:</h4>
<p>進入 Pyslvs-PyQt5 目錄後, 執行:</p>
<pre class="brush:js;auto-links:false;toolbar:false" contenteditable="false">mingw32-make clean
mingw32-make</pre>
<p>完成後, 以 2018.09 版次為例, dist 目錄中將得到可執行檔案:</p>
<pre class="brush:js;auto-links:false;toolbar:false" contenteditable="false">pyslvs-18.9.0.mscv1900-amd64.exe</pre>
<h4>編譯 no GUI 程式庫:</h4>
<p>在命令列中更換目錄至 core\libs\pyslvs 後, 執行:</p>
<pre class="brush:js;auto-links:false;toolbar:false" contenteditable="false">mingw32-make clean
mingw32-make</pre>
<p>建立下列動態連結程式庫 (pyd):</p>
<pre class="brush:js;auto-links:false;toolbar:false" contenteditable="false">bfgs.cp36-win_amd64.pyd
de.cp36-win_amd64.pyd
firefly.cp36-win_amd64.pyd
number.cp36-win_amd64.pyd
planarlinkage.cp36-win_amd64.pyd
pmks.cp36-win_amd64.pyd
rga.cp36-win_amd64.pyd
tinycadlib.cp36-win_amd64.pyd
topologic.cp36-win_amd64.pyd
triangulation.cp36-win_amd64.pyd
verify.cp36-win_amd64.pyd</pre>
<p>位於 pyslvs 目錄中的 unittest 程式:</p>
<pre class="brush:py;auto-links:false;toolbar:false" contenteditable="false"># -*- coding: utf-8 -*-

"""This module will test the functions of Pyslvs."""

__author__ = "Yuan Chang"
__copyright__ = "Copyright (C) 2016-2018"
__license__ = "AGPL"
__email__ = "pyslvs@gmail.com"

import unittest
from unittest import TestCase
from typing import Tuple, List

#For necessary testing modules.
from math import sqrt, radians, isclose
from pmks import VPoint
import bfgs
from tinycadlib import (
    Coordinate,
    PLAP,
    PLLP,
    PLPP,
    PXY,
    expr_solving,
    data_collecting,
)
from planarlinkage import Planar
from rga import Genetic
from firefly import Firefly
from de import DiffertialEvolution
from number import number_synthesis
from topologic import topo, Graph
from triangulation import vpoints_configure
from _parser import parse_vpoints
from examples import example_list


class CoreTest(TestCase):
    
    """Testing Cython libs."""
    
    def vpoints_object(self) -&gt; Tuple[List[VPoint], Tuple[Tuple[int, int]]]:
        """Example: Jansen's linkage (Single)."""
        expr, inputs = example_list["Jansen's linkage (Single)"]
        return parse_vpoints(expr), inputs
    
    def planar_object(self) -&gt; Planar:
        """Test-used mechanism for algorithm."""
        return Planar({
            'Driver': {'P0': (-70, -70, 50)},
            'Follower': {'P1': (70, -70, 50)},
            'Target': {'P4': [
                (60.3, 118.12),
                (31.02, 115.62),
                (3.52, 110.62),
                (-25.77, 104.91),
                (-81.49, 69.19),
                (-96.47, 54.906),
                (-109.34, 35.98),
                (-121.84, 13.83),
                (-127.56, -20.09),
                (-128.63, -49.74),
                (-117.56, -65.45),
            ]},
            'Expression': "PLAP[P0,L0,a0](P2);" +
                "PLLP[P2,L1,L2,P1](P3);" +
                "PLLP[P2,L3,L4,P3](P4)",
            'constraint': [('P0', 'P1', 'P2', 'P3')],
            'upper': [100., 100., 100., 100., 100., 360.],
            'lower': [5., 5., 5., 5., 5., 0.],
        })
    
    def test_plap(self):
        """Test for PLAP function."""
        A = Coordinate(0, 0)
        B = Coordinate(50, 0)
        x, y = PLAP(A, 50 * sqrt(2), radians(45), B)
        self.assertTrue(isclose(x, 50))
        self.assertTrue(isclose(y, 50))
    
    def test_pllp(self):
        """Test for PLLP function."""
        A = Coordinate(-30, 0)
        B = Coordinate(30, 0)
        x, y = PLLP(A, 50, 50, B)
        self.assertTrue(isclose(x, 0))
        self.assertTrue(isclose(y, 40))
        x, y = PLLP(A, 30, 30, B)
        self.assertTrue(isclose(x, 0))
        self.assertTrue(isclose(y, 0))
        x, y = PLLP(A, 90, 30, B)
        self.assertTrue(isclose(x, 60))
        self.assertTrue(isclose(y, 0))
    
    def test_plpp(self):
        """Test for PLPP function."""
        A = Coordinate(0, 0)
        B = Coordinate(0, -3)
        C = Coordinate(3/2, 0)
        x, y = PLPP(A, sqrt(5), B, C)
        self.assertTrue(isclose(x, 2))
        self.assertTrue(isclose(y, 1))
    
    def test_pxy(self):
        A = Coordinate(80, 90)
        x, y = PXY(A, 40, -20)
        self.assertTrue(isclose(x, 120))
        self.assertTrue(isclose(y, 70))
    
    def test_topologic(self):
        """Testing 'topologic' libraries.
        
        + 'topo' function.
        + 'Graph' class.
        """
        G = Graph([(0, 1), (0, 4), (1, 5), (2, 3), (2, 4), (3, 5), (4, 5)])
        H = Graph([(0, 2), (0, 4), (1, 3), (1, 4), (2, 5), (3, 5), (4, 5)])
        I = Graph([(0, 1), (0, 2), (1, 4), (2, 5), (3, 4), (3, 5), (4, 5)])
        self.assertTrue(G.is_isomorphic(H))
        self.assertFalse(G.is_isomorphic(I))
        answer, time = topo([4, 2], degenerate=True)
        self.assertEqual(len(answer), 2)
    
    def test_solving(self):
        """Test triangular formula solving.
        
        + Test for PMKS parser.
        + Test data collecting function.
        + Test expression solving function.
        """
        vpoints, inputs = self.vpoints_object()
        self.assertTrue(len(vpoints) == 8)
        exprs = vpoints_configure(vpoints, inputs)
        mapping = {n: 'P{}'.format(n) for n in range(len(vpoints))}
        data_dict, dof = data_collecting(exprs, mapping, vpoints)
        for link, link_length in (
            ('L0', 15.002083188677497),
            ('L1', 41.50187586121861),
            ('L2', 49.9949057404852),
            ('L3', 40.09650982317538),
            ('L4', 55.80253220060896),
            ('L5', 61.90525179659639),
            ('L6', 39.302800154696364),
            ('L7', 36.69767567571548),
            ('L8', 39.395233214184685),
            ('L9', 48.995886562037015),
            ('L10', 65.69940106271898),
        ):
            self.assertTrue(isclose(data_dict[link], link_length))
        self.assertEqual(dof, 1)
        result = expr_solving(exprs, mapping, vpoints, [0.])
        x, y = result[-1]
        self.assertTrue(isclose(x, -43.17005515543241))
        self.assertTrue(isclose(y, -91.75322590542523))
    
    def test_bfgs(self):
        """Test Sketch Solve kernel."""
        input_data, output_data, grad_data = bfgs.test_kernel()
        self.assertEqual(input_data[0], (0.0, 0.0))
        self.assertEqual(input_data[1], (5.0, 0.0))
        self.assertEqual(input_data[2], (6.0, 5.0))
        self.assertEqual(input_data[3], (6.0, 5.0))
        self.assertEqual(input_data[4], (30.0, 10.0))
        self.assertTrue(isclose(round(output_data[2][1], 2), 10))
        self.assertTrue(isclose(round(output_data[4][0], 2), 30))
        vpoints, inputs = self.vpoints_object()
        result = bfgs.vpoint_solving(vpoints, [(0, 1, 0.)])
        x, y = result[-1]
        self.assertTrue(isclose(round(x, 2), -43.17))
        self.assertTrue(isclose(round(y, 2), -91.75))
    
    def test_number_synthesis(self):
        """Test Number Synthesis function."""
        for NL, NJ in [(4, 4), (6, 7), (8, 9), (10, 12)]:
            for factors in number_synthesis(NL, NJ):
                count = 0
                for i, factor in enumerate(factors):
                    count += factor * (i + 2)
                self.assertEqual(int(count / 2), NJ)
    
    def test_algorithm_rga(self):
        """Real-coded genetic algorithm."""
        fun1 = Genetic(self.planar_object(), {
            'maxTime': 1, 'report': 10,
            #Genetic
            'nPop': 500,
            'pCross': 0.95,
            'pMute': 0.05,
            'pWin': 0.95,
            'bDelta': 5.,
        })
        fun1.run()
    
    def test_algorithm_firefly(self):
        """Firefly algorithm."""
        fun2 = Firefly(self.planar_object(), {
            'maxTime': 1, 'report': 10,
            #Firefly
            'n': 80,
            'alpha': 0.01,
            'betaMin': 0.2,
            'gamma': 1.,
            'beta0': 1.,
        })
        fun2.run()
    
    def test_algorithm_de(self):
        """Differtial evolution."""
        fun3 = DiffertialEvolution(self.planar_object(), {
            'maxTime': 1, 'report': 10,
            #DE
            'strategy': 1,
            'NP': 400,
            'F': 0.6,
            'CR': 0.9,
        })
        fun3.run()


if __name__ == '__main__':
    unittest.main()
</pre>
<p></p><h3>參考檔案</h3>
<p>從 <a href="https://drive.google.com/file/d/1DWtyoUhl8CycKJ8uulB3viRXE39KqpE1/view?usp=sharing">p37</a> 標準版升級能夠以 <a href="https://www.msys2.org/">Msys2</a> 編譯 Pyslvs-PyQt5</p>
<pre class="brush:js;auto-links:false;toolbar:false" contenteditable="false">pip install PyQtChart
pip install lark-parser
pip install networkx
pip install ezdxf
pip install peewee
pip install openpyxl
pip install psutil
pip install pyinstaller
pip install cffi</pre>
<h4><span>cygwinccompiler.py 修改</span></h4>
<p><span>p37\Lib\distutils\cygwinccompiler.py</span></p>
<pre class="brush:py;auto-links:false;toolbar:false" contenteditable="false">"""distutils.cygwinccompiler

Provides the CygwinCCompiler class, a subclass of UnixCCompiler that
handles the Cygwin port of the GNU C compiler to Windows.  It also contains
the Mingw32CCompiler class which handles the mingw32 port of GCC (same as
cygwin in no-cygwin mode).
"""

# problems:
#
# * if you use a msvc compiled python version (1.5.2)
#   1. you have to insert a __GNUC__ section in its config.h
#   2. you have to generate an import library for its dll
#      - create a def-file for python??.dll
#      - create an import library using
#             dlltool --dllname python15.dll --def python15.def \
#                       --output-lib libpython15.a
#
#   see also http://starship.python.net/crew/kernr/mingw32/Notes.html
#
# * We put export_symbols in a def-file, and don't use
#   --export-all-symbols because it doesn't worked reliable in some
#   tested configurations. And because other windows compilers also
#   need their symbols specified this no serious problem.
#
# tested configurations:
#
# * cygwin gcc 2.91.57/ld 2.9.4/dllwrap 0.2.4 works
#   (after patching python's config.h and for C++ some other include files)
#   see also http://starship.python.net/crew/kernr/mingw32/Notes.html
# * mingw32 gcc 2.95.2/ld 2.9.4/dllwrap 0.2.4 works
#   (ld doesn't support -shared, so we use dllwrap)
# * cygwin gcc 2.95.2/ld 2.10.90/dllwrap 2.10.90 works now
#   - its dllwrap doesn't work, there is a bug in binutils 2.10.90
#     see also http://sources.redhat.com/ml/cygwin/2000-06/msg01274.html
#   - using gcc -mdll instead dllwrap doesn't work without -static because
#     it tries to link against dlls instead their import libraries. (If
#     it finds the dll first.)
#     By specifying -static we force ld to link against the import libraries,
#     this is windows standard and there are normally not the necessary symbols
#     in the dlls.
#   *** only the version of June 2000 shows these problems
# * cygwin gcc 3.2/ld 2.13.90 works
#   (ld supports -shared)
# * mingw gcc 3.2/ld 2.13 works
#   (ld supports -shared)

import os
import sys
import copy
from subprocess import Popen, PIPE, check_output
import re

from distutils.ccompiler import gen_preprocess_options, gen_lib_options
from distutils.unixccompiler import UnixCCompiler
from distutils.file_util import write_file
from distutils.errors import (DistutilsExecError, CCompilerError,
        CompileError, UnknownFileError)
from distutils import log
from distutils.version import LooseVersion
from distutils.spawn import find_executable

def get_msvcr():
    """Include the appropriate MSVC runtime library if Python was built
    with MSVC 7.0 or later.
    """
    msc_pos = sys.version.find('MSC v.')
    if msc_pos != -1:
        msc_ver = sys.version[msc_pos+6:msc_pos+10]
        if msc_ver == '1300':
            # MSVC 7.0
            return ['msvcr70']
        elif msc_ver == '1310':
            # MSVC 7.1
            return ['msvcr71']
        elif msc_ver == '1400':
            # VS2005 / MSVC 8.0
            return ['msvcr80']
        elif msc_ver == '1500':
            # VS2008 / MSVC 9.0
            return ['msvcr90']
        elif msc_ver == '1600':
            # VS2010 / MSVC 10.0
            return ['msvcr100']
        elif msc_ver == '1700':
            # Visual Studio 2012 / Visual C++ 11.0
            return ['msvcr110']
        elif msc_ver == '1800':
            # Visual Studio 2013 / Visual C++ 12.0
            return ['msvcr120']
        elif msc_ver == '1900':
            # Visual Studio 2015 / Visual C++ 14.0
            # "msvcr140.dll no longer exists"
            return ['vcruntime140']
        elif msc_ver == '1910':
            return ['vcruntime140']
        elif msc_ver == '1914':
            return ['vcruntime140']
        else:
            raise ValueError("Unknown MS Compiler version %s " % msc_ver)


class CygwinCCompiler(UnixCCompiler):
    """ Handles the Cygwin port of the GNU C compiler to Windows.
    """
    compiler_type = 'cygwin'
    obj_extension = ".o"
    static_lib_extension = ".a"
    shared_lib_extension = ".dll"
    static_lib_format = "lib%s%s"
    shared_lib_format = "%s%s"
    exe_extension = ".exe"

    def __init__(self, verbose=0, dry_run=0, force=0):

        UnixCCompiler.__init__(self, verbose, dry_run, force)

        status, details = check_config_h()
        self.debug_print("Python's GCC status: %s (details: %s)" %
                         (status, details))
        if status is not CONFIG_H_OK:
            self.warn(
                "Python's pyconfig.h doesn't seem to support your compiler. "
                "Reason: %s. "
                "Compiling may fail because of undefined preprocessor macros."
                % details)

        self.gcc_version, self.ld_version, self.dllwrap_version = \
            get_versions()
        self.debug_print(self.compiler_type + ": gcc %s, ld %s, dllwrap %s\n" %
                         (self.gcc_version,
                          self.ld_version,
                          self.dllwrap_version) )

        # ld_version &gt;= "2.10.90" and &lt; "2.13" should also be able to use
        # gcc -mdll instead of dllwrap
        # Older dllwraps had own version numbers, newer ones use the
        # same as the rest of binutils ( also ld )
        # dllwrap 2.10.90 is buggy
        if self.ld_version &gt;= "2.10.90":
            self.linker_dll = "gcc"
        else:
            self.linker_dll = "dllwrap"

        # ld_version &gt;= "2.13" support -shared so use it instead of
        # -mdll -static
        if self.ld_version &gt;= "2.13":
            shared_option = "-shared"
        else:
            shared_option = "-mdll -static"

        # Hard-code GCC because that's what this is all about.
        # XXX optimization, warnings etc. should be customizable.
        self.set_executables(compiler='gcc -mcygwin -O -Wall',
                             compiler_so='gcc -mcygwin -mdll -O -Wall',
                             compiler_cxx='g++ -mcygwin -O -Wall',
                             linker_exe='gcc -mcygwin',
                             linker_so=('%s -mcygwin %s' %
                                        (self.linker_dll, shared_option)))

        # cygwin and mingw32 need different sets of libraries
        if self.gcc_version == "2.91.57":
            # cygwin shouldn't need msvcrt, but without the dlls will crash
            # (gcc version 2.91.57) -- perhaps something about initialization
            self.dll_libraries=["msvcrt"]
            self.warn(
                "Consider upgrading to a newer version of gcc")
        #else:
            # Include the appropriate MSVC runtime library if Python was built
            # with MSVC 7.0 or later.
            #self.dll_libraries = get_msvcr()

    def _compile(self, obj, src, ext, cc_args, extra_postargs, pp_opts):
        """Compiles the source by spawning GCC and windres if needed."""
        if ext == '.rc' or ext == '.res':
            # gcc needs '.res' and '.rc' compiled to object files !!!
            try:
                self.spawn(["windres", "-i", src, "-o", obj])
            except DistutilsExecError as msg:
                raise CompileError(msg)
        else: # for other files use the C-compiler
            try:
                self.spawn(self.compiler_so + cc_args + [src, '-o', obj] +
                           extra_postargs)
            except DistutilsExecError as msg:
                raise CompileError(msg)

    def link(self, target_desc, objects, output_filename, output_dir=None,
             libraries=None, library_dirs=None, runtime_library_dirs=None,
             export_symbols=None, debug=0, extra_preargs=None,
             extra_postargs=None, build_temp=None, target_lang=None):
        """Link the objects."""
        # use separate copies, so we can modify the lists
        extra_preargs = copy.copy(extra_preargs or [])
        libraries = copy.copy(libraries or [])
        objects = copy.copy(objects or [])

        # Additional libraries
        libraries.extend(self.dll_libraries)

        # handle export symbols by creating a def-file
        # with executables this only works with gcc/ld as linker
        if ((export_symbols is not None) and
            (target_desc != self.EXECUTABLE or self.linker_dll == "gcc")):
            # (The linker doesn't do anything if output is up-to-date.
            # So it would probably better to check if we really need this,
            # but for this we had to insert some unchanged parts of
            # UnixCCompiler, and this is not what we want.)

            # we want to put some files in the same directory as the
            # object files are, build_temp doesn't help much
            # where are the object files
            temp_dir = os.path.dirname(objects[0])
            # name of dll to give the helper files the same base name
            (dll_name, dll_extension) = os.path.splitext(
                os.path.basename(output_filename))

            # generate the filenames for these files
            def_file = os.path.join(temp_dir, dll_name + ".def")
            lib_file = os.path.join(temp_dir, 'lib' + dll_name + ".a")

            # Generate .def file
            contents = [
                "LIBRARY %s" % os.path.basename(output_filename),
                "EXPORTS"]
            for sym in export_symbols:
                contents.append(sym)
            self.execute(write_file, (def_file, contents),
                         "writing %s" % def_file)

            # next add options for def-file and to creating import libraries

            # dllwrap uses different options than gcc/ld
            if self.linker_dll == "dllwrap":
                extra_preargs.extend(["--output-lib", lib_file])
                # for dllwrap we have to use a special option
                extra_preargs.extend(["--def", def_file])
            # we use gcc/ld here and can be sure ld is &gt;= 2.9.10
            else:
                # doesn't work: bfd_close build\...\libfoo.a: Invalid operation
                #extra_preargs.extend(["-Wl,--out-implib,%s" % lib_file])
                # for gcc/ld the def-file is specified as any object files
                objects.append(def_file)

        #end: if ((export_symbols is not None) and
        #        (target_desc != self.EXECUTABLE or self.linker_dll == "gcc")):

        # who wants symbols and a many times larger output file
        # should explicitly switch the debug mode on
        # otherwise we let dllwrap/ld strip the output file
        # (On my machine: 10KB &lt; stripped_file &lt; ??100KB
        #   unstripped_file = stripped_file + XXX KB
        #  ( XXX=254 for a typical python extension))
        if not debug:
            extra_preargs.append("-s")

        UnixCCompiler.link(self, target_desc, objects, output_filename,
                           output_dir, libraries, library_dirs,
                           runtime_library_dirs,
                           None, # export_symbols, we do this in our def-file
                           debug, extra_preargs, extra_postargs, build_temp,
                           target_lang)

    # -- Miscellaneous methods -----------------------------------------

    def object_filenames(self, source_filenames, strip_dir=0, output_dir=''):
        """Adds supports for rc and res files."""
        if output_dir is None:
            output_dir = ''
        obj_names = []
        for src_name in source_filenames:
            # use normcase to make sure '.rc' is really '.rc' and not '.RC'
            base, ext = os.path.splitext(os.path.normcase(src_name))
            if ext not in (self.src_extensions + ['.rc','.res']):
                raise UnknownFileError("unknown file type '%s' (from '%s')" % \
                      (ext, src_name))
            if strip_dir:
                base = os.path.basename (base)
            if ext in ('.res', '.rc'):
                # these need to be compiled to object files
                obj_names.append (os.path.join(output_dir,
                                              base + ext + self.obj_extension))
            else:
                obj_names.append (os.path.join(output_dir,
                                               base + self.obj_extension))
        return obj_names

# the same as cygwin plus some additional parameters
class Mingw32CCompiler(CygwinCCompiler):
    """ Handles the Mingw32 port of the GNU C compiler to Windows.
    """
    compiler_type = 'mingw32'

    def __init__(self, verbose=0, dry_run=0, force=0):

        CygwinCCompiler.__init__ (self, verbose, dry_run, force)

        # ld_version &gt;= "2.13" support -shared so use it instead of
        # -mdll -static
        if self.ld_version &gt;= "2.13":
            shared_option = "-shared"
        else:
            shared_option = "-mdll -static"

        # A real mingw32 doesn't need to specify a different entry point,
        # but cygwin 2.91.57 in no-cygwin-mode needs it.
        if self.gcc_version &lt;= "2.91.57":
            entry_point = '--entry _DllMain@12'
        else:
            entry_point = ''

        if is_cygwingcc():
            raise CCompilerError(
                'Cygwin gcc cannot be used with --compiler=mingw32')

        self.set_executables(compiler='gcc -O -Wall',
                             compiler_so='gcc -mdll -O -Wall',
                             compiler_cxx='g++ -O -Wall',
                             linker_exe='gcc',
                             linker_so='%s %s %s'
                                        % (self.linker_dll, shared_option,
                                           entry_point))
        # Maybe we should also append -mthreads, but then the finished
        # dlls need another dll (mingwm10.dll see Mingw32 docs)
        # (-mthreads: Support thread-safe exception handling on `Mingw32')

        # no additional libraries needed
        self.dll_libraries=[]

        # Include the appropriate MSVC runtime library if Python was built
        # with MSVC 7.0 or later.
        self.dll_libraries = get_msvcr()

# Because these compilers aren't configured in Python's pyconfig.h file by
# default, we should at least warn the user if he is using an unmodified
# version.

CONFIG_H_OK = "ok"
CONFIG_H_NOTOK = "not ok"
CONFIG_H_UNCERTAIN = "uncertain"

def check_config_h():
    """Check if the current Python installation appears amenable to building
    extensions with GCC.

    Returns a tuple (status, details), where 'status' is one of the following
    constants:

    - CONFIG_H_OK: all is well, go ahead and compile
    - CONFIG_H_NOTOK: doesn't look good
    - CONFIG_H_UNCERTAIN: not sure -- unable to read pyconfig.h

    'details' is a human-readable string explaining the situation.

    Note there are two ways to conclude "OK": either 'sys.version' contains
    the string "GCC" (implying that this Python was built with GCC), or the
    installed "pyconfig.h" contains the string "__GNUC__".
    """

    # XXX since this function also checks sys.version, it's not strictly a
    # "pyconfig.h" check -- should probably be renamed...

    from distutils import sysconfig

    # if sys.version contains GCC then python was compiled with GCC, and the
    # pyconfig.h file should be OK
    if "GCC" in sys.version:
        return CONFIG_H_OK, "sys.version mentions 'GCC'"

    # let's see if __GNUC__ is mentioned in python.h
    fn = sysconfig.get_config_h_filename()
    try:
        config_h = open(fn)
        try:
            if "__GNUC__" in config_h.read():
                return CONFIG_H_OK, "'%s' mentions '__GNUC__'" % fn
            else:
                return CONFIG_H_NOTOK, "'%s' does not mention '__GNUC__'" % fn
        finally:
            config_h.close()
    except OSError as exc:
        return (CONFIG_H_UNCERTAIN,
                "couldn't read '%s': %s" % (fn, exc.strerror))

RE_VERSION = re.compile(br'(\d+\.\d+(\.\d+)*)')

def _find_exe_version(cmd):
    """Find the version of an executable by running `cmd` in the shell.

    If the command is not found, or the output does not match
    `RE_VERSION`, returns None.
    """
    executable = cmd.split()[0]
    if find_executable(executable) is None:
        return None
    out = Popen(cmd, shell=True, stdout=PIPE).stdout
    try:
        out_string = out.read()
    finally:
        out.close()
    result = RE_VERSION.search(out_string)
    if result is None:
        return None
    # LooseVersion works with strings
    # so we need to decode our bytes
    return LooseVersion(result.group(1).decode())

def get_versions():
    """ Try to find out the versions of gcc, ld and dllwrap.

    If not possible it returns None for it.
    """
    commands = ['gcc -dumpversion', 'ld -v', 'dllwrap --version']
    return tuple([_find_exe_version(cmd) for cmd in commands])

def is_cygwingcc():
    '''Try to determine if the gcc that would be used is from cygwin.'''
    out_string = check_output(['gcc', '-dumpmachine'])
    return out_string.strip().endswith(b'cygwin')
</pre>
<h4><span>pyconfig.h 修改</span></h4>
<p><span>p37\include\pyconfig.h 檔案第 84 行:</span></p>
<pre class="brush:cpp;auto-links:false;toolbar:false" contenteditable="false">#ifdef _MSC_VER</pre>
<p>之前插入三行, 成為:</p>
<pre class="brush:cpp;auto-links:false;toolbar:false" contenteditable="false">#ifdef _WIN64
#define MS_WIN64
#endif
#ifdef _MSC_VER</pre>
<p>並且將</p>
<pre class="brush:cpp;auto-links:false;toolbar:false" contenteditable="false">#define COMPILER "[gcc]"
#define hypot _hypot</pre>
<p>改為</p>
<pre class="brush:cpp;auto-links:false;toolbar:false" contenteditable="false">#define COMPILER "[gcc]"
#ifndef _MATH_H_
#define hypot _hypot
#endif</pre>
<h4>增加 distutils.cfg 檔案</h4>
<p>在 p37\Lib\distutils 目錄中新增 distutils.cfg</p>
<p>內容為</p>
<pre class="brush:js;auto-links:false;toolbar:false" contenteditable="false">[build]
compiler=mingw32</pre>
<h4>修改 _advapi32.py 檔案</h4>
<p>修改 p37\Lib\site-packages\win32ctypes\core\cffi\_advapi32.py</p>
<p>蓋掉第 197 與 199 行</p>
<pre class="brush:cpp;auto-links:false;toolbar:false" contenteditable="false">#c_creds.CredentialBlobSize = \

    #ffi.sizeof(blob_data) - ffi.sizeof('wchar_t')</pre>
<p></p><h2>Ubuntu 開發</h2>
<p>安裝 python3-dev 與 swig 套件：</p>
<pre class="brush:html;auto-links:false;toolbar:false" contenteditable="false">sudo apt update
sudo apt install python3-dev swig</pre>
<p>取得 Pyslvs 原始碼：</p>
<pre class="brush:html;toolbar:false" contenteditable="false">git clone --recurse-submodules https://github.com/KmolYuan/Pyslvs-PyQt5</pre>
<p>安裝需要的 Python 模組：</p>
<pre class="brush:html;auto-links:false;toolbar:false" contenteditable="false">sudo pip3 install -r requirement.txt</pre>
<p>完整編譯：</p>
<pre class="brush:html;auto-links:false;toolbar:false" contenteditable="false">make</pre>
<p>可以在倉儲目錄下的 out 資料夾中取得 AppImage 可執行檔。</p>
<p>編譯核心：</p>
<pre class="brush:html;auto-links:false;toolbar:false" contenteditable="false"># 所有程式庫
make build-kernel

# Pyslvs 程式庫
make build-pyslvs

# Python-Solvespace 程式庫
make build-solvespace</pre>
<p>執行腳本：</p>
<pre class="brush:html;auto-links:false;toolbar:false" contenteditable="false">python3 launch_pyslvs.py</pre><h2>Mac OS X 開發</h2>
<p>建議使用 <a href="https://brew.sh/index_zh-tw">Homebrew</a> 套件管理工具。</p>
<p>安裝 Python 與 SWIG：</p>
<pre class="brush:html;auto-links:false;toolbar:false" contenteditable="false">brew install python@3
brew install swig</pre>
<p>安裝需要的 Python 模組：</p>
<pre class="brush:html;auto-links:false;toolbar:false" contenteditable="false">pip3 install -r requirement.txt

# 安裝 PyInstaller 打包成執行檔
pip3 install pyinstaller</pre>
<p>完整編譯：</p>
<pre class="brush:html;auto-links:false;toolbar:false" contenteditable="false">make</pre>
<p>可以在倉儲目錄下的 dist 資料夾中取得 app 與 unix-style 可執行檔。</p>
<p>編譯核心：</p>
<pre class="brush:html;auto-links:false;toolbar:false" contenteditable="false"># 所有程式庫
make build-kernel
 
# Pyslvs 程式庫
make build-pyslvs
 
# Python-Solvespace 程式庫
make build-solvespace</pre>
<p>執行腳本：</p>
<pre class="brush:html;auto-links:false;toolbar:false" contenteditable="false">python3 launch_pyslvs.py</pre>
<p></p><h1>參考</h1>
<p><a href="https://www.researchgate.net/profile/Jing-Shan_Zhao/publication/265747246_Design_of_Special_Planar_Linkages/links/55fc02db08ae07629e07d546/Design-of-Special-Planar-Linkages.pdf">Design of special planar linkages.pdf</a></p>
<p><a href="https://designengrlab.github.io/PMKS/">https://designengrlab.github.io/PMKS/</a> </p>
<p><a href="https://github.com/DesignEngrLab/PMKS">https://github.com/DesignEngrLab/PMKS</a> </p>
<p><a href="/downloads/Automated+Generation+of+Linkage+Loop+Equations+for+Planar+One+Degree-of-Freedom+Linkages,+Demonstrated+up+to+8-Bar.pdf">Automated Generation of Linkage Loop Equations for Planar One Degree-of-Freedom Linkages up to 8-Bar.pdf</a></p>
<p><a href="/downloads/Computer+Aided+Design+of+Eight-bar+Linkages.pdf">Computer Aided Design of Eight-bar Linkages.pdf</a></p>
<p><a href="/downloads/Implementation%20of an Open Source Planar Linkage Mechanism Simulation and Dimensional Synthesis System.pdf">Implementation of an Open Source Planar Linkage Mechanism Simulation and Dimensional Synthesis System.pdf</a></p>
<h4>自動拓樸結構合成</h4>
<p style="padding-left: 30px;"><a href="https://link.springer.com/chapter/10.1007/978-981-10-2875-5_74">Automatic Synthesis of Planar Simple Joint Kinematic Chains by Single Kinematic Chain Adding Method</a></p>
<h4>機構類型合成</h4>
<p style="padding-left: 30px;"><a href="https://cimec.org.ar/ojs/index.php/mc/article/viewFile/170/154">TYPE SYNTHESIS OF PLANAR LINKAGE MECHANISMS WITH ROTOIDAL AND PRISMATIC JOINTS</a></p>
<h4>網際連桿合成</h4>
<p style="padding-left: 30px;"><a href="https://link.springer.com/content/pdf/10.1007%2F978-1-4020-2212-8_65.pdf">A WEB-BASED OPTIMIZATION FOR FUNCTION SYNTHESIS OF PLANAR LINKAGE</a></p>
<h4>機構尺寸合成</h4>
<p style="padding-left: 30px;"><a href="https://link.springer.com/content/pdf/10.1007%2F978-94-007-4902-3_29.pdf">Dimensional Synthesis of Six-Bar Linkage as a Constrained RPR Chain</a></p>
<h4>C++ 程式轉為 Python 動態程式庫</h4>
<p style="padding-left: 30px;"><a href="https://github.com/pyslvs/pyslvs.github.io/files/2441549/AutoWIG.-.automatic.generation.of.python.bindings.for.Cpp.libraries.pdf">AutoWIG - automatic generation of python bindings for Cpp libraries.pdf</a><br/><a href="https://github.com/StatisKit/AutoWIG">https://github.com/StatisKit/AutoWIG</a></p>
<h4>其他</h4>
<p style="padding-left: 30px;">1990:<span> </span><a href="https://www.sciencedirect.com/science/article/pii/089571779090069Y" rel="nofollow">Number synthesis of kinematic chains based on permutation groups</a></p>
<p style="padding-left: 30px;">1995:<span> </span><a href="http://www.airitilibrary.com/Publication/alDetailedMesh?DocID=10217940-199512-201306050024-201306050024-1-8" rel="nofollow">Structural Synthesis of Mechanisms</a></p>
<p style="padding-left: 30px;">2007:<span> </span><a href="https://www.sciencedirect.com/science/article/pii/S0094114X06002205" rel="nofollow">A new theory for the topological structure analysis of kinematic chains and its applications</a></p>
<p style="padding-left: 30px;">2008:<span> </span><a href="https://www.sciencedirect.com/science/article/pii/S0094114X08000025" rel="nofollow">Computer-aided structure decomposition theory of kinematic chains and its applications</a></p>
<p style="padding-left: 30px;">2012:<span> </span><a href="https://www.sciencedirect.com/science/article/pii/S0094114X11001728" rel="nofollow">Synthesis of the whole family of planar 1-DOF kinematic chains and creation of their atlas database</a></p>
<p style="padding-left: 30px;">2013:<span> </span><a href="https://www.sciencedirect.com/science/article/pii/S0094114X13000852" rel="nofollow">Automated sketching of non-fractionated kinematic chains</a></p>
<p style="padding-left: 30px;">2014:<span> </span><a href="http://www.airitilibrary.com/Publication/alDetailedMesh1?DocID=U0026-2107201416312200" rel="nofollow">一般化運動鏈之數目合成</a></p>
<p style="padding-left: 30px;">2015:<span> </span><a href="https://www.sciencedirect.com/science/article/pii/S0094114X14002092" rel="nofollow">On the number synthesis of kinematic chains</a></p>
<p style="padding-left: 30px;">2015:<span> </span><a href="https://github.com/pyslvs/pyslvs.github.io/files/2452934/Automatic_Structural_Synthesis_of_Planar_Mechanisms_and_Its_Application_to_Creative_Design.pdf">Automatic_Structural_Synthesis_of_Planar_Mechanisms_and_Its_Application_to_Creative_Design.pdf</a></p>
<p style="padding-left: 30px;">2016:<span> </span><a href="https://www.sciencedirect.com/science/article/pii/S0094114X15002207" rel="nofollow">Automatic generation of the complete set of planar kinematic chains with up to six independent loops and up to 19 links</a></p>
<p style="padding-left: 30px;">2017:<span> </span><a href="https://www.sciencedirect.com/science/article/pii/S0094114X16303561" rel="nofollow">An automatic method for the connectivity calculation in planar closed kinematic chains</a></p>
<p style="padding-left: 30px;">2018:<span> </span><a href="https://www.sciencedirect.com/science/article/pii/S0094114X17316932" rel="nofollow">A new atlas for 8-bar kinematic chains with up to 3 prismatic pairs using Joint Sorting Code</a></p>
<p style="padding-left: 30px;">2018:<span> </span><a href="https://www.sciencedirect.com/science/article/pii/S0094114X17311126" rel="nofollow">A new method for the automatic sketching of planar kinematic chains</a></p>
<h4>CAD</h4>
<p style="padding-left: 30px;"><a href="https://freecadweb.org/">https://freecadweb.org/</a> </p>
<p style="padding-left: 30px;"><a href="https://www.blender.org/">https://www.blender.org/</a> </p>
<p style="padding-left: 30px;"><a href="https://github.com/tpaviot/oce">https://github.com/tpaviot/oce</a> </p>
<p style="padding-left: 30px;"><a href="https://github.com/LaughlinResearch/pyOCCT">https://github.com/LaughlinResearch/pyOCCT</a> </p>
<p></p>
<p></p><h2>Misc</h2>
<p><a href="https://www.iacr.org/archive/asiacrypt2003/08_invited_talk/28940325.pdf">The Secret and Beauty of Ancient Chinese Padlocks.pdf</a></p>
<p><iframe allowfullscreen="allowfullscreen" height="314" src="//www.youtube.com/embed/aZ02DvXHa6k" width="560"></iframe></p>
<p><iframe allowfullscreen="allowfullscreen" height="314" src="//www.youtube.com/embed/gCKc8OP9Azc" width="560"></iframe></p>
<p><iframe allowfullscreen="allowfullscreen" height="314" src="//www.youtube.com/embed/9iUjxXJrUcY" width="560"></iframe></p>
<p><iframe allowfullscreen="allowfullscreen" height="314" src="//www.youtube.com/embed/lRh2sUp0jcQ" width="560"></iframe></p>
<p></p>
<pre class="lang-bsh prettyprint prettyprinted"><code><span class="pln"></span></code></pre>