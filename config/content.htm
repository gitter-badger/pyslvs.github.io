<h1>簡介</h1>
<p><a href="https://github.com/KmolYuan/Pyslvs-PyQt5">Pyslvs</a> 是一套利用 Python 3 與 PyQt5 建立的平面機構模擬與合成系統.&nbsp; 機構模擬與合成的主要核心包括&nbsp;<a href="https://github.com/KmolYuan/python-solvespace">Python-Solvespace</a>&nbsp;幾何約束求解程式庫、<a href="https://github.com/KmolYuan/pyslvs/blob/master/src/tinycadlib.pyx">tinycadlib</a> 三角幾何函式程式庫、<a href="https://github.com/KmolYuan/Adesign">ADesign</a> 演算程式庫、<a href="https://github.com/KmolYuan/pyslvs/blob/master/src/bfgs.pyx">bgfs</a> 幾何約束求解程式庫、<a href="https://github.com/KmolYuan/pyslvs/blob/master/src/topologic.pyx">topologic</a>&nbsp;類型合成程式庫、<a href="https://github.com/KmolYuan/pyslvs/blob/master/src/number.pyx">number</a> 數目合成程式庫等.</p>
<p>其中, <a href="https://github.com/KmolYuan/Adesign">ADesign</a> 演算程式庫包含 Real-coded Genetic Algorithm (<a href="https://github.com/KmolYuan/Adesign/blob/master/src/rga.pyx">RGA</a>)、Differential Evolution (<a href="https://github.com/KmolYuan/Adesign/blob/master/src/de.pyx">DE</a>) 與 Firefly Algorithm (<a href="https://github.com/KmolYuan/Adesign/blob/master/src/firefly.pyx">Firefly</a>) 等三種, 用於平面機構尺寸合成演算.</p>
<h4>源起</h4>
<p><a href="https://github.com/KmolYuan/Pyslvs-PyQt5">Pyslvs</a> 的開發源自 2008 年, 從最基本的實數基因演算法在平面機構的應用研究起步, 期間歷經下列研究者的貢獻:</p>
<ol>
<li>李孟恭, 2015, <a href="https://hdl.handle.net/11296/tur9hu">Django 網際框架在平面四連桿尺寸合成系統上的應用</a></li>
<li>李玠廷, 2013, <a href="https://hdl.handle.net/11296/mtf789">網際程式框架在平面連桿機構尺寸合成系統上的應用</a></li>
<li>陳威任, 2013, 符號式平面滑塊機構應用研究</li>
<li>謝政良, 2012, <a href="https://hdl.handle.net/11296/h5z5sb">網際雙自由度凸輪機構尺寸合成系統</a></li>
<li>黃竣鉉, 2012, <a href="https://hdl.handle.net/11296/a5b4p7">網際符號輔助軸接連桿機構之基因演算法尺寸合成系統</a></li>
<li>謝智翔, 2012, <a href="https://hdl.handle.net/11296/v9mr92">網際史都華平台機構逆運動學分析與模擬</a></li>
<li>許哲菘, 2010, <a href="https://hdl.handle.net/11296/w66tpa">網際六軸機械臂系統的逆運動學分析與模擬</a></li>
<li>葉岱錦, 2009, <a href="https://hdl.handle.net/11296/tt6672">基因演算法在網際機構合成系統上的應用</a></li>
</ol>
<p>過程中, 於 2015 年由<a href="https://github.com/kmollee">李孟恭</a>整合上述論文所開發的三種演算法, 完成 <a href="http://cython.org/">Cython</a> 格式的 <a href="https://github.com/kmollee/algorithm/blob/master/rga.pyx">RGA</a>、<a href="https://github.com/kmollee/algorithm/blob/master/de.pyx">DE</a> 與 <a href="https://github.com/kmollee/algorithm/blob/master/firefly.pyx">Firefly</a> 演算法程式庫後. 並自 2016 年起由<a href="https://github.com/KmolYuan">張元</a>將上述尺寸合成演算法, 搭配利用&nbsp; <a href="http://www.swig.org/">SWIG</a> 技術, 將原本只能用於 Python 2 的 <a href="https://github.com/BBBSnowball/python-solvespace">Python-Solvespace</a> 倉儲, 改寫為能結合 PyQt5 圖形介面使用的 <a href="https://github.com/KmolYuan/python-solvespace">Python-Solvespace</a> 程式庫作為另一項開端. 再搭配平面機構中的數目合成與類型合成等程式庫後, 成為目前的 <a href="https://github.com/KmolYuan/Pyslvs-PyQt5">Pyslvs</a> 平面機構模擬與合成套件.</p>
<h4>Pyslvs 開發紀要</h4>
<p>2015 年 4 月 - 由<a href="https://github.com/kmollee">李孟恭</a>以 <a href="http://cython.org/">Cython</a> 技術, 完成三個<a href="https://github.com/kmollee/algorithm">尺寸合成演算法</a>程式庫.</p>
<p>2016 年 7 月 - 由<a href="https://github.com/KmolYuan">張元</a>完成 Python 3 格式的 <a href="https://github.com/KmolYuan/python-solvespace">Python-Solvespace</a> 程式庫.</p>
<p>2016 年 12 月- 由<a href="https://github.com/KmolYuan">張元</a>結合 PyQt5 與演算程式庫, 完成第一代 <a href="https://github.com/KmolYuan/Pyslvs-PyQt5">Pyslvs</a> 套件.</p>
<p>2017 年 11 月 - <a href="http://pyslvs.com">http://pyslvs.com</a>&nbsp;上線.</p>
<p>2018 年 1 月 - 推出 <a href="https://github.com/KmolYuan/Pyslvs-PyQt5">Pyslvs</a> 18.01&nbsp; 版, 自此改為以年月序作為版次.</p>
<p>2018 年 7 月 -&nbsp;<a href="http://pyslvs.com/content/">http://pyslvs.com/content/</a>&nbsp;使用手冊上線.</p>
<p></p>
<h2>機構與機器</h2>
<h4>機構 (Mechanism)</h4>
<p>機構是由剛體 (Rigid) 或撓性 (Flexible) 體機械元件所組成, 這些元件透過接頭 (Joint) 連接, 並以特定的運動相互移動.</p>
<h4>機器 (Machine)</h4>
<p>機器是由機構或機構的集合所組成, 能將力從動力源傳遞到預計要施加之元件上.</p>
<p>換言之, 機器是由剛性元件或撓性元件所組合而成,&nbsp;能將力從動力源傳遞到預計要施加之元件上.</p>
<p>機器具有兩個功能: 傳遞確定的相對運動和傳遞力.&nbsp; 這些功能需要足夠強度與剛性來傳遞力.</p>
<p>若機構中所有的機件皆為連桿, 且所有的接頭皆為旋轉對, 則這個機構特稱為連 (Linkage).</p><h2>Pyslvs 介面</h2>
<p><img src="/images/pyslvs-18.7.0-screenshot.png" width="600" height="524" alt=""></p>
<p>Pyslvs 主畫面的上方為功能表列 (Menu bar), 右側為畫布 (Canvas), 左方則有各式功能的分頁欄 (Tab widgets).</p>
<p>功能表列涵蓋大部分的功能, 其中部分有關各項目的細部操作, 則必須在對應的分頁欄中選取或設定.&nbsp;</p>
<h4>Mechanism 分頁</h4>
<p>Pyslvs 左側中的 Mechanism 子頁面, 主要用於輸入機構關鍵點與運動連桿, 使用時以滑鼠點選 Mechanism 頁面後, 可在右方工作區, 以滑鼠輸入機構關鍵點與運動連桿.</p>
<h4>Inputs&nbsp;分頁</h4>
<p>Pyslvs 的 Inputs 子頁面用於宣告機構的主動軸, 並進行運動模擬.</p>
<h4>Synthesis&nbsp;分頁</h4>
<p>Pyslvs 的 Synthesis 子頁面用於進行平面機構的結構合成與尺寸合成.</p>
<h4>功能表列 (Menu bar)</h4>
<p>功能表列中根據不同的功能分類如下:</p>
<p>檔案 (File)</p>
<p>建立新的工作簿、開啟既有的工作簿、參考範例, 以及不同檔案格式的匯入與匯出功能.</p>
<p>編輯 (Edit)</p>
<p>復原與重做功能.&nbsp;</p>
<p>選項 (Options)</p>
<p>檢視方式調整以及工作簿相關資訊.</p>
<p>說明 (Help)</p>
<p>與 Pyslvs 相關網站與套件資訊.</p>
<h4>快捷鍵</h4>
<p>F1 - 有關 Pyslvs</p>
<p>Shift + F1 - Toggle 全螢幕</p>
<p></p><h1>操作</h1>
<p>Pyslvs 開啟 Crank-Rocker 機構畫面, under Mechanism 頁面:</p>
<p><img src="/images/crank_rocker-18.7.0.png" width="600" height="338" alt=""></p>
<p>Crank-Rocker under Inputs 頁面:</p>
<p><img src="/images/crank_rocker_inputs-18.7.0.png" width="600" height="338" alt=""></p>
<p>Crank-Rocker 通過特定點尺寸合成畫面1:</p>
<p><img src="/images/crank_rocker_dimensional_synthesis1.png" width="600" height="338" alt=""></p>
<p>完成 1000 代 DE 演算法之後的結果畫面:</p>
<p><img src="/images/crank_rocker_dimensional_synthesis2.png" width="600" height="338" alt=""></p>
<h2>模擬操作</h2>
<p>Pyslvs 的模擬操作主要牽涉 Mechanism 與 Inputs 分頁, Mechanism 分頁用於定義機構各節點與連桿, 而 Inputs 分頁則可用來定義主動旋轉軸, 並利用自動或手動模式進行合理平面機構的運動模擬.</p><h3>曲柄滑塊</h3>
<p>File -&gt; New Workbook</p>
<p>選擇左側 Mechanism 子頁面.</p>
<h4>建立固定點與移動點</h4>
<p>利用滑鼠在右側畫布區, 按住滑鼠右鍵輸入兩個固定點與一個可運動點.</p>
<h4>建立連桿</h4>
<p>將其中一個固定點轉為滑塊, 即將 point2 之類型 (type) 由 pin 轉為 pin in slot, 採內建水平滑動面, 或更改滑動面的對應角度.</p>
<p>在 Mechanism 完成機構定義後, 轉到 Inputs 子頁面, 定義 Driver point 後進行曲柄滑塊的運動模擬.</p>
<h3>四連桿</h3>
<p>在 Mechanism 子頁面定義兩個固定點與兩個移動點後, 建立三根可運動連桿.</p>
<p>接著進入 Inputs 頁面, 定義 driver points 後進行基本運動模擬.</p>
<h2>尺寸合成操作</h2>
<p>Pyslvs 的尺寸合成功能, 主要依賴&nbsp;<a href="https://github.com/KmolYuan/pyslvs/blob/master/src/tinycadlib.pyx">tinycadlib</a><span>&nbsp;三角幾何函式程式庫與&nbsp;</span><a href="https://github.com/KmolYuan/Adesign">ADesign</a><span>&nbsp;演算程式庫, 其中各平面機構範例進行尺寸合成的第一步必須先以三角幾何函式程式庫進行配置後, 再輸入特定機構節點所要通過的運行點座標, 最後再選擇 <a href="https://github.com/KmolYuan/Adesign">ADesign</a>&nbsp;演算程式庫中的 Real-coded Genetic Algorithm (<a href="https://github.com/KmolYuan/Adesign/blob/master/src/rga.pyx">RGA</a>)、Differential Evolution (<a href="https://github.com/KmolYuan/Adesign/blob/master/src/de.pyx">DE</a>) 或 Firefly Algorithm (<a href="https://github.com/KmolYuan/Adesign/blob/master/src/firefly.pyx">Firefly</a>) 演算法進行尺寸合成運算.</span></p><h2>結構合成操作</h2>
<p>Pyslvs 的結構合成包括平面機構的數目合成與類型合成等兩部分.</p>
<p>在數目合成階段, 使用者可以選擇連桿個數 (Link number)、接頭個數 (Joint number), 以及機構的自由度.</p><h1>下載</h1>
<p>利用 pyslvs At mde 登錄 Gdrive 提供各版次下載.</p>
<p>Windows 64 位元操作系統:</p>
<p><a href="https://drive.google.com/file/d/1YdgFsFwFMmYvB0wi56OInl-0crUJPFlh/view?usp=sharing">pyslvs-18.7.0.mscv1900-amd64.exe</a> (53446 KB)</p>
<p><a href="https://drive.google.com/file/d/1VZ9uW1lWkZyYBpxDBqCjBii1aGdHPTKj/view?usp=sharing">pyslvs-18.8.0.mscv1900-amd64.exe</a> (53458 KB)</p><h1>範例</h1>
<p>展示利用 Pyslvs 解題</p>
<p>參考資料:</p>
<p>1977 -&nbsp;<a href="https://theses.ncl.ac.uk/dspace/bitstream/10443/567/1/Oldham77.pdf">THE KINEMATICS AND VIBRATION OF PLANAR LINKAGE MECHANISMS</a></p>
<p><a href="https://www.researchgate.net/publication/304782762_MeKin2D_Suite_for_Planar_Mechanism_Kinematics">MeKin2d</a></p>
<p><a href="https://www.amazon.com/Machines-Mechanisms-Applied-Kinematic-Analysis/dp/0132157802">MACHINES AND MECHANISMS APPLIED KINEMATIC ANALYSIS Fourth Edition by David H. Myszka</a></p>
<p><a href="https://books.google.com.tw/books?id=0A1mDwAAQBAJ&amp;pg=PP1&amp;lpg=PP1&amp;dq=Introduction+to+Mechanism+Design:+with+Computer+Applications&amp;source=bl&amp;ots=WakYIZ-L93&amp;sig=tSRFX6Z9fhaT3Lzk3USgSb05PXA&amp;hl=en&amp;sa=X&amp;ved=2ahUKEwiPqeP4-sPcAhVHFYgKHbE_Ae4Q6AEwBHoECAUQAQ#v=onepage&amp;q=Introduction%20to%20Mechanism%20Design%3A%20with%20Computer%20Applications">Introduction to Mechanism Design: with Computer Applications by By Eric Constans and Karl B. Dyer</a></p>
<p><a href="https://www.amazon.com/Theory-Machines-Mechanisms-John-Uicker/dp/0195371232">THEORY OF MACHINES AND MECHANISMS Fourth Edition by John Uicker, Gordon Pennock and&nbsp; Joseph Shigley</a></p>
<p></p>
<p></p>
<h2>模擬範例</h2>
<p><img src="/images/sam_sixbar.png" width="800" height="450" alt=""></p>
<p><img src="/images/sam_sixbar-18.7.png" width="800" height="450" alt=""></p>
<p><img src="/images/sixbar_r_slider.png" width="560" height="315" alt=""></p>
<p><a href="/downloads/sixbar_r_with_slider.pyslvs">sixbar_r_slider.pyslvs</a> (18.8.0 version)</p>
<p><iframe width="560" height="315" src="https://www.youtube.com/embed/aBEfsdOycC8" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen="allowfullscreen"></iframe></p>
<h4>建立六連桿機構模型</h4>
<p><iframe width="560" height="315" src="https://www.youtube.com/embed/1BcjhYgvQtY" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen="allowfullscreen"></iframe></p>
<h4>八連桿機構</h4>
<p><a href="/downloads/eight_bar1.pyslvs">eightbar1.pyslvs</a></p>
<p><img src="/images/eightbar1.png" width="600" height="322" alt=""></p><h2>尺寸合成範例</h2>
<h2>結構合成範例</h2>
<h2>產品設計範例</h2>
<h4>健步機</h4>
<p><a href="/downloads/2014_nsysu_design_linkage_type_foot_exercise_machine.pdf">連桿式健步機設計.pdf</a></p>
<p><a href="/downloads/sixbar_foot_exercise_machine.pyslvs">sixbar_foot_exercise_machine.pyslvs</a></p>
<p><img src="/images/sixbar_foot_exercise_machine.png" width="600" height="338" alt=""></p>
<h4>汽車雨刷</h4>
<p><a href="/downloads/windshield_design1.pyslvs">windshield_design1.pyslvs</a></p>
<p><img src="/images/windshield_design1.png" width="600" height="338" alt=""></p>
<h4>汽車引擎蓋</h4>
<p><a href="/downloads/automobile_hood1.pyslvs">automobile_hood1.pyslvs</a></p>
<p><img src="/images/automobile_hood1.png" width="600" height="322" alt=""></p>
<p></p>
<p></p><h1>開發</h1>
<p>以 Eric6 IDE 開啟 Pyslvs 專案:</p>
<p><img src="/images/pyslvs_under_eric6.png" width="600" height="338" alt=""></p><h2>Windows 開發</h2>
<p>下載 <a href="https://drive.google.com/file/d/12BLN4daAPlO1KjCTDFi1kqJZ6f5k7Y5k/view?usp=sharing">Qt 可攜程式開發套件.7z&nbsp;</a> (下載檔案約 8GB, 解開壓縮後約 21GB)</p>
<p>執行 start.bat</p>
<p>取得 Pyslvs 原始碼:</p>
<pre class="brush:js;auto-links:false;toolbar:false" contenteditable="false">git clone --recurse-submodules https://github.com/KmolYuan/Pyslvs-PyQt5</pre>
<h4>編譯 GUI 套件:</h4>
<p>進入 Pyslvs-PyQt5 目錄後, 執行:</p>
<pre class="brush:js;auto-links:false;toolbar:false" contenteditable="false">mingw32-make clean
mingw32-make</pre>
<p>完成後, 以 2018.07 版次為例, dist 目錄中將得到可執行檔案:</p>
<pre class="brush:js;auto-links:false;toolbar:false" contenteditable="false">pyslvs-18.7.0.mscv1900-amd64.exe</pre>
<h4>編譯 no GUI 程式庫:</h4>
<p>在命令列中更換目錄至 core\libs\pyslvs 後, 執行:</p>
<pre class="brush:js;auto-links:false;toolbar:false" contenteditable="false">mingw32-make clean
mingw32-make</pre>
<p>建立下列動態連結程式庫 (pyd):</p>
<pre class="brush:js;auto-links:false;toolbar:false" contenteditable="false">bfgs.cp36-win_amd64.pyd
de.cp36-win_amd64.pyd
firefly.cp36-win_amd64.pyd
number.cp36-win_amd64.pyd
planarlinkage.cp36-win_amd64.pyd
pmks.cp36-win_amd64.pyd
rga.cp36-win_amd64.pyd
tinycadlib.cp36-win_amd64.pyd
topologic.cp36-win_amd64.pyd
triangulation.cp36-win_amd64.pyd
verify.cp36-win_amd64.pyd</pre>
<p>位於 pyslvs 目錄中的 unittest 程式:</p>
<pre class="brush:py;auto-links:false;toolbar:false" contenteditable="false"># -*- coding: utf-8 -*-

"""This module will test the functions of Pyslvs."""

__author__ = "Yuan Chang"
__copyright__ = "Copyright (C) 2016-2018"
__license__ = "AGPL"
__email__ = "pyslvs@gmail.com"

import unittest
from unittest import TestCase
from typing import Tuple, List

#For necessary testing modules.
from math import sqrt, radians, isclose
from pmks import VPoint
import bfgs
from tinycadlib import (
    Coordinate,
    PLAP,
    PLLP,
    PLPP,
    PXY,
    expr_solving,
    data_collecting,
)
from planarlinkage import Planar
from rga import Genetic
from firefly import Firefly
from de import DiffertialEvolution
from number import number_synthesis
from topologic import topo, Graph
from triangulation import vpoints_configure
from _parser import parse_vpoints
from examples import example_list


class CoreTest(TestCase):
    
    """Testing Cython libs."""
    
    def vpoints_object(self) -&gt; Tuple[List[VPoint], Tuple[Tuple[int, int]]]:
        """Example: Jansen's linkage (Single)."""
        expr, inputs = example_list["Jansen's linkage (Single)"]
        return parse_vpoints(expr), inputs
    
    def planar_object(self) -&gt; Planar:
        """Test-used mechanism for algorithm."""
        return Planar({
            'Driver': {'P0': (-70, -70, 50)},
            'Follower': {'P1': (70, -70, 50)},
            'Target': {'P4': [
                (60.3, 118.12),
                (31.02, 115.62),
                (3.52, 110.62),
                (-25.77, 104.91),
                (-81.49, 69.19),
                (-96.47, 54.906),
                (-109.34, 35.98),
                (-121.84, 13.83),
                (-127.56, -20.09),
                (-128.63, -49.74),
                (-117.56, -65.45),
            ]},
            'Expression': "PLAP[P0,L0,a0](P2);" +
                "PLLP[P2,L1,L2,P1](P3);" +
                "PLLP[P2,L3,L4,P3](P4)",
            'constraint': [('P0', 'P1', 'P2', 'P3')],
            'upper': [100., 100., 100., 100., 100., 360.],
            'lower': [5., 5., 5., 5., 5., 0.],
        })
    
    def test_plap(self):
        """Test for PLAP function."""
        A = Coordinate(0, 0)
        B = Coordinate(50, 0)
        x, y = PLAP(A, 50 * sqrt(2), radians(45), B)
        self.assertTrue(isclose(x, 50))
        self.assertTrue(isclose(y, 50))
    
    def test_pllp(self):
        """Test for PLLP function."""
        A = Coordinate(-30, 0)
        B = Coordinate(30, 0)
        x, y = PLLP(A, 50, 50, B)
        self.assertTrue(isclose(x, 0))
        self.assertTrue(isclose(y, 40))
        x, y = PLLP(A, 30, 30, B)
        self.assertTrue(isclose(x, 0))
        self.assertTrue(isclose(y, 0))
        x, y = PLLP(A, 90, 30, B)
        self.assertTrue(isclose(x, 60))
        self.assertTrue(isclose(y, 0))
    
    def test_plpp(self):
        """Test for PLPP function."""
        A = Coordinate(0, 0)
        B = Coordinate(0, -3)
        C = Coordinate(3/2, 0)
        x, y = PLPP(A, sqrt(5), B, C)
        self.assertTrue(isclose(x, 2))
        self.assertTrue(isclose(y, 1))
    
    def test_pxy(self):
        A = Coordinate(80, 90)
        x, y = PXY(A, 40, -20)
        self.assertTrue(isclose(x, 120))
        self.assertTrue(isclose(y, 70))
    
    def test_topologic(self):
        """Testing 'topologic' libraries.
        
        + 'topo' function.
        + 'Graph' class.
        """
        G = Graph([(0, 1), (0, 4), (1, 5), (2, 3), (2, 4), (3, 5), (4, 5)])
        H = Graph([(0, 2), (0, 4), (1, 3), (1, 4), (2, 5), (3, 5), (4, 5)])
        I = Graph([(0, 1), (0, 2), (1, 4), (2, 5), (3, 4), (3, 5), (4, 5)])
        self.assertTrue(G.is_isomorphic(H))
        self.assertFalse(G.is_isomorphic(I))
        answer, time = topo([4, 2], degenerate=True)
        self.assertEqual(len(answer), 2)
    
    def test_solving(self):
        """Test triangular formula solving.
        
        + Test for PMKS parser.
        + Test data collecting function.
        + Test expression solving function.
        """
        vpoints, inputs = self.vpoints_object()
        self.assertTrue(len(vpoints) == 8)
        exprs = vpoints_configure(vpoints, inputs)
        mapping = {n: 'P{}'.format(n) for n in range(len(vpoints))}
        data_dict, dof = data_collecting(exprs, mapping, vpoints)
        for link, link_length in (
            ('L0', 15.002083188677497),
            ('L1', 41.50187586121861),
            ('L2', 49.9949057404852),
            ('L3', 40.09650982317538),
            ('L4', 55.80253220060896),
            ('L5', 61.90525179659639),
            ('L6', 39.302800154696364),
            ('L7', 36.69767567571548),
            ('L8', 39.395233214184685),
            ('L9', 48.995886562037015),
            ('L10', 65.69940106271898),
        ):
            self.assertTrue(isclose(data_dict[link], link_length))
        self.assertEqual(dof, 1)
        result = expr_solving(exprs, mapping, vpoints, [0.])
        x, y = result[-1]
        self.assertTrue(isclose(x, -43.17005515543241))
        self.assertTrue(isclose(y, -91.75322590542523))
    
    def test_bfgs(self):
        """Test Sketch Solve kernel."""
        input_data, output_data, grad_data = bfgs.test_kernel()
        self.assertEqual(input_data[0], (0.0, 0.0))
        self.assertEqual(input_data[1], (5.0, 0.0))
        self.assertEqual(input_data[2], (6.0, 5.0))
        self.assertEqual(input_data[3], (6.0, 5.0))
        self.assertEqual(input_data[4], (30.0, 10.0))
        self.assertTrue(isclose(round(output_data[2][1], 2), 10))
        self.assertTrue(isclose(round(output_data[4][0], 2), 30))
        vpoints, inputs = self.vpoints_object()
        result = bfgs.vpoint_solving(vpoints, [(0, 1, 0.)])
        x, y = result[-1]
        self.assertTrue(isclose(round(x, 2), -43.17))
        self.assertTrue(isclose(round(y, 2), -91.75))
    
    def test_number_synthesis(self):
        """Test Number Synthesis function."""
        for NL, NJ in [(4, 4), (6, 7), (8, 9), (10, 12)]:
            for factors in number_synthesis(NL, NJ):
                count = 0
                for i, factor in enumerate(factors):
                    count += factor * (i + 2)
                self.assertEqual(int(count / 2), NJ)
    
    def test_algorithm_rga(self):
        """Real-coded genetic algorithm."""
        fun1 = Genetic(self.planar_object(), {
            'maxTime': 1, 'report': 10,
            #Genetic
            'nPop': 500,
            'pCross': 0.95,
            'pMute': 0.05,
            'pWin': 0.95,
            'bDelta': 5.,
        })
        fun1.run()
    
    def test_algorithm_firefly(self):
        """Firefly algorithm."""
        fun2 = Firefly(self.planar_object(), {
            'maxTime': 1, 'report': 10,
            #Firefly
            'n': 80,
            'alpha': 0.01,
            'betaMin': 0.2,
            'gamma': 1.,
            'beta0': 1.,
        })
        fun2.run()
    
    def test_algorithm_de(self):
        """Differtial evolution."""
        fun3 = DiffertialEvolution(self.planar_object(), {
            'maxTime': 1, 'report': 10,
            #DE
            'strategy': 1,
            'NP': 400,
            'F': 0.6,
            'CR': 0.9,
        })
        fun3.run()


if __name__ == '__main__':
    unittest.main()
</pre>
<p></p>
<h2>Ubuntu 開發</h2>
<h1>參考</h1><p><a href="https://www.researchgate.net/profile/Jing-Shan_Zhao/publication/265747246_Design_of_Special_Planar_Linkages/links/55fc02db08ae07629e07d546/Design-of-Special-Planar-Linkages.pdf">Design of special planar linkages.pdf</a></p><p><a href="https://designengrlab.github.io/PMKS/">https://designengrlab.github.io/PMKS/</a>&nbsp;</p><p><a href="https://github.com/DesignEngrLab/PMKS">https://github.com/DesignEngrLab/PMKS</a>&nbsp;</p><p><a href="/downloads/Automated+Generation+of+Linkage+Loop+Equations+for+Planar+One+Degree-of-Freedom+Linkages,+Demonstrated+up+to+8-Bar.pdf">Automated Generation of Linkage Loop Equations for Planar One Degree-of-Freedom Linkages up to 8-Bar.pdf</a></p><p><a href="/downloads/Computer+Aided+Design+of+Eight-bar+Linkages.pdf">Computer Aided Design of Eight-bar Linkages.pdf</a></p><p><a href="/downloads/Implementation%20of an Open Source Planar Linkage Mechanism Simulation and Dimensional Synthesis System.pdf">Implementation of an Open Source Planar Linkage Mechanism Simulation and Dimensional Synthesis System.pdf</a></p><h4>自動拓樸結構合成</h4><p><a href="https://link.springer.com/chapter/10.1007/978-981-10-2875-5_74">Automatic Synthesis of Planar Simple Joint Kinematic Chains by Single Kinematic Chain Adding Method</a></p><h4>機構類型合成</h4><p><a href="https://cimec.org.ar/ojs/index.php/mc/article/viewFile/170/154">TYPE SYNTHESIS OF PLANAR LINKAGE MECHANISMS WITH ROTOIDAL AND PRISMATIC JOINTS</a></p><h4>網際連桿合成</h4><p><a href="https://link.springer.com/content/pdf/10.1007%2F978-1-4020-2212-8_65.pdf">A WEB-BASED OPTIMIZATION FOR FUNCTION SYNTHESIS OF PLANAR LINKAGE</a></p><h4>機構尺寸合成</h4><p><a href="https://link.springer.com/content/pdf/10.1007%2F978-94-007-4902-3_29.pdf">Dimensional Synthesis of Six-Bar Linkage as a Constrained RPR Chain</a></p><p></p><pre class="lang-bsh prettyprint prettyprinted"><code><span class="pln"></span></code></pre>