<h1>簡介</h1>
<p><a href="https://github.com/KmolYuan/Pyslvs-PyQt5">Pyslvs</a> 是一套利用 Python 3 與 PyQt5 建立的平面機構模擬與合成系統.  機構模擬與合成的主要核心包括 <a href="https://github.com/KmolYuan/python-solvespace">Python-Solvespace</a> 幾何約束求解程式庫、<a href="https://github.com/KmolYuan/pyslvs/blob/master/src/tinycadlib.pyx">tinycadlib</a> 三角幾何函式程式庫、<a href="https://github.com/KmolYuan/Adesign">ADesign</a> 演算程式庫、<a href="https://github.com/KmolYuan/pyslvs/blob/master/src/bfgs.pyx">bgfs</a> 幾何約束求解程式庫、<a href="https://github.com/KmolYuan/pyslvs/blob/master/src/topologic.pyx">topologic</a> 類型合成程式庫、<a href="https://github.com/KmolYuan/pyslvs/blob/master/src/number.pyx">number</a> 數目合成程式庫等.</p>
<p>其中, <a href="https://github.com/KmolYuan/Adesign">ADesign</a> 演算程式庫包含 Real-coded Genetic Algorithm (<a href="https://github.com/KmolYuan/Adesign/blob/master/src/rga.pyx">RGA</a>)、Differential Evolution (<a href="https://github.com/KmolYuan/Adesign/blob/master/src/de.pyx">DE</a>) 與 Firefly Algorithm (<a href="https://github.com/KmolYuan/Adesign/blob/master/src/firefly.pyx">Firefly</a>) 等三種, 用於平面機構尺寸合成演算.</p>
<h4>源起</h4>
<p><a href="https://github.com/KmolYuan/Pyslvs-PyQt5">Pyslvs</a> 的開發源自 2008 年, 從最基本的實數基因演算法在平面機構的應用研究起步, 期間歷經下列研究者的貢獻:</p>
<ol>
<li>李孟恭, 2015, <a href="https://hdl.handle.net/11296/tur9hu">Django 網際框架在平面四連桿尺寸合成系統上的應用</a></li>
<li>李玠廷, 2013, <a href="https://hdl.handle.net/11296/mtf789">網際程式框架在平面連桿機構尺寸合成系統上的應用</a></li>
<li>陳威任, 2013, 符號式平面滑塊機構應用研究</li>
<li>謝政良, 2012, <a href="https://hdl.handle.net/11296/h5z5sb">網際雙自由度凸輪機構尺寸合成系統</a></li>
<li>黃竣鉉, 2012, <a href="https://hdl.handle.net/11296/a5b4p7">網際符號輔助軸接連桿機構之基因演算法尺寸合成系統</a></li>
<li>謝智翔, 2012, <a href="https://hdl.handle.net/11296/v9mr92">網際史都華平台機構逆運動學分析與模擬</a></li>
<li>許哲菘, 2010, <a href="https://hdl.handle.net/11296/w66tpa">網際六軸機械臂系統的逆運動學分析與模擬</a></li>
<li>葉岱錦, 2009, <a href="https://hdl.handle.net/11296/tt6672">基因演算法在網際機構合成系統上的應用</a></li>
</ol>
<p>過程中, 於 2015 年由<a href="https://github.com/kmollee">李孟恭</a>整合上述論文所開發的三種演算法, 完成 <a href="http://cython.org/">Cython</a> 格式的 <a href="https://github.com/kmollee/algorithm/blob/master/rga.pyx">RGA</a>、<a href="https://github.com/kmollee/algorithm/blob/master/de.pyx">DE</a> 與 <a href="https://github.com/kmollee/algorithm/blob/master/firefly.pyx">Firefly</a> 演算法程式庫後. 並自 2016 年起由<a href="https://github.com/KmolYuan">張元</a>將上述尺寸合成演算法, 搭配利用  <a href="http://www.swig.org/">SWIG</a> 技術, 將原本只能用於 Python 2 的 <a href="https://github.com/BBBSnowball/python-solvespace">Python-Solvespace</a> 倉儲, 改寫為能結合 PyQt5 圖形介面使用的 <a href="https://github.com/KmolYuan/python-solvespace">Python-Solvespace</a> 程式庫作為另一項開端. 再搭配平面機構中的數目合成與類型合成等程式庫後, 成為目前的 <a href="https://github.com/KmolYuan/Pyslvs-PyQt5">Pyslvs</a> 平面機構模擬與合成套件.</p>
<h4>Pyslvs 開發紀要</h4>
<p>2015 年 4 月 - 由<a href="https://github.com/kmollee">李孟恭</a>以 <a href="http://cython.org/">Cython</a> 技術, 完成三個<a href="https://github.com/kmollee/algorithm">尺寸合成演算法</a>程式庫.</p>
<p>2016 年 7 月 - 由<a href="https://github.com/KmolYuan">張元</a>完成 Python 3 格式的 <a href="https://github.com/KmolYuan/python-solvespace">Python-Solvespace</a> 程式庫.</p>
<p>2016 年 12 月- 由<a href="https://github.com/KmolYuan">張元</a>結合 PyQt5 與演算程式庫, 完成第一代 <a href="https://github.com/KmolYuan/Pyslvs-PyQt5">Pyslvs</a> 套件.</p>
<p>2017 年 11 月 - <a href="http://pyslvs.com">http://pyslvs.com</a> 上線.</p>
<p>2018 年 1 月 - 推出 <a href="https://github.com/KmolYuan/Pyslvs-PyQt5">Pyslvs</a> 18.01  版, 自此改為以年月序作為版次.</p>
<p>2018 年 7 月 - <a href="http://pyslvs.com/content/">http://pyslvs.com/content/</a> 使用手冊上線.</p>
<p></p>
<h2>機構與機器</h2>
<h4>機構 (Mechanism)</h4>
<p>機構是由剛體 (Rigid) 或撓性 (Flexible) 體機械元件所組成, 這些元件透過接頭 (Joint) 連接, 並以特定的運動相互移動.</p>
<h4>機器 (Machine)</h4>
<p>機器是由機構或機構的集合所組成, 能將力從動力源傳遞到預計要施加之元件上.</p>
<p>換言之, 機器是由剛性元件或撓性元件所組合而成, 能將力從動力源傳遞到預計要施加之元件上.</p>
<p>機器具有兩個功能: 傳遞確定的相對運動和傳遞力.  這些功能需要足夠強度與剛性來傳遞力.</p>
<p>若機構中所有的機件皆為連桿, 且所有的接頭皆為旋轉對, 則這個機構特稱為連 (Linkage).</p>
<p>參考資料:</p>
<p style="padding-left: 30px;"><a href="/downloads/Comparison_of_Methodologies_for_Conceptual_Design_of_Mechanisms.pdf">Comparison of Methodologies for Conceptual Design of Mechanisms.pdf</a></p>
<p style="padding-left: 30px;"><a href="/downloads/Design_and_Optimization_of_Slider_and_Crank_Mechanism_with_Multibody_Systems.pdf">Design and Optimization of Slider and Crank Mechanism with Multibody Systems.pdf</a></p>
<p style="padding-left: 30px;"><a href="/downloads/Dynamic_Analysis_of_Flexible_Mechanisms_by_Multibody_Dynamics.pdf">Dynamic Analysis of Flexible Mechanisms by Multibody Dynamics.pdf</a></p><h2>Pyslvs 介面</h2>
<p>(以 <a href="https://drive.google.com/file/d/1VZ9uW1lWkZyYBpxDBqCjBii1aGdHPTKj/view?usp=sharing">pyslvs-18.8.0.mscv1900-amd64.exe</a><span>  開啟)</span></p>
<p><img alt="" height="524" src="/images/pyslvs-18.7.0-screenshot.png" width="600"/></p>
<p>Pyslvs 主畫面的上方為功能表列 (Menu bar), 右側為畫布 (Canvas), 左方則有各式功能的分頁欄 (Tab widgets).</p>
<p>功能表列涵蓋大部分的功能, 其中部分有關各項目的細部操作, 則必須在對應的分頁欄中選取或設定. </p>
<h4>Mechanism 分頁</h4>
<p>Pyslvs 左側中的 Mechanism 子頁面, 主要用於輸入機構關鍵點與運動連桿, 使用時以滑鼠點選 Mechanism 頁面後, 可在右方工作區, 以滑鼠輸入機構關鍵點與運動連桿.</p>
<h4>Inputs 分頁</h4>
<p>Pyslvs 的 Inputs 子頁面用於宣告機構的主動軸, 並進行運動模擬.</p>
<h4>Synthesis 分頁</h4>
<p>Pyslvs 的 Synthesis 子頁面用於進行平面機構的結構合成與尺寸合成.</p>
<h4>功能表列 (Menu bar)</h4>
<p>功能表列中根據不同的功能分類如下:</p>
<p>檔案 (File)</p>
<p>建立新的工作簿、開啟既有的工作簿、參考範例, 以及不同檔案格式的匯入與匯出功能.</p>
<p>編輯 (Edit)</p>
<p>復原與重做功能. </p>
<p>選項 (Options)</p>
<p>檢視方式調整以及工作簿相關資訊.</p>
<p>說明 (Help)</p>
<p>與 Pyslvs 相關網站與套件資訊.</p>
<h4>快捷鍵</h4>
<p>F1 - 有關 Pyslvs</p>
<p>Shift + F1 - Toggle 全螢幕</p>
<p></p><h1>操作</h1>
<p>Pyslvs 開啟 Crank-Rocker 機構畫面, under Mechanism 頁面 (以 <a href="https://drive.google.com/file/d/1VZ9uW1lWkZyYBpxDBqCjBii1aGdHPTKj/view?usp=sharing">pyslvs-18.8.0.mscv1900-amd64.exe</a><span>  開啟)</span>:</p>
<p><img alt="" height="338" src="/images/crank_rocker-18.7.0.png" width="600"/></p>
<p>Crank-Rocker under Inputs 頁面 (以 <a href="https://drive.google.com/file/d/1VZ9uW1lWkZyYBpxDBqCjBii1aGdHPTKj/view?usp=sharing">pyslvs-18.8.0.mscv1900-amd64.exe</a><span>  開啟)</span>:</p>
<p><img alt="" height="338" src="/images/crank_rocker_inputs-18.7.0.png" width="600"/></p>
<p>Crank-Rocker 通過特定點尺寸合成畫面1 (以 <a href="https://drive.google.com/file/d/1VZ9uW1lWkZyYBpxDBqCjBii1aGdHPTKj/view?usp=sharing">pyslvs-18.8.0.mscv1900-amd64.exe</a><span>  開啟)</span>:</p>
<p><img alt="" height="338" src="/images/crank_rocker_dimensional_synthesis1.png" width="600"/></p>
<p>完成 1000 代 DE 演算法之後的結果畫面 (以 <a href="https://drive.google.com/file/d/1VZ9uW1lWkZyYBpxDBqCjBii1aGdHPTKj/view?usp=sharing">pyslvs-18.8.0.mscv1900-amd64.exe</a><span>  開啟)</span>:</p>
<p><img alt="" height="338" src="/images/crank_rocker_dimensional_synthesis2.png" width="600"/></p><h2>模擬操作</h2>
<p>Pyslvs 的模擬操作主要牽涉 Mechanism 與 Inputs 分頁, Mechanism 分頁用於定義機構各節點與連桿, 而 Inputs 分頁則可用來定義主動旋轉軸, 並利用自動或手動模式進行合理平面機構的運動模擬.</p><h3>曲柄滑塊</h3>
<p>以下說明以 <a href="https://drive.google.com/file/d/1VZ9uW1lWkZyYBpxDBqCjBii1aGdHPTKj/view?usp=sharing">pyslvs-18.8.0.mscv1900-amd64.exe</a><span>  為主.</span></p>
<p>File -&gt; New Workbook</p>
<p>選擇左側 Mechanism 子頁面.</p>
<h4>建立固定點與移動點</h4>
<p>利用滑鼠在右側畫布區, 按住滑鼠右鍵輸入兩個固定點與一個可運動點.</p>
<h4>建立連桿</h4>
<p>將其中一個固定點轉為滑塊, 即將 point2 之類型 (type) 由 pin 轉為 pin in slot, 採內建水平滑動面, 或更改滑動面的對應角度.</p>
<p>在 Mechanism 完成機構定義後, 轉到 Inputs 子頁面, 定義 Driver point 後進行曲柄滑塊的運動模擬.</p><h3>四連桿</h3>
<p>在 Mechanism 子頁面定義兩個固定點與兩個移動點後, 建立三根可運動連桿.</p>
<p>接著進入 Inputs 頁面, 定義 driver points 後進行基本運動模擬.</p>
<h2>尺寸合成操作</h2>
<p>Pyslvs 的尺寸合成功能, 主要依賴 <a href="https://github.com/KmolYuan/pyslvs/blob/master/src/tinycadlib.pyx">tinycadlib</a><span> 三角幾何函式程式庫與 </span><a href="https://github.com/KmolYuan/Adesign">ADesign</a><span> 演算程式庫, 其中各平面機構範例進行尺寸合成的第一步必須先以三角幾何函式程式庫進行配置後, 再輸入特定機構節點所要通過的運行點座標, 最後再選擇 <a href="https://github.com/KmolYuan/Adesign">ADesign</a> 演算程式庫中的 Real-coded Genetic Algorithm (<a href="https://github.com/KmolYuan/Adesign/blob/master/src/rga.pyx">RGA</a>)、Differential Evolution (<a href="https://github.com/KmolYuan/Adesign/blob/master/src/de.pyx">DE</a>) 或 Firefly Algorithm (<a href="https://github.com/KmolYuan/Adesign/blob/master/src/firefly.pyx">Firefly</a>) 演算法進行尺寸合成運算.</span></p><h2>構造合成操作</h2>
<p>Pyslvs 的構造合成包括平面機構的數目合成與類型合成等兩部分.</p>
<p>在數目合成階段, 使用者可以選擇連桿個數 (Link number)、接頭個數 (Joint number), 以及機構的自由度.</p><h1>下載</h1>
<p>利用 pyslvs At mde 登錄 Gdrive 提供各版次下載.</p>
<p>Windows 64 位元操作系統:</p>
<p><a href="https://drive.google.com/file/d/1YdgFsFwFMmYvB0wi56OInl-0crUJPFlh/view?usp=sharing">pyslvs-18.7.0.mscv1900-amd64.exe</a> (53446 KB)</p>
<p><a href="https://drive.google.com/file/d/1VZ9uW1lWkZyYBpxDBqCjBii1aGdHPTKj/view?usp=sharing">pyslvs-18.8.0.mscv1900-amd64.exe</a> (53458 KB)</p>
<p><a href="https://drive.google.com/file/d/1gaX-_UfrbjObdATGvS00egfTW0uq3piP/view?usp=sharing">pyslvs-18.9.0.mscv1900-amd64.exe</a> (68337 KB)</p>
<p><a href="https://drive.google.com/open?id=1YT49__LzaT_aFvhZdbmleqktZJEwDb5U">pyslvs-18.11.0.mscv1900-amd64.exe</a> (70875 KB)</p><h1>範例</h1>
<p>展示利用 Pyslvs 解題</p>
<p>參考資料:</p>
<p>1977 - <a href="https://theses.ncl.ac.uk/dspace/bitstream/10443/567/1/Oldham77.pdf">THE KINEMATICS AND VIBRATION OF PLANAR LINKAGE MECHANISMS</a></p>
<p><a href="https://www.researchgate.net/publication/304782762_MeKin2D_Suite_for_Planar_Mechanism_Kinematics">MeKin2d</a></p>
<p><a href="https://www.amazon.com/Machines-Mechanisms-Applied-Kinematic-Analysis/dp/0132157802">MACHINES AND MECHANISMS APPLIED KINEMATIC ANALYSIS Fourth Edition by David H. Myszka</a></p>
<p><a href="https://books.google.com.tw/books?id=0A1mDwAAQBAJ&amp;pg=PP1&amp;lpg=PP1&amp;dq=Introduction+to+Mechanism+Design:+with+Computer+Applications&amp;source=bl&amp;ots=WakYIZ-L93&amp;sig=tSRFX6Z9fhaT3Lzk3USgSb05PXA&amp;hl=en&amp;sa=X&amp;ved=2ahUKEwiPqeP4-sPcAhVHFYgKHbE_Ae4Q6AEwBHoECAUQAQ#v=onepage&amp;q=Introduction%20to%20Mechanism%20Design%3A%20with%20Computer%20Applications">Introduction to Mechanism Design: with Computer Applications by By Eric Constans and Karl B. Dyer</a></p>
<p><a href="https://www.amazon.com/Theory-Machines-Mechanisms-John-Uicker/dp/0195371232">THEORY OF MACHINES AND MECHANISMS Fourth Edition by John Uicker, Gordon Pennock and  Joseph Shigley</a></p>
<p></p>
<p></p>
<h2>模擬範例</h2>
<p><img alt="" height="338" src="/images/sam_sixbar.png" width="600"/></p>
<p>以下畫面以 <a href="https://drive.google.com/file/d/1VZ9uW1lWkZyYBpxDBqCjBii1aGdHPTKj/view?usp=sharing">pyslvs-18.8.0.mscv1900-amd64.exe</a><span>  製作.</span></p>
<p><img alt="" height="338" src="/images/sam_sixbar-18.7.png" width="600"/></p>
<p>以下畫面以 <a href="https://drive.google.com/file/d/1VZ9uW1lWkZyYBpxDBqCjBii1aGdHPTKj/view?usp=sharing">pyslvs-18.8.0.mscv1900-amd64.exe</a><span>  製作.</span></p>
<p><img alt="" height="315" src="/images/sixbar_r_slider.png" width="560"/></p>
<p><a href="/downloads/sixbar_r_with_slider.pyslvs">sixbar_r_slider.pyslvs</a> (只適用於 <a href="https://drive.google.com/file/d/1VZ9uW1lWkZyYBpxDBqCjBii1aGdHPTKj/view?usp=sharing">pyslvs-18.8.0.mscv1900-amd64.exe</a><span> 版本</span>)</p>
<p><iframe allow="autoplay; encrypted-media" allowfullscreen="allowfullscreen" frameborder="0" height="315" src="https://www.youtube.com/embed/aBEfsdOycC8" width="560"></iframe></p>
<h4>建立六連桿機構模型</h4>
<p>以 <a href="https://drive.google.com/file/d/1VZ9uW1lWkZyYBpxDBqCjBii1aGdHPTKj/view?usp=sharing">pyslvs-18.8.0.mscv1900-amd64.exe</a><span>  製作</span>)</p>
<p><iframe allow="autoplay; encrypted-media" allowfullscreen="allowfullscreen" frameborder="0" height="315" src="https://www.youtube.com/embed/1BcjhYgvQtY" width="560"></iframe></p>
<h4>八連桿機構</h4>
<p><a href="/downloads/eight_bar1.pyslvs">eightbar1.pyslvs</a> (只適用於 <a href="https://drive.google.com/file/d/1VZ9uW1lWkZyYBpxDBqCjBii1aGdHPTKj/view?usp=sharing">pyslvs-18.8.0.mscv1900-amd64.exe</a><span> 版本</span>)</p>
<p><img alt="" height="322" src="/images/eightbar1.png" width="600"/></p>
<p><a href="/downloads/eight_bar2.pyslvs">eightbar2.pyslvs</a> (只適用於 <a href="https://drive.google.com/file/d/1VZ9uW1lWkZyYBpxDBqCjBii1aGdHPTKj/view?usp=sharing">pyslvs-18.8.0.mscv1900-amd64.exe</a><span> 版本</span>)</p>
<p><img alt="" height="322" src="/images/eightbar2.png" width="600"/></p>
<p><a href="/downloads/eight_bar3.pyslvs">eightbar3.pyslvs</a> (只適用於 <a href="https://drive.google.com/file/d/1VZ9uW1lWkZyYBpxDBqCjBii1aGdHPTKj/view?usp=sharing">pyslvs-18.8.0.mscv1900-amd64.exe</a><span> 版本</span>)</p>
<p><img alt="" height="322" src="/images/eightbar3.png" width="600"/></p>
<h4>十連桿機構</h4>
<p><a href="/downloads/tenbar_linkage.pyslvs">tenbar_linkage.pyslvs</a> (只適用於 <a href="https://drive.google.com/file/d/1VZ9uW1lWkZyYBpxDBqCjBii1aGdHPTKj/view?usp=sharing">pyslvs-18.8.0.mscv1900-amd64.exe</a><span> 版本</span>)</p>
<p><img alt="" height="322" src="/images/tenbar_linkage.png" width="600"/></p><h2>尺寸合成範例</h2>
<h2>結構合成範例</h2>
<h2>產品設計範例</h2>
<h4>健步機</h4>
<p><a href="/downloads/2014_nsysu_design_linkage_type_foot_exercise_machine.pdf">連桿式健步機設計.pdf</a></p>
<p><a href="/downloads/sixbar_foot_exercise_machine.pyslvs">sixbar_foot_exercise_machine.pyslvs</a> (只適用於 <a href="https://drive.google.com/file/d/1VZ9uW1lWkZyYBpxDBqCjBii1aGdHPTKj/view?usp=sharing">pyslvs-18.8.0.mscv1900-amd64.exe</a><span> 版本</span>)</p>
<p><img alt="" height="338" src="/images/sixbar_foot_exercise_machine.png" width="600"/></p>
<h4>汽車雨刷</h4>
<p><a href="/downloads/windshield_design1.pyslvs">windshield_design1.pyslvs</a> (只適用於 <a href="https://drive.google.com/file/d/1VZ9uW1lWkZyYBpxDBqCjBii1aGdHPTKj/view?usp=sharing">pyslvs-18.8.0.mscv1900-amd64.exe</a><span> 版本</span>)</p>
<p><img alt="" height="338" src="/images/windshield_design1.png" width="600"/></p>
<h4>汽車引擎蓋</h4>
<p><a href="/downloads/automobile_hood1.pyslvs">automobile_hood1.pyslvs</a> (只適用於 <a href="https://drive.google.com/file/d/1VZ9uW1lWkZyYBpxDBqCjBii1aGdHPTKj/view?usp=sharing">pyslvs-18.8.0.mscv1900-amd64.exe</a><span> 版本</span>)</p>
<p><img alt="" height="322" src="/images/automobile_hood1.png" width="600"/></p>
<p>平開窗戶開合機構</p>
<p><a href="/downloads/house_window.pyslvs">house_window.pyslvs</a> (只適用於 <a href="https://drive.google.com/file/d/1VZ9uW1lWkZyYBpxDBqCjBii1aGdHPTKj/view?usp=sharing">pyslvs-18.8.0.mscv1900-amd64.exe</a><span> 版本</span>)</p>
<p><img alt="" height="322" src="/images/casement_window.png" width="600"/></p>
<p></p><h1>開發</h1>
<p>取得 Pyslvs 原始碼:</p>
<pre class="brush:bash;toolbar:false" contenteditable="false">git clone --recurse-submodules https://github.com/KmolYuan/Pyslvs-PyQt5</pre>
<p>本倉儲有兩個主要分支：master 分支為當前穩定版本；dev 分支為開發中版本。每當切換分支時，請注意子倉儲的版次是否有變動，使用以下指令更新：</p>
<pre class="brush:bash;auto-links:false;toolbar:false" contenteditable="false">git submodule update --recursive</pre>
<p>若有更新，必須重新編譯核心。</p>
<p>位於 pyslvs 目錄中的 unittest 程式:</p>
<pre class="brush:py;auto-links:false;toolbar:false" contenteditable="false"># -*- coding: utf-8 -*-

"""This module will test the functions of Pyslvs."""

__author__ = "Yuan Chang"
__copyright__ = "Copyright (C) 2016-2018"
__license__ = "AGPL"
__email__ = "pyslvs@gmail.com"

import unittest
from unittest import TestCase
from typing import Tuple, List

#For necessary testing modules.
from math import sqrt, radians, isclose
from pmks import VPoint
import bfgs
from tinycadlib import (
    Coordinate,
    PLAP,
    PLLP,
    PLPP,
    PXY,
    expr_solving,
    data_collecting,
)
from planarlinkage import Planar
from rga import Genetic
from firefly import Firefly
from de import DiffertialEvolution
from number import number_synthesis
from topologic import topo, Graph
from triangulation import vpoints_configure
from _parser import parse_vpoints
from examples import example_list


class CoreTest(TestCase):
    
    """Testing Cython libs."""
    
    def vpoints_object(self) -&gt; Tuple[List[VPoint], Tuple[Tuple[int, int]]]:
        """Example: Jansen's linkage (Single)."""
        expr, inputs = example_list["Jansen's linkage (Single)"]
        return parse_vpoints(expr), inputs
    
    def planar_object(self) -&gt; Planar:
        """Test-used mechanism for algorithm."""
        return Planar({
            'Driver': {'P0': (-70, -70, 50)},
            'Follower': {'P1': (70, -70, 50)},
            'Target': {'P4': [
                (60.3, 118.12),
                (31.02, 115.62),
                (3.52, 110.62),
                (-25.77, 104.91),
                (-81.49, 69.19),
                (-96.47, 54.906),
                (-109.34, 35.98),
                (-121.84, 13.83),
                (-127.56, -20.09),
                (-128.63, -49.74),
                (-117.56, -65.45),
            ]},
            'Expression': "PLAP[P0,L0,a0](P2);" +
                "PLLP[P2,L1,L2,P1](P3);" +
                "PLLP[P2,L3,L4,P3](P4)",
            'constraint': [('P0', 'P1', 'P2', 'P3')],
            'upper': [100., 100., 100., 100., 100., 360.],
            'lower': [5., 5., 5., 5., 5., 0.],
        })
    
    def test_plap(self):
        """Test for PLAP function."""
        A = Coordinate(0, 0)
        B = Coordinate(50, 0)
        x, y = PLAP(A, 50 * sqrt(2), radians(45), B)
        self.assertTrue(isclose(x, 50))
        self.assertTrue(isclose(y, 50))
    
    def test_pllp(self):
        """Test for PLLP function."""
        A = Coordinate(-30, 0)
        B = Coordinate(30, 0)
        x, y = PLLP(A, 50, 50, B)
        self.assertTrue(isclose(x, 0))
        self.assertTrue(isclose(y, 40))
        x, y = PLLP(A, 30, 30, B)
        self.assertTrue(isclose(x, 0))
        self.assertTrue(isclose(y, 0))
        x, y = PLLP(A, 90, 30, B)
        self.assertTrue(isclose(x, 60))
        self.assertTrue(isclose(y, 0))
    
    def test_plpp(self):
        """Test for PLPP function."""
        A = Coordinate(0, 0)
        B = Coordinate(0, -3)
        C = Coordinate(3/2, 0)
        x, y = PLPP(A, sqrt(5), B, C)
        self.assertTrue(isclose(x, 2))
        self.assertTrue(isclose(y, 1))
    
    def test_pxy(self):
        A = Coordinate(80, 90)
        x, y = PXY(A, 40, -20)
        self.assertTrue(isclose(x, 120))
        self.assertTrue(isclose(y, 70))
    
    def test_topologic(self):
        """Testing 'topologic' libraries.
        
        + 'topo' function.
        + 'Graph' class.
        """
        G = Graph([(0, 1), (0, 4), (1, 5), (2, 3), (2, 4), (3, 5), (4, 5)])
        H = Graph([(0, 2), (0, 4), (1, 3), (1, 4), (2, 5), (3, 5), (4, 5)])
        I = Graph([(0, 1), (0, 2), (1, 4), (2, 5), (3, 4), (3, 5), (4, 5)])
        self.assertTrue(G.is_isomorphic(H))
        self.assertFalse(G.is_isomorphic(I))
        answer, time = topo([4, 2], degenerate=True)
        self.assertEqual(len(answer), 2)
    
    def test_solving(self):
        """Test triangular formula solving.
        
        + Test for PMKS parser.
        + Test data collecting function.
        + Test expression solving function.
        """
        vpoints, inputs = self.vpoints_object()
        self.assertTrue(len(vpoints) == 8)
        exprs = vpoints_configure(vpoints, inputs)
        mapping = {n: 'P{}'.format(n) for n in range(len(vpoints))}
        data_dict, dof = data_collecting(exprs, mapping, vpoints)
        for link, link_length in (
            ('L0', 15.002083188677497),
            ('L1', 41.50187586121861),
            ('L2', 49.9949057404852),
            ('L3', 40.09650982317538),
            ('L4', 55.80253220060896),
            ('L5', 61.90525179659639),
            ('L6', 39.302800154696364),
            ('L7', 36.69767567571548),
            ('L8', 39.395233214184685),
            ('L9', 48.995886562037015),
            ('L10', 65.69940106271898),
        ):
            self.assertTrue(isclose(data_dict[link], link_length))
        self.assertEqual(dof, 1)
        result = expr_solving(exprs, mapping, vpoints, [0.])
        x, y = result[-1]
        self.assertTrue(isclose(x, -43.17005515543241))
        self.assertTrue(isclose(y, -91.75322590542523))
    
    def test_bfgs(self):
        """Test Sketch Solve kernel."""
        input_data, output_data, grad_data = bfgs.test_kernel()
        self.assertEqual(input_data[0], (0.0, 0.0))
        self.assertEqual(input_data[1], (5.0, 0.0))
        self.assertEqual(input_data[2], (6.0, 5.0))
        self.assertEqual(input_data[3], (6.0, 5.0))
        self.assertEqual(input_data[4], (30.0, 10.0))
        self.assertTrue(isclose(round(output_data[2][1], 2), 10))
        self.assertTrue(isclose(round(output_data[4][0], 2), 30))
        vpoints, inputs = self.vpoints_object()
        result = bfgs.vpoint_solving(vpoints, [(0, 1, 0.)])
        x, y = result[-1]
        self.assertTrue(isclose(round(x, 2), -43.17))
        self.assertTrue(isclose(round(y, 2), -91.75))
    
    def test_number_synthesis(self):
        """Test Number Synthesis function."""
        for NL, NJ in [(4, 4), (6, 7), (8, 9), (10, 12)]:
            for factors in number_synthesis(NL, NJ):
                count = 0
                for i, factor in enumerate(factors):
                    count += factor * (i + 2)
                self.assertEqual(int(count / 2), NJ)
    
    def test_algorithm_rga(self):
        """Real-coded genetic algorithm."""
        fun1 = Genetic(self.planar_object(), {
            'maxTime': 1, 'report': 10,
            #Genetic
            'nPop': 500,
            'pCross': 0.95,
            'pMute': 0.05,
            'pWin': 0.95,
            'bDelta': 5.,
        })
        fun1.run()
    
    def test_algorithm_firefly(self):
        """Firefly algorithm."""
        fun2 = Firefly(self.planar_object(), {
            'maxTime': 1, 'report': 10,
            #Firefly
            'n': 80,
            'alpha': 0.01,
            'betaMin': 0.2,
            'gamma': 1.,
            'beta0': 1.,
        })
        fun2.run()
    
    def test_algorithm_de(self):
        """Differtial evolution."""
        fun3 = DiffertialEvolution(self.planar_object(), {
            'maxTime': 1, 'report': 10,
            #DE
            'strategy': 1,
            'NP': 400,
            'F': 0.6,
            'CR': 0.9,
        })
        fun3.run()


if __name__ == '__main__':
    unittest.main()
</pre>
<p>以 Eric6 IDE 開啟 Pyslvs 專案:</p>
<p><img alt="" height="338" src="/images/pyslvs_under_eric6.png" width="600"/></p><h2>Windows 開發</h2>
<p>下載 <a href="https://drive.google.com/file/d/12BLN4daAPlO1KjCTDFi1kqJZ6f5k7Y5k/view?usp=sharing">Qt 可攜程式開發套件.7z </a>（下載檔案約 8GB, 解開壓縮後約 21GB）或使用 Python 3.7.0 與 Msys2  製作的 <a href="https://drive.google.com/file/d/1WOGsDH_rVWBJJ5QI6FSJ4kDVBgAeRkkg/view?usp=sharing">p37_adv</a>（下載檔案約 5.3 GB, 解開壓縮約 14 GB）執行 start.bat。</p>
<p>其中所需要的套件已安裝在可攜程式當中，可參考模組需求清單 requirements.txt。</p>
<p>若要完成獨立可執行檔案的發布，必須另外安裝 <a href="https://www.pyinstaller.org/">PyInstaller</a> 模組：</p>
<pre class="brush:bash;auto-links:false;toolbar:false" contenteditable="false">python -m pip install pyinstaller</pre>
<h4>編譯 GUI 套件:</h4>
<p>進入 Pyslvs-PyQt5 目錄後, 執行:</p>
<pre class="brush:bash;auto-links:false;toolbar:false" contenteditable="false">mingw32-make</pre>
<p>完成後, 以 2018.09 版次為例, dist 目錄中將得到可執行檔案:</p>
<pre class="brush:bash;auto-links:false;toolbar:false" contenteditable="false">pyslvs-18.9.0.mscv1900-amd64.exe</pre>
<h4>編譯程式庫:</h4>
<p>在命令列中更換目錄至 core\libs\pyslvs 後, 執行:</p>
<pre class="brush:bash;auto-links:false;toolbar:false" contenteditable="false">mingw32-make</pre>
<p>建立下列動態連結程式庫 (pyd):</p>
<pre class="brush:bash;auto-links:false;toolbar:false" contenteditable="false">bfgs.cp36-win_amd64.pyd
de.cp36-win_amd64.pyd
firefly.cp36-win_amd64.pyd
number.cp36-win_amd64.pyd
planarlinkage.cp36-win_amd64.pyd
pmks.cp36-win_amd64.pyd
rga.cp36-win_amd64.pyd
tinycadlib.cp36-win_amd64.pyd
topologic.cp36-win_amd64.pyd
triangulation.cp36-win_amd64.pyd
verify.cp36-win_amd64.pyd</pre><h3>環境修正</h3>
<p>從 <a href="https://drive.google.com/file/d/1DWtyoUhl8CycKJ8uulB3viRXE39KqpE1/view?usp=sharing">p37</a> 標準版升級能夠以 <a href="https://www.msys2.org/">Msys2</a> 編譯 Pyslvs-PyQt5</p>
<pre class="brush:bash;auto-links:false;toolbar:false" contenteditable="false">pip install pyqtchart lark-parser networkx ezdxf peewee openpyxl psutil pyinstaller cffi pyyaml</pre>
<h4><span>cygwinccompiler.py 修改</span></h4>
<p><span>套用編譯器設定的補釘，其位於 Pyslvs 專案的 platform 目錄中。</span></p>
<pre class="brush:bash;auto-links:false;toolbar:false" contenteditable="false">patch p37\lib\distutils\cygwinccompiler.py platform\patch.diff</pre>
<p>patch.diff 內容：</p>
<pre class="brush:diff;auto-links:false;toolbar:false" contenteditable="false">--- cygwinccompiler.py
+++ cygwinccompiler.py
@@ -82,7 +82,21 @@ def get_msvcr():
         elif msc_ver == '1600':
             # VS2010 / MSVC 10.0
             return ['msvcr100']
+        elif msc_ver == '1700':
+            # Visual Studio 2012 / Visual C++ 11.0
+            return ['msvcr110']
+        elif msc_ver == '1800':
+            # Visual Studio 2013 / Visual C++ 12.0
+            return ['msvcr120']
+        elif msc_ver == '1900':
+            # Visual Studio 2015 / Visual C++ 14.0
+            # "msvcr140.dll no longer exists" http://blogs.msdn.com/b/vcblog/archive/2014/06/03/visual-studio-14-ctp.aspx
+            return ['vcruntime140']
+        elif msc_ver == '1910':
+            return ['vcruntime140']
+        elif msc_ver == '1914':
+            return ['vcruntime140']
         else:
             raise ValueError("Unknown MS Compiler version %s " % msc_ver)
</pre>
<h4>增加 distutils.cfg 檔案</h4>
<p>在 p37\Lib\distutils 目錄中新增 distutils.cfg</p>
<pre class="brush:bash;auto-links:false;toolbar:false" contenteditable="false">echo [build]&gt;&gt; p37\Lib\distutils\distutils.cfg
echo compiler = mingw32&gt;&gt; p37\Lib\distutils\distutils.cfg</pre>
<h4>修改 _advapi32.py 檔案</h4>
<p>修改 p37\Lib\site-packages\win32ctypes\core\cffi\_advapi32.py</p>
<p>蓋掉第 197 與 199 行</p>
<pre class="brush:cpp;auto-links:false;toolbar:false" contenteditable="false">#c_creds.CredentialBlobSize = \

    #ffi.sizeof(blob_data) - ffi.sizeof('wchar_t')</pre><h3>PyInstaller 對 Windows 的支援</h3>
<p>官方說明：<a href="https://pyinstaller.readthedocs.io/en/stable/man/pyi-makespec.html#windows-and-mac-os-x-specific-options">https://pyinstaller.readthedocs.io/en/stable/man/pyi-makespec.html#windows-and-mac-os-x-specific-options</a></p>
<ul>
<li>預設包裝時採用不關閉主控台選項（不使用 -w），目的是顯示 Pyslvs 的版本資訊，關閉後將會無法使用 --help 或 --version 等不啟動 GUI 的顯示功能。</li>
<li>在 Windows 中必須手動加入除了端口程式庫 pyd 以外的相依外部程式庫，如 SWIG 與 PyQt sip 的隱式導入。</li>
<li>在 Windows 中的圖示格式為 ico。</li>
</ul><h2>Ubuntu 開發</h2>
<p>安裝 python3-dev 與 swig 套件：</p>
<pre class="brush:bash;auto-links:false;toolbar:false" contenteditable="false">sudo apt update
sudo apt install python3-dev swig</pre>
<p>取得 Pyslvs 原始碼：</p>
<pre class="brush:bash;toolbar:false" contenteditable="false">git clone --recurse-submodules https://github.com/KmolYuan/Pyslvs-PyQt5</pre>
<p>安裝需要的 Python 模組：</p>
<pre class="brush:bash;auto-links:false;toolbar:false" contenteditable="false">sudo pip3 install -r requirements.txt</pre>
<p>完整編譯：</p>
<pre class="brush:bash;auto-links:false;toolbar:false" contenteditable="false">make</pre>
<p>可以在倉儲目錄下的 out 資料夾中取得 AppImage 可執行檔（詳見下一節說明）。</p>
<p>編譯核心：</p>
<pre class="brush:bash;auto-links:false;toolbar:false" contenteditable="false"># 所有程式庫
make build-kernel

# Pyslvs 程式庫
make build-pyslvs

# Python-Solvespace 程式庫
make build-solvespace</pre>
<p>執行腳本：</p>
<pre class="brush:bash;auto-links:false;toolbar:false" contenteditable="false">python3 launch_pyslvs.py</pre><h3>AppImage 包裝</h3>
<p>官方網站：<a href="https://appimage.org/">https://appimage.org/</a></p>
<p>在不同的 Linux 作業系統下有著不一樣的程式庫版本，由於程式之間的「相依性」十分高，會造成程式編譯後無法移植到其他環境中使用，即使編譯端與客戶端的作業系統是一樣的。</p>
<p>AppImage 的目標是將編譯端的程式可以編一到任何「目標作業系統」都可以執行。而「目標作業系統」必須符合對應的環境需求（相依程式庫版本必須滿足）。最差的情況是必須「完全符合或較新」；最完美的情況甚至是「不用安裝」。</p>
<p>使用的原理是 App Dir 壓縮包配上腳本檔案，執行時會解壓縮到帳戶的 /tmp 目錄（並且會附加 Hash code），而此一壓縮包會包含所有程式所需要的相依程式庫或套件。</p>
<p>AppImage releases 標榜「不使用 sudo」、「選擇性安裝」以及支援版本升級功能。</p>
<p>包裝的建立是透過 bash 腳本使用 AppImage tool kits，支援基本的自動「程式與程式庫相依性分析」的功能。不過在過度「客製化」的開發環境下，開發者必須手動將所需的檔案複製到 App Dir 中。</p>
<p>Pyslvs 的包裝流程是透過 appimage_recipe.sh 腳本完成。使用的工具為 virtualenv，依照開發環境的安裝模式建立 App Dir，並安裝 Pyslvs 所需的模組，並經由手動複製一些 built-in scripts 之後，打造出完全獨立的 Python 執行環境。Pyslvs 便可在完全無 Python 3 的環境中執行（不過仍有 glib 的最低版本需求）。</p>
<ul>
<li>App Dir 位置：ENV/</li>
<li>包裝輸出位置：out/</li>
</ul><h2>Mac OS X 開發</h2>
<p>Mac OS X 上的任何程式開發都不建議使用 sudo 指令（除非必要），也不要使用內建的 Python 以免系統故障。建議使用 <a href="https://brew.sh/index_zh-tw">Homebrew</a> 或是 <a href="https://www.macports.org/">MacPort</a> 套件管理工具。</p>
<p>必須注意的是，平台上的編譯工具僅支援向下相容，較新的 xcode 版本無法在舊版運行。</p>
<p>安裝 Python 與 SWIG：</p>
<pre class="brush:bash;auto-links:false;toolbar:false" contenteditable="false"># Homebrew 的 Python 版本永遠是最新的穩定板
brew install python@3
brew install swig

# MacPort 可支援任意 Python 版本
# 安裝在 /opt 必須使用 sudo 指令
yes | sudo part install python36
yes | sudo port install py$PYTHON-pip
sudo port select --set python3 python36
sudo port select --set pip pip36</pre>
<p>使用 MacPort 的 pip3 安裝時請加上 --user 免去 sudo 操作。</p>
<p>取得 Pyslvs 原始碼：</p>
<pre class="brush:bash;toolbar:false" contenteditable="false">git clone --recurse-submodules https://github.com/KmolYuan/Pyslvs-PyQt5</pre>
<p>安裝需要的 Python 模組：</p>
<pre class="brush:bash;auto-links:false;toolbar:false" contenteditable="false">pip3 install -r requirements.txt</pre>
<p>安裝 PyInstaller 模組打包成執行檔：</p>
<pre class="brush:bash;auto-links:false;toolbar:false" contenteditable="false">pip3 install pyinstaller</pre>
<p>完整編譯：</p>
<pre class="brush:html;auto-links:false;toolbar:false" contenteditable="false">make</pre>
<p>可以在倉儲目錄下的 dist 資料夾中取得 app 與 unix-style 可執行檔。</p>
<p>編譯核心：</p>
<pre class="brush:bash;auto-links:false;toolbar:false" contenteditable="false"># 所有程式庫
make build-kernel
 
# Pyslvs 程式庫
make build-pyslvs
 
# Python-Solvespace 程式庫
make build-solvespace</pre>
<p>執行腳本：</p>
<pre class="brush:bash;auto-links:false;toolbar:false" contenteditable="false">python3 launch_pyslvs.py</pre>
<h3>PyInstaller 對 Mac OS X 的支援</h3>
<p>官方說明：<a href="https://pyinstaller.readthedocs.io/en/stable/man/pyi-makespec.html#windows-and-mac-os-x-specific-options">https://pyinstaller.readthedocs.io/en/stable/man/pyi-makespec.html#windows-and-mac-os-x-specific-options</a></p>
<ul>
<li>預設包裝時採用關閉主控台的選項（使用 -w），目的是為了產生標準 .app 格式的可執行檔，而非只有類 Unix 執行檔。啟用此選項後，會包裝出上述兩種格式的執行檔。</li>
<li><span class="option">在 Mac OS X 中，對 .app 格式的可執行檔作網路傳輸時必須微壓縮成 .zip 檔案。<br/></span></li>
<li>在 Mac OS X 中可以自動定位 SWIG 與 PyQt 等擁有外部程式庫的模組。</li>
<li>在 Mac OS X 中的圖示格式為 icns。</li>
</ul>
<h2>參與協同</h2>
<p>若要參與 Pyslvs 的開發，基本編寫風格遵循 <a href="https://www.python.org/dev/peps/pep-0008/">PEP 8</a>，主要規則請參閱子章節的資訊。</p><h3>註解規則</h3>
<p>所有 Modules、Classes 與 Functions 都應該加上 doc string，一般 Methods 應比照 Functions，而 __init__ 等則視情況在程式碼中添加單行註解。</p>
<pre class="brush:py;auto-links:false;toolbar:false" contenteditable="false"># -*- coding: utf-8 -*-

"""Module doc string title

Module decriptions ...
"""


def function():
    """Single line doc string."""
    ...


class MyClass:

    """MyClass doc string."""

    def method():
        """MyClass.method doc string."""
        ...</pre>
<p>使用單行註解多行程式碼時，為求功能明確，應在該區域使用單空行分隔。</p>
<pre class="brush:py;auto-links:false;toolbar:false" contenteditable="false">def foo() -&gt; List[Set[int]]:
    """foo doc string."""
    a = 10
    b = 20

    # Let a plus b, and assign to c.
    c = a + b

    # Do another things ...
    d = func_c2d(c)
    e = func_c2e(c)
    f = func_de2f(d, e)

    # Convert f.
    return list(f)</pre><h3>命名規則</h3>
<ul>
<li>Classes 使用字首大寫命名，如 RedApple。</li>
<li>定值使用全部大寫並用底線連接，如 RED_APPLE。</li>
<li>模組、變數等其他名稱一律使用小寫並用底線連接，如 red_apple。</li>
<li>自用變數樣式（以表示絕對不會跨層級）：
<ul>
<li>模組層級的自用變數使用一個底線起始，如 _red_apple、_RedApple 或 _RED_APPLE。</li>
<li>Class 層級的自用變數或 Methods 使用兩個底線起始，如 __red_apple。</li>
</ul>
</li>
<li>必須複寫原始模組，如 Qt 使用小寫字首 redApple，則遵照原始模組。</li>
</ul>
<h3>類型註解</h3>
<p>建議對任何 Functions 與 Methods 都加上類型註解（參見 <a href="https://www.python.org/dev/peps/pep-0484/">PEP 484</a>），必要時在一般名稱也可做註記（回傳值無法推斷時）。</p>
<pre class="brush:py;auto-links:false;toolbar:false" contenteditable="false">if not row &gt; -1:
    return

# Here is not None!
item: MyItem = table.item(row)
item.do_something()</pre>
<p>若是回傳 None 值，可以不加上回傳值的註解。</p>
<pre class="brush:py;auto-links:false;toolbar:false" contenteditable="false">def func(a: bool):
    if a:
        return
    do_my_job()</pre>
<p>序列的樣式為 Sequence[T]、List[T]、Iterator[T] 等，唯獨 Tuple[T] 為固定長度，應標示 Tuple[T, ...]。</p>
<pre class="brush:py;auto-links:false;toolbar:false" contenteditable="false">def _join_more(iter_obj: Iterable[int]) -&gt; Tuple[int, ...]:
    """Convert iterable object to tuple."""
    return tuple(iter_obj) + (1,)</pre>
<p>若是可能為多種非繼承類型，使用 Union。</p>
<pre class="brush:py;auto-links:false;toolbar:false" contenteditable="false">s: Union[str, Sequence[bytes]] = s_func()</pre>
<p>若是可能為 None 值，應加上 Optional。</p>
<pre class="brush:py;auto-links:false;toolbar:false" contenteditable="false">def func(*, labels: Optional[Sequence[int]] = None):
    ...</pre>
<p>Functions 使用 Callable[[In_T1, InT2], Out_T]。</p>
<pre class="brush:py;auto-links:false;toolbar:false" contenteditable="false">def danger(func: Callable[[Any], Any]) -&gt; Callable[[Any], Any]:
    """My danger decorator."""

    def wrapper_func(*args):
        """Is danger function."""
        print("Danger!")
        return func(*args)

    return wrapper_func


@danger
def foo():
    ...</pre>
<p>造成遞迴引用類型時應改為字串。</p>
<pre class="brush:py;auto-links:false;toolbar:false" contenteditable="false">class MyClass:

    def __add__(self, p: 'MyClass') -&gt; 'MyClass':
        ...</pre><h1>參考</h1>
<p><a href="https://www.researchgate.net/profile/Jing-Shan_Zhao/publication/265747246_Design_of_Special_Planar_Linkages/links/55fc02db08ae07629e07d546/Design-of-Special-Planar-Linkages.pdf">Design of special planar linkages.pdf</a></p>
<p><a href="https://designengrlab.github.io/PMKS/">https://designengrlab.github.io/PMKS/</a> </p>
<p><a href="https://github.com/DesignEngrLab/PMKS">https://github.com/DesignEngrLab/PMKS</a> </p>
<p><a href="/downloads/Automated+Generation+of+Linkage+Loop+Equations+for+Planar+One+Degree-of-Freedom+Linkages,+Demonstrated+up+to+8-Bar.pdf">Automated Generation of Linkage Loop Equations for Planar One Degree-of-Freedom Linkages up to 8-Bar.pdf</a></p>
<p><a href="/downloads/Computer+Aided+Design+of+Eight-bar+Linkages.pdf">Computer Aided Design of Eight-bar Linkages.pdf</a></p>
<p><a href="/downloads/Implementation%20of an Open Source Planar Linkage Mechanism Simulation and Dimensional Synthesis System.pdf">Implementation of an Open Source Planar Linkage Mechanism Simulation and Dimensional Synthesis System.pdf</a></p>
<h4>自動拓樸結構合成</h4>
<p style="padding-left: 30px;"><a href="https://link.springer.com/chapter/10.1007/978-981-10-2875-5_74">Automatic Synthesis of Planar Simple Joint Kinematic Chains by Single Kinematic Chain Adding Method</a></p>
<h4>機構類型合成</h4>
<p style="padding-left: 30px;"><a href="https://cimec.org.ar/ojs/index.php/mc/article/viewFile/170/154">TYPE SYNTHESIS OF PLANAR LINKAGE MECHANISMS WITH ROTOIDAL AND PRISMATIC JOINTS</a></p>
<h4>網際連桿合成</h4>
<p style="padding-left: 30px;"><a href="https://link.springer.com/content/pdf/10.1007%2F978-1-4020-2212-8_65.pdf">A WEB-BASED OPTIMIZATION FOR FUNCTION SYNTHESIS OF PLANAR LINKAGE</a></p>
<h4>機構尺寸合成</h4>
<p style="padding-left: 30px;"><a href="https://link.springer.com/content/pdf/10.1007%2F978-94-007-4902-3_29.pdf">Dimensional Synthesis of Six-Bar Linkage as a Constrained RPR Chain</a></p>
<h4>C++ 程式轉為 Python 動態程式庫</h4>
<p style="padding-left: 30px;"><a href="https://github.com/pyslvs/pyslvs.github.io/files/2441549/AutoWIG.-.automatic.generation.of.python.bindings.for.Cpp.libraries.pdf">AutoWIG - automatic generation of python bindings for Cpp libraries.pdf</a><br/><a href="https://github.com/StatisKit/AutoWIG">https://github.com/StatisKit/AutoWIG</a></p>
<h4>其他</h4>
<p style="padding-left: 30px;">1990:<span> </span><a href="https://www.sciencedirect.com/science/article/pii/089571779090069Y" rel="nofollow">Number synthesis of kinematic chains based on permutation groups</a></p>
<p style="padding-left: 30px;">1995:<span> </span><a href="http://www.airitilibrary.com/Publication/alDetailedMesh?DocID=10217940-199512-201306050024-201306050024-1-8" rel="nofollow">Structural Synthesis of Mechanisms</a></p>
<p style="padding-left: 30px;">2007:<span> </span><a href="https://www.sciencedirect.com/science/article/pii/S0094114X06002205" rel="nofollow">A new theory for the topological structure analysis of kinematic chains and its applications</a></p>
<p style="padding-left: 30px;">2008:<span> </span><a href="https://www.sciencedirect.com/science/article/pii/S0094114X08000025" rel="nofollow">Computer-aided structure decomposition theory of kinematic chains and its applications</a></p>
<p style="padding-left: 30px;">2012:<span> </span><a href="https://www.sciencedirect.com/science/article/pii/S0094114X11001728" rel="nofollow">Synthesis of the whole family of planar 1-DOF kinematic chains and creation of their atlas database</a></p>
<p style="padding-left: 30px;">2013:<span> </span><a href="https://www.sciencedirect.com/science/article/pii/S0094114X13000852" rel="nofollow">Automated sketching of non-fractionated kinematic chains</a></p>
<p style="padding-left: 30px;">2014:<span> </span><a href="http://www.airitilibrary.com/Publication/alDetailedMesh1?DocID=U0026-2107201416312200" rel="nofollow">一般化運動鏈之數目合成</a></p>
<p style="padding-left: 30px;">2015:<span> </span><a href="https://www.sciencedirect.com/science/article/pii/S0094114X14002092" rel="nofollow">On the number synthesis of kinematic chains</a></p>
<p style="padding-left: 30px;">2015:<span> </span><a href="https://github.com/pyslvs/pyslvs.github.io/files/2452934/Automatic_Structural_Synthesis_of_Planar_Mechanisms_and_Its_Application_to_Creative_Design.pdf">Automatic_Structural_Synthesis_of_Planar_Mechanisms_and_Its_Application_to_Creative_Design.pdf</a></p>
<p style="padding-left: 30px;">2016:<span> </span><a href="https://www.sciencedirect.com/science/article/pii/S0094114X15002207" rel="nofollow">Automatic generation of the complete set of planar kinematic chains with up to six independent loops and up to 19 links</a></p>
<p style="padding-left: 30px;">2017:<span> </span><a href="https://www.sciencedirect.com/science/article/pii/S0094114X16303561" rel="nofollow">An automatic method for the connectivity calculation in planar closed kinematic chains</a></p>
<p style="padding-left: 30px;">2018:<span> </span><a href="https://www.sciencedirect.com/science/article/pii/S0094114X17316932" rel="nofollow">A new atlas for 8-bar kinematic chains with up to 3 prismatic pairs using Joint Sorting Code</a></p>
<p style="padding-left: 30px;">2018:<span> </span><a href="https://www.sciencedirect.com/science/article/pii/S0094114X17311126" rel="nofollow">A new method for the automatic sketching of planar kinematic chains</a></p>
<h4>CAD</h4>
<p style="padding-left: 30px;"><a href="https://freecadweb.org/">https://freecadweb.org/</a> </p>
<p style="padding-left: 30px;"><a href="https://www.blender.org/">https://www.blender.org/</a> </p>
<p style="padding-left: 30px;"><a href="https://github.com/tpaviot/oce">https://github.com/tpaviot/oce</a> </p>
<p style="padding-left: 30px;"><a href="https://github.com/LaughlinResearch/pyOCCT">https://github.com/LaughlinResearch/pyOCCT</a> </p>
<p></p>
<p></p><h2>Misc</h2>
<p><a href="https://www.iacr.org/archive/asiacrypt2003/08_invited_talk/28940325.pdf">The Secret and Beauty of Ancient Chinese Padlocks.pdf</a></p>
<p><iframe allowfullscreen="allowfullscreen" height="314" src="//www.youtube.com/embed/aZ02DvXHa6k" width="560"></iframe></p>
<p><iframe allowfullscreen="allowfullscreen" height="314" src="//www.youtube.com/embed/gCKc8OP9Azc" width="560"></iframe></p>
<p><iframe allowfullscreen="allowfullscreen" height="314" src="//www.youtube.com/embed/9iUjxXJrUcY" width="560"></iframe></p>
<p><iframe allowfullscreen="allowfullscreen" height="314" src="//www.youtube.com/embed/lRh2sUp0jcQ" width="560"></iframe></p>
<p></p>
<pre class="lang-bsh prettyprint prettyprinted"><code><span class="pln"></span></code></pre>